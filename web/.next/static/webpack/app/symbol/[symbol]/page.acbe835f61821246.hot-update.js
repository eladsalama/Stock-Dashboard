"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/symbol/[symbol]/page",{

/***/ "(app-pages-browser)/./src/components/dashboard/AdvancedPriceChart.tsx":
/*!*********************************************************!*\
  !*** ./src/components/dashboard/AdvancedPriceChart.tsx ***!
  \*********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ AdvancedPriceChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _layoutConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layoutConfig */ \"(app-pages-browser)/./src/components/dashboard/layoutConfig.ts\");\n/* harmony import */ var _auth_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../auth-context/AuthContext */ \"(app-pages-browser)/./src/components/auth-context/AuthContext.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction AdvancedPriceChart(param) {\n    let { data, mode, range, logScale, showVolMA, showBollingerBands = false, showEMA20 = false, symbol } = param;\n    _s();\n    const { theme } = (0,_auth_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [hover, setHover] = react__WEBPACK_IMPORTED_MODULE_1___default().useState(null);\n    // Note: symbol prop defined but not used - chart is data-driven from parent's data prop\n    // Parent (DashboardClient) handles all data fetching via api.history()\n    // Backend already fetches the correct range, so we use sourceData directly\n    const sourceData = data || [];\n    const TARGET_PER_RANGE = {\n        \"1d\": 18,\n        \"1w\": 40,\n        \"1m\": 70,\n        \"3m\": 90,\n        \"1y\": 140,\n        \"5y\": 220\n    };\n    const target = TARGET_PER_RANGE[range] || 120;\n    let bucketSize = sourceData.length > target ? Math.ceil(sourceData.length / target) : 1;\n    if (range === \"1d\") bucketSize = 1; // never bucket intraday so ticks align with real times\n    // Calculate indicators on RAW sourceData BEFORE bucketing for maximum accuracy\n    const rawEma20 = showEMA20 ? ema(sourceData.map((d)=>d.c), 20) : [];\n    const rawVolMA = showVolMA ? sma(sourceData.map((d)=>d.v), 20) : [];\n    const rawBollingerBands = showBollingerBands ? calculateBollingerBands(sourceData.map((d)=>d.c)) : {\n        upper: [],\n        lower: [],\n        middle: []\n    };\n    function bucketAggregate(src, size) {\n        if (size <= 1) return src;\n        const out = [];\n        for(let i = 0; i < src.length; i += size){\n            const slice = src.slice(i, i + size);\n            if (!slice.length) continue;\n            const o = slice[0].o;\n            const c = slice[slice.length - 1].c;\n            let h = -Infinity, l = Infinity, v = 0;\n            for (const s of slice){\n                if (s.h > h) h = s.h;\n                if (s.l < l) l = s.l;\n                v += s.v;\n            }\n            out.push({\n                t: slice[0].t,\n                o,\n                h,\n                l,\n                c,\n                v\n            });\n        }\n        return out;\n    }\n    // Bucket indicators alongside the data (take every Nth value to match bucketing)\n    function bucketIndicator(values, size) {\n        if (size <= 1) return values;\n        const out = [];\n        for(let i = 0; i < values.length; i += size){\n            out.push(values[i]); // Take the first value of each bucket\n        }\n        return out;\n    }\n    const baseData = bucketSize === 1 ? sourceData : bucketAggregate(sourceData, bucketSize);\n    const bucketedEma20 = bucketSize === 1 ? rawEma20 : bucketIndicator(rawEma20, bucketSize);\n    const bucketedVolMA = bucketSize === 1 ? rawVolMA : bucketIndicator(rawVolMA, bucketSize);\n    const bucketedBollingerBands = bucketSize === 1 ? rawBollingerBands : {\n        upper: bucketIndicator(rawBollingerBands.upper, bucketSize),\n        lower: bucketIndicator(rawBollingerBands.lower, bucketSize),\n        middle: bucketIndicator(rawBollingerBands.middle, bucketSize)\n    };\n    // Backend fetches extra candles for indicator calculation (20-50 depending on range)\n    // After bucketing, we hide proportionally fewer candles\n    const bufferPerRange = {\n        \"1d\": 50,\n        \"1w\": 50,\n        \"1m\": 50,\n        \"3m\": 50,\n        \"1y\": 50,\n        \"5y\": 50\n    };\n    const bufferCandles = Math.min(bufferPerRange[range], Math.floor(baseData.length * 0.2));\n    const displayData = baseData.slice(bufferCandles); // Hide first candles from user\n    const [windowIdx, setWindowIdx] = react__WEBPACK_IMPORTED_MODULE_1___default().useState(()=>[\n            0,\n            displayData.length - 1\n        ]);\n    // Reset window when displayData length changes (range change or new data)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setWindowIdx([\n            0,\n            displayData.length - 1\n        ]);\n    }, [\n        displayData.length\n    ]);\n    // Always show full range unless user zooms/pans (windowIdx acts as user override after first wheel/drag)\n    const [wStart, wEnd] = windowIdx;\n    const fullStart = 0;\n    const fullEnd = displayData.length - 1;\n    const effectiveStart = wStart === 0 && wEnd === displayData.length - 1 ? fullStart : Math.max(0, Math.min(wStart, fullEnd));\n    const effectiveEnd = wStart === 0 && wEnd === displayData.length - 1 ? fullEnd : Math.min(wEnd, fullEnd);\n    const safeEnd = Math.min(effectiveEnd, displayData.length - 1);\n    const safeStart = Math.max(0, Math.min(effectiveStart, safeEnd - 5));\n    const drawData = displayData.slice(safeStart, safeEnd + 1);\n    // Slice pre-calculated indicators to match drawData (offset by buffer + window)\n    const indicatorStart = bufferCandles + safeStart;\n    const indicatorEnd = bufferCandles + safeEnd + 1;\n    const ema20 = bucketedEma20.slice(indicatorStart, indicatorEnd);\n    const volMA = bucketedVolMA.slice(indicatorStart, indicatorEnd);\n    const bollingerBands = {\n        upper: bucketedBollingerBands.upper.slice(indicatorStart, indicatorEnd),\n        lower: bucketedBollingerBands.lower.slice(indicatorStart, indicatorEnd),\n        middle: bucketedBollingerBands.middle.slice(indicatorStart, indicatorEnd)\n    };\n    const closes = drawData.map((d)=>d.c), highs = drawData.map((d)=>d.h), lows = drawData.map((d)=>d.l);\n    function quantile(arr, q) {\n        if (!arr.length) return 0;\n        const sorted = [\n            ...arr\n        ].sort((a, b)=>a - b);\n        const pos = (sorted.length - 1) * q;\n        const base = Math.floor(pos);\n        const rest = pos - base;\n        return sorted[base + 1] !== undefined ? sorted[base] + rest * (sorted[base + 1] - sorted[base]) : sorted[base];\n    }\n    let min = quantile(lows, 0.005), max = quantile(highs, 0.995);\n    const lastC = drawData[drawData.length - 1];\n    if (lastC) {\n        if (lastC.l < min) min = lastC.l;\n        if (lastC.h > max) max = lastC.h;\n    }\n    const span = max - min || 1;\n    // Single scale variable\n    const S = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.CHART_SCALE; // affects vertical real estate\n    const hVisualBase = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.GRAPH_HEIGHT; // baseline visual height from config\n    const volumePortion = 0.23; // fraction reserved for volume area\n    const hVisual = hVisualBase * S;\n    const volH = hVisual * volumePortion;\n    const priceH = hVisual - volH;\n    const axisFooter = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_FOOTER_HEIGHT;\n    const h = hVisual + axisFooter;\n    const w = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.GRAPH_WIDTH;\n    const gutterRight = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_RIGHT_GUTTER;\n    const padTop = 8, padBottom = 6, padLeft = 4;\n    const priceArea = priceH - padTop - padBottom;\n    const up = closes[closes.length - 1] >= closes[0];\n    const priceW = w - gutterRight - padLeft;\n    // Index-based horizontal scale (removes time gaps for continuous display)\n    const numCandles = drawData.length;\n    function xForIdx(idx) {\n        return padLeft + idx / Math.max(1, numCandles - 1) * priceW;\n    }\n    // Store timestamps for labels\n    const drawTimes = drawData.map((d)=>new Date(d.t).getTime());\n    // Adaptive candle width from data density\n    let candleWidth;\n    if (numCandles <= 2) {\n        candleWidth = priceW / Math.max(1, numCandles) * 0.6;\n    } else {\n        candleWidth = priceW / numCandles * 0.8;\n    }\n    if (candleWidth < 3) candleWidth = 3;\n    if (candleWidth > 22) candleWidth = 22;\n    const linePts = drawData.map((d, idx)=>{\n        const x = xForIdx(idx);\n        const val = logScale ? (Math.log10(d.c) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (d.c - min) / span;\n        const y = padTop + (priceArea - val * priceArea);\n        return \"\".concat(x, \",\").concat(y);\n    }).join(\" \");\n    const hoverPoint = hover != null ? drawData[hover] : null;\n    function onMove(e) {\n        const rect = e.currentTarget.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        // Index-based hover: find nearest candle by x position\n        if (drawData.length === 0) return;\n        const xRatio = Math.max(0, Math.min(1, (x - padLeft) / (rect.width - gutterRight / w * rect.width)));\n        const idx = Math.round(xRatio * (numCandles - 1));\n        setHover(Math.max(0, Math.min(numCandles - 1, idx)));\n    }\n    const dragState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    function onWheel(e) {\n        e.preventDefault();\n        if (drawData.length < 10) return;\n        const delta = e.deltaY;\n        const factor = delta > 0 ? 1.1 : 0.9;\n        const currentLen = wEnd - wStart + 1;\n        const newLen = Math.max(20, Math.min(displayData.length, Math.round(currentLen * factor)));\n        const rect = e.currentTarget.getBoundingClientRect();\n        const xRatio = (e.clientX - rect.left - padLeft) / (rect.width - gutterRight);\n        const focusIdx = wStart + Math.round(currentLen * xRatio);\n        let newStart = focusIdx - Math.round(newLen * xRatio);\n        let newEnd = newStart + newLen - 1;\n        if (newStart < 0) {\n            newStart = 0;\n            newEnd = newLen - 1;\n        }\n        if (newEnd > displayData.length - 1) {\n            newEnd = displayData.length - 1;\n            newStart = newEnd - newLen + 1;\n        }\n        setWindowIdx([\n            newStart,\n            newEnd\n        ]);\n    }\n    function onPointerDown(e) {\n        e.currentTarget.setPointerCapture(e.pointerId);\n        dragState.current = {\n            startX: e.clientX,\n            startRange: windowIdx\n        };\n    }\n    function onPointerMove(e) {\n        if (!dragState.current) return;\n        const [s, eIdx] = dragState.current.startRange;\n        const len = eIdx - s + 1;\n        const pixelPerCandle = priceW / drawData.length;\n        const deltaPx = e.clientX - dragState.current.startX;\n        const shift = Math.round(-deltaPx / pixelPerCandle);\n        let newStart = s + shift;\n        let newEnd = newStart + len - 1;\n        if (newStart < 0) {\n            newStart = 0;\n            newEnd = len - 1;\n        }\n        if (newEnd > displayData.length - 1) {\n            newEnd = displayData.length - 1;\n            newStart = newEnd - len + 1;\n        }\n        setWindowIdx([\n            newStart,\n            newEnd\n        ]);\n    }\n    function onPointerUp() {\n        dragState.current = null;\n    }\n    function niceTicks(low, high) {\n        let target = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5;\n        const rawSpan = high - low || 1;\n        const roughStep = rawSpan / (target - 1);\n        const pow10 = Math.pow(10, Math.floor(Math.log10(roughStep)));\n        const multiples = [\n            1,\n            2,\n            2.5,\n            5,\n            10\n        ];\n        const found = multiples.find((m)=>m * pow10 >= roughStep) || multiples[multiples.length - 1];\n        const step = found * pow10;\n        const first = Math.ceil(low / step) * step;\n        const ticks = [];\n        for(let v = first; v <= high; v += step)ticks.push(v);\n        return ticks;\n    }\n    // Time ticks per explicit spec\n    const timeTicks = [];\n    if (drawData.length > 1) {\n        if (range === \"1d\") {\n            // Show label every hour for cleaner display\n            const seen = new Set();\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                const hh = d.getHours();\n                const mm = d.getMinutes();\n                // Show label every hour on the hour\n                if (mm === 0) {\n                    const timeKey = \"\".concat(hh, \":00\");\n                    if (!seen.has(timeKey)) {\n                        seen.add(timeKey);\n                        timeTicks.push({\n                            x: xForIdx(idx),\n                            label: d.toLocaleTimeString(\"en-US\", {\n                                hour: \"numeric\",\n                                minute: \"2-digit\",\n                                hour12: false\n                            })\n                        });\n                    }\n                }\n            });\n        } else if (range === \"1w\") {\n            const seen = new Set();\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                const k = d.toDateString();\n                if (!seen.has(k)) {\n                    seen.add(k);\n                    timeTicks.push({\n                        x: xForIdx(idx),\n                        label: d.toLocaleDateString(undefined, {\n                            weekday: \"short\"\n                        }).toUpperCase()\n                    });\n                }\n            });\n        } else if (range === \"1m\") {\n            const seen = new Set();\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                if (d.getDay() === 1) {\n                    const key = d.getFullYear() + \"-\" + d.getMonth() + \"-\" + d.getDate();\n                    if (!seen.has(key)) {\n                        seen.add(key);\n                        timeTicks.push({\n                            x: xForIdx(idx),\n                            label: d.getMonth() + 1 + \"/\" + d.getDate()\n                        });\n                    }\n                }\n            });\n        } else if (range === \"3m\") {\n            let mondayCount = 0;\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                if (d.getDay() === 1) {\n                    if (mondayCount % 3 === 0) timeTicks.push({\n                        x: xForIdx(idx),\n                        label: d.getMonth() + 1 + \"/\" + d.getDate()\n                    });\n                    mondayCount++;\n                }\n            });\n        } else if (range === \"1y\") {\n            const seenMonth = new Set();\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                const mk = d.getFullYear() + \"-\" + d.getMonth();\n                if (!seenMonth.has(mk) && d.getDate() <= 7) {\n                    seenMonth.add(mk);\n                    timeTicks.push({\n                        x: xForIdx(idx),\n                        label: d.toLocaleString(undefined, {\n                            month: \"short\"\n                        }).toUpperCase()\n                    });\n                }\n            });\n        } else if (range === \"5y\") {\n            const seenYear = new Set();\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                if (!seenYear.has(d.getFullYear()) && d.getMonth() < 2) {\n                    seenYear.add(d.getFullYear());\n                    timeTicks.push({\n                        x: xForIdx(idx),\n                        label: String(d.getFullYear())\n                    });\n                }\n            });\n        }\n    }\n    const maxVol = Math.max(...drawData.map((d)=>d.v), 1);\n    const magnitude = Math.abs(max);\n    const decimals = magnitude >= 500 ? 0 : magnitude >= 100 ? 1 : 2;\n    function sma(src, period) {\n        if (src.length < period) return [];\n        const out = new Array(period - 1).fill(null); // Pad beginning with nulls\n        let sum = 0;\n        for(let i = 0; i < src.length; i++){\n            sum += src[i];\n            if (i >= period) sum -= src[i - period];\n            if (i >= period - 1) out.push(sum / period);\n        }\n        return out;\n    }\n    function ema(src, period) {\n        if (src.length < period) return [];\n        const k = 2 / (period + 1);\n        const out = new Array(period - 1).fill(null); // Pad beginning with nulls\n        // Start with SMA for first value\n        let sum = 0;\n        for(let i = 0; i < period; i++){\n            sum += src[i];\n        }\n        out.push(sum / period);\n        // Then use EMA formula\n        for(let i = period; i < src.length; i++){\n            out.push(src[i] * k + out[out.length - 1] * (1 - k));\n        }\n        return out;\n    }\n    function calculateBollingerBands(closes) {\n        let period = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20, stdDevMultiplier = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n        if (closes.length < period) return {\n            upper: [],\n            lower: [],\n            middle: []\n        };\n        const middle = new Array(period - 1).fill(null);\n        const upper = new Array(period - 1).fill(null);\n        const lower = new Array(period - 1).fill(null);\n        for(let i = period - 1; i < closes.length; i++){\n            const slice = closes.slice(i - period + 1, i + 1);\n            const avg = slice.reduce((sum, val)=>sum + val, 0) / period;\n            const variance = slice.reduce((sum, val)=>sum + Math.pow(val - avg, 2), 0) / period;\n            const stdDev = Math.sqrt(variance);\n            middle.push(avg);\n            upper.push(avg + stdDevMultiplier * stdDev);\n            lower.push(avg - stdDevMultiplier * stdDev);\n        }\n        return {\n            upper,\n            lower,\n            middle\n        };\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            position: \"absolute\",\n            inset: 0,\n            fontSize: 11\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                viewBox: \"0 0 \".concat(w, \" \").concat(h),\n                preserveAspectRatio: \"none\",\n                style: {\n                    width: \"100%\",\n                    height: \"100%\",\n                    cursor: \"crosshair\",\n                    userSelect: \"none\",\n                    fontFamily: \"system-ui, ui-monospace, Menlo, monospace\"\n                },\n                onMouseMove: onMove,\n                onMouseLeave: ()=>setHover(null),\n                onWheel: onWheel,\n                onPointerDown: onPointerDown,\n                onPointerMove: onPointerMove,\n                onPointerUp: onPointerUp,\n                children: [\n                    niceTicks(min, max, 5).map((t)=>{\n                        const y = 8 + (priceArea - (t - min) / span * priceArea);\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                    x1: padLeft,\n                                    x2: padLeft + priceW,\n                                    y1: y,\n                                    y2: y,\n                                    stroke: theme === \"light\" ? \"#d0d7de\" : \"#30363d\",\n                                    strokeWidth: 1\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 392,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                                    x: padLeft + priceW + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_Y_LABEL_X_OFFSET,\n                                    y: y + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_Y_FONT_SIZE / 3,\n                                    fill: theme === \"light\" ? \"#000000\" : \"#ffffff\",\n                                    fontSize: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_Y_FONT_SIZE,\n                                    children: t.toFixed(decimals)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 400,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, t.toFixed(6), true, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 391,\n                            columnNumber: 13\n                        }, this);\n                    }),\n                    timeTicks.map((t, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                            x1: t.x,\n                            x2: t.x,\n                            y1: 0,\n                            y2: hVisual,\n                            stroke: theme === \"light\" ? \"#d0d7de\" : \"#30363d\",\n                            strokeWidth: 1\n                        }, \"xtick-\" + i, false, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 414,\n                            columnNumber: 11\n                        }, this)),\n                    showBollingerBands && bollingerBands.upper.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polygon\", {\n                                points: (()=>{\n                                    const points = [];\n                                    // Upper band\n                                    for(let i = 0; i < bollingerBands.upper.length; i++){\n                                        const upperVal = bollingerBands.upper[i];\n                                        if (upperVal === null) continue;\n                                        const x = xForIdx(i);\n                                        const val = (upperVal - min) / span;\n                                        const y = padTop + (priceArea - val * priceArea);\n                                        if (isFinite(x) && isFinite(y)) {\n                                            points.push(\"\".concat(x, \",\").concat(y));\n                                        }\n                                    }\n                                    // Lower band (reversed)\n                                    for(let i = bollingerBands.lower.length - 1; i >= 0; i--){\n                                        const lowerVal = bollingerBands.lower[i];\n                                        if (lowerVal === null) continue;\n                                        const x = xForIdx(i);\n                                        const val = (lowerVal - min) / span;\n                                        const y = padTop + (priceArea - val * priceArea);\n                                        if (isFinite(x) && isFinite(y)) {\n                                            points.push(\"\".concat(x, \",\").concat(y));\n                                        }\n                                    }\n                                    return points.join(\" \");\n                                })(),\n                                fill: \"rgba(135, 206, 235, 0.15)\",\n                                stroke: \"none\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                lineNumber: 429,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polyline\", {\n                                points: bollingerBands.upper.map((v, i)=>{\n                                    if (v === null) return null;\n                                    const x = xForIdx(i);\n                                    const val = (v - min) / span;\n                                    const y = padTop + (priceArea - val * priceArea);\n                                    return \"\".concat(x, \",\").concat(y);\n                                }).filter((p)=>p !== null).join(\" \"),\n                                fill: \"none\",\n                                stroke: \"rgba(135, 206, 235, 0.8)\",\n                                strokeWidth: 1,\n                                vectorEffect: \"non-scaling-stroke\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                lineNumber: 461,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polyline\", {\n                                points: bollingerBands.lower.map((v, i)=>{\n                                    if (v === null) return null;\n                                    const x = xForIdx(i);\n                                    const val = (v - min) / span;\n                                    const y = padTop + (priceArea - val * priceArea);\n                                    return \"\".concat(x, \",\").concat(y);\n                                }).filter((p)=>p !== null).join(\" \"),\n                                fill: \"none\",\n                                stroke: \"rgba(135, 206, 235, 0.8)\",\n                                strokeWidth: 1,\n                                vectorEffect: \"non-scaling-stroke\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                lineNumber: 479,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true),\n                    mode === \"line\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polyline\", {\n                        points: linePts,\n                        fill: \"none\",\n                        stroke: up ? \"var(--color-success)\" : \"var(--color-danger)\",\n                        strokeWidth: 2,\n                        vectorEffect: \"non-scaling-stroke\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                        lineNumber: 498,\n                        columnNumber: 11\n                    }, this),\n                    mode === \"candles\" && drawData.map((d, idx)=>{\n                        const centerX = xForIdx(idx);\n                        const x = centerX - candleWidth / 2;\n                        const valOpen = logScale ? (Math.log10(d.o) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (d.o - min) / span;\n                        const valClose = logScale ? (Math.log10(d.c) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (d.c - min) / span;\n                        const valHigh = logScale ? (Math.log10(d.h) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (d.h - min) / span;\n                        const valLow = logScale ? (Math.log10(d.l) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (d.l - min) / span;\n                        const openY = 8 + (priceArea - valOpen * priceArea);\n                        const closeY = 8 + (priceArea - valClose * priceArea);\n                        const highY = 8 + (priceArea - valHigh * priceArea);\n                        const lowY = 8 + (priceArea - valLow * priceArea);\n                        const rising = d.c >= d.o;\n                        const pct = Math.min(0.05, Math.max(-0.05, (d.c - d.o) / d.o));\n                        const intensity = Math.abs(pct) / 0.05;\n                        const baseColor = rising ? \"var(--color-success)\" : \"var(--color-danger)\";\n                        const fill = rising ? \"rgba(35,134,54,\".concat(0.35 + 0.55 * intensity, \")\") : \"rgba(248,81,73,\".concat(0.35 + 0.55 * intensity, \")\");\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                    x1: x + candleWidth / 2,\n                                    x2: x + candleWidth / 2,\n                                    y1: highY,\n                                    y2: lowY,\n                                    stroke: baseColor,\n                                    strokeWidth: 1\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 535,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                                    x: x,\n                                    y: Math.min(openY, closeY),\n                                    width: candleWidth,\n                                    height: Math.max(2, Math.abs(closeY - openY)),\n                                    fill: fill,\n                                    stroke: baseColor,\n                                    strokeWidth: 0.5\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 543,\n                                    columnNumber: 17\n                                }, this)\n                            ]\n                        }, d.t, true, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 534,\n                            columnNumber: 15\n                        }, this);\n                    }),\n                    showEMA20 && ema20.length && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polyline\", {\n                        points: ema20.map((v, i)=>{\n                            if (v === null) return null;\n                            const x = xForIdx(i);\n                            const val = logScale ? (Math.log10(v) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (v - min) / span;\n                            const y = 8 + (priceArea - val * priceArea);\n                            return \"\".concat(x, \",\").concat(y);\n                        }).filter((p)=>p !== null).join(\" \"),\n                        fill: \"none\",\n                        stroke: \"#ff9500\",\n                        strokeWidth: 1.4,\n                        vectorEffect: \"non-scaling-stroke\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                        lineNumber: 558,\n                        columnNumber: 11\n                    }, this),\n                    drawData.map((d, idx)=>{\n                        const centerX = xForIdx(idx);\n                        const x = centerX - candleWidth / 2;\n                        const volRatio = d.v / maxVol;\n                        let barH = volRatio * (volH - 16);\n                        // Minimum bar height for visibility (especially for low after-hours volume)\n                        const minBarHeight = 2;\n                        if (barH > 0 && barH < minBarHeight) barH = minBarHeight;\n                        const y = priceH + (volH - barH);\n                        const rising = d.c >= d.o;\n                        // Check if this is extended hours (before 9:30 or after 16:00 ET)\n                        const candleDate = new Date(d.t);\n                        const hour = candleDate.getHours();\n                        const minute = candleDate.getMinutes();\n                        const timeInMinutes = hour * 60 + minute;\n                        const marketOpen = 9 * 60 + 30; // 9:30 AM\n                        const marketClose = 16 * 60; // 4:00 PM\n                        const isExtendedHours = timeInMinutes < marketOpen || timeInMinutes >= marketClose;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                            x: x,\n                            y: y,\n                            width: candleWidth,\n                            height: barH,\n                            fill: rising ? \"var(--color-success)\" : \"var(--color-danger)\",\n                            opacity: isExtendedHours ? 0.2 : 0.35\n                        }, d.t + \":vol\", false, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 601,\n                            columnNumber: 13\n                        }, this);\n                    }),\n                    showVolMA && volMA.length && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polyline\", {\n                        points: volMA.map((v, i)=>{\n                            if (v === null) return null;\n                            const x = xForIdx(i);\n                            const ratio = v / maxVol;\n                            const barH = ratio * (volH - 16);\n                            const y = priceH + (volH - barH);\n                            return \"\".concat(x, \",\").concat(y);\n                        }).filter((p)=>p !== null).join(\" \"),\n                        fill: \"none\",\n                        stroke: \"#58a6ff\",\n                        strokeWidth: 1,\n                        vectorEffect: \"non-scaling-stroke\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                        lineNumber: 613,\n                        columnNumber: 11\n                    }, this),\n                    hoverPoint && (()=>{\n                        const x = xForIdx(hover);\n                        const y = 8 + (priceArea - (hoverPoint.c - min) / span * priceArea);\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                    x1: x,\n                                    x2: x,\n                                    y1: 0,\n                                    y2: priceH,\n                                    stroke: theme === \"light\" ? \"#656d76\" : \"#7d8590\",\n                                    strokeDasharray: \"4 3\",\n                                    strokeWidth: 1\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 637,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                    x1: 0,\n                                    x2: w,\n                                    y1: y,\n                                    y2: y,\n                                    stroke: theme === \"light\" ? \"#656d76\" : \"#7d8590\",\n                                    strokeDasharray: \"4 3\",\n                                    strokeWidth: 1\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 646,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    cx: x,\n                                    cy: y,\n                                    r: 5,\n                                    fill: \"var(--color-bg)\",\n                                    stroke: up ? \"var(--color-success)\" : \"var(--color-danger)\",\n                                    strokeWidth: 2\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 655,\n                                    columnNumber: 17\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 636,\n                            columnNumber: 15\n                        }, this);\n                    })(),\n                    drawData.length > 0 && (()=>{\n                        const last = drawData[drawData.length - 1];\n                        const y = 8 + (priceArea - (last.c - min) / span * priceArea);\n                        const isUp = last.c >= closes[0];\n                        // Brighter, higher contrast colors for last price label\n                        const brightGreen = \"#00ff41\"; // Bright neon green\n                        const brightRed = \"#ff3366\"; // Bright red\n                        const color = isUp ? brightGreen : brightRed;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                    x1: padLeft,\n                                    x2: padLeft + priceW,\n                                    y1: y,\n                                    y2: y,\n                                    stroke: color,\n                                    strokeDasharray: \"2 4\",\n                                    strokeWidth: 1\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 678,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                                    x: padLeft + priceW + 4,\n                                    y: y - _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_HEIGHT / 2,\n                                    width: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_WIDTH,\n                                    height: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_HEIGHT,\n                                    fill: isUp ? theme === \"light\" ? \"#e6fff0\" : \"#002211\" : theme === \"light\" ? \"#ffe6ee\" : \"#2d0011\",\n                                    stroke: color,\n                                    rx: 3\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 687,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                                    x: padLeft + priceW + 4 + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_WIDTH / 2,\n                                    y: y + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_FONT_SIZE / 3,\n                                    textAnchor: \"middle\",\n                                    fill: color,\n                                    fontSize: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_FONT_SIZE,\n                                    fontWeight: 600,\n                                    children: last.c.toFixed(decimals)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 698,\n                                    columnNumber: 17\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 677,\n                            columnNumber: 15\n                        }, this);\n                    })(),\n                    (()=>{\n                        var _drawData_;\n                        const labels = [];\n                        // Main price position\n                        const lastPrice = ((_drawData_ = drawData[drawData.length - 1]) === null || _drawData_ === void 0 ? void 0 : _drawData_.c) || 0;\n                        const priceY = 8 + (priceArea - (lastPrice - min) / span * priceArea);\n                        // EMA20\n                        if (showEMA20 && ema20.length > 0) {\n                            const lastEma = ema20[ema20.length - 1];\n                            if (lastEma !== null) {\n                                labels.push({\n                                    y: 8 + (priceArea - (lastEma - min) / span * priceArea),\n                                    value: lastEma,\n                                    color: \"#ff9500\",\n                                    bgColor: theme === \"light\" ? \"#fff5e6\" : \"#2d2400\",\n                                    stroke: \"#ff9500\"\n                                });\n                            }\n                        }\n                        // Bollinger Bands Upper\n                        if (showBollingerBands && bollingerBands.upper.length > 0) {\n                            const lastUpper = bollingerBands.upper[bollingerBands.upper.length - 1];\n                            if (lastUpper !== null) {\n                                labels.push({\n                                    y: 8 + (priceArea - (lastUpper - min) / span * priceArea),\n                                    value: lastUpper,\n                                    color: \"rgba(135, 206, 235, 1)\",\n                                    bgColor: theme === \"light\" ? \"#e6f7ff\" : \"#001a2d\",\n                                    stroke: \"rgba(135, 206, 235, 0.8)\"\n                                });\n                            }\n                        }\n                        // Bollinger Bands Lower\n                        if (showBollingerBands && bollingerBands.lower.length > 0) {\n                            const lastLower = bollingerBands.lower[bollingerBands.lower.length - 1];\n                            if (lastLower !== null) {\n                                labels.push({\n                                    y: 8 + (priceArea - (lastLower - min) / span * priceArea),\n                                    value: lastLower,\n                                    color: \"rgba(135, 206, 235, 1)\",\n                                    bgColor: theme === \"light\" ? \"#e6f7ff\" : \"#001a2d\",\n                                    stroke: \"rgba(135, 206, 235, 0.8)\"\n                                });\n                            }\n                        }\n                        // Adjust positions to avoid overlaps\n                        const minGap = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_HEIGHT + 2;\n                        const adjustedLabels = labels.map((label)=>{\n                            let adjustedY = label.y;\n                            // Check overlap with main price label\n                            if (Math.abs(adjustedY - priceY) < minGap) {\n                                // Move above or below based on which side has more space\n                                if (adjustedY < priceY) {\n                                    // Label is above price, move it further up\n                                    adjustedY = priceY - minGap;\n                                } else {\n                                    // Label is below price, move it further down\n                                    adjustedY = priceY + minGap;\n                                }\n                            }\n                            return {\n                                ...label,\n                                y: adjustedY\n                            };\n                        });\n                        // Sort by Y position and adjust for overlaps between indicators\n                        adjustedLabels.sort((a, b)=>a.y - b.y);\n                        for(let i = 1; i < adjustedLabels.length; i++){\n                            if (adjustedLabels[i].y - adjustedLabels[i - 1].y < minGap) {\n                                adjustedLabels[i].y = adjustedLabels[i - 1].y + minGap;\n                            }\n                        }\n                        return adjustedLabels.map((label, idx)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                                        x: padLeft + priceW + 4,\n                                        y: label.y - _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_HEIGHT / 2,\n                                        width: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_WIDTH,\n                                        height: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_HEIGHT,\n                                        fill: label.bgColor,\n                                        stroke: label.stroke,\n                                        rx: 2\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                        lineNumber: 792,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                                        x: padLeft + priceW + 4 + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_WIDTH / 2,\n                                        y: label.y + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_FONT_SIZE / 3,\n                                        textAnchor: \"middle\",\n                                        fill: label.color,\n                                        fontSize: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_FONT_SIZE,\n                                        fontWeight: 600,\n                                        children: label.value.toFixed(decimals)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                        lineNumber: 801,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, \"indicator-label-\".concat(idx), true, {\n                                fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                lineNumber: 791,\n                                columnNumber: 13\n                            }, this));\n                    })(),\n                    timeTicks.map((t, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                            x: t.x,\n                            y: h - 6,\n                            textAnchor: \"middle\",\n                            fontSize: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_X_FONT_SIZE,\n                            fill: theme === \"light\" ? \"#000000\" : \"#ffffff\",\n                            children: t.label\n                        }, \"xlabel-\" + i, false, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 816,\n                            columnNumber: 11\n                        }, this))\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                lineNumber: 371,\n                columnNumber: 7\n            }, this),\n            hoverPoint && (()=>{\n                const hoverX = xForIdx(hover);\n                const hoverXPercent = (hoverX - padLeft) / priceW * 100;\n                // Estimate tooltip width (approximate)\n                const tooltipWidth = 120; // pixels\n                const chartLeftPx = padLeft;\n                const chartRightPx = padLeft + priceW;\n                // Check if tooltip would overflow on right or left\n                const wouldOverflowRight = hoverX + tooltipWidth / 2 > chartRightPx;\n                const wouldOverflowLeft = hoverX - tooltipWidth / 2 < chartLeftPx;\n                let leftPos;\n                let rightPos;\n                let transform;\n                if (wouldOverflowRight) {\n                    // Anchor to right side of hover point\n                    rightPos = \"\".concat(100 - hoverXPercent, \"%\");\n                    transform = \"translateX(100%)\";\n                } else if (wouldOverflowLeft) {\n                    // Anchor to left side of hover point\n                    leftPos = \"\".concat(hoverXPercent, \"%\");\n                    transform = \"translateX(0)\";\n                } else {\n                    // Center on hover point (default)\n                    leftPos = \"\".concat(hoverXPercent, \"%\");\n                    transform = \"translateX(-50%)\";\n                }\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        position: \"absolute\",\n                        left: leftPos,\n                        right: rightPos,\n                        top: 8,\n                        background: theme === \"light\" ? \"rgba(255,255,255,0.95)\" : \"rgba(0,0,0,0.78)\",\n                        padding: \"6px 8px\",\n                        borderRadius: 4,\n                        pointerEvents: \"none\",\n                        border: theme === \"light\" ? \"1px solid #d0d7de\" : \"1px solid #30363d\",\n                        whiteSpace: \"nowrap\",\n                        backdropFilter: \"blur(2px)\",\n                        color: theme === \"light\" ? \"#24292f\" : \"#e6edf3\",\n                        transform\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontSize: 11,\n                                opacity: 0.7\n                            },\n                            children: new Date(hoverPoint.t).toLocaleString()\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 877,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: 600\n                            },\n                            children: hoverPoint.c.toFixed(2)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 880,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                    lineNumber: 860,\n                    columnNumber: 11\n                }, this);\n            })()\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n        lineNumber: 370,\n        columnNumber: 5\n    }, this);\n}\n_s(AdvancedPriceChart, \"lHy/StbT2zLTwfx1ruRUmtw45WE=\", false, function() {\n    return [\n        _auth_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth\n    ];\n});\n_c = AdvancedPriceChart;\nvar _c;\n$RefreshReg$(_c, \"AdvancedPriceChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Rhc2hib2FyZC9BZHZhbmNlZFByaWNlQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQ2lEO0FBRUg7QUFDUTtBQXFCdkMsU0FBU0ssbUJBQW1CLEtBU25DO1FBVG1DLEVBQ3pDQyxJQUFJLEVBQ0pDLElBQUksRUFDSkMsS0FBSyxFQUNMQyxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMscUJBQXFCLEtBQUssRUFDMUJDLFlBQVksS0FBSyxFQUNqQkMsTUFBTSxFQUNBLEdBVG1DOztJQVV6QyxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHVixrRUFBT0E7SUFDekIsTUFBTSxDQUFDVyxPQUFPQyxTQUFTLEdBQUdoQixxREFBYyxDQUFnQjtJQUV4RCx3RkFBd0Y7SUFDeEYsdUVBQXVFO0lBQ3ZFLDJFQUEyRTtJQUUzRSxNQUFNa0IsYUFBdUJaLFFBQVEsRUFBRTtJQUV2QyxNQUFNYSxtQkFBNkM7UUFDakQsTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO1FBQ04sTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO0lBQ1I7SUFDQSxNQUFNQyxTQUFTRCxnQkFBZ0IsQ0FBQ1gsTUFBTSxJQUFJO0lBQzFDLElBQUlhLGFBQWFILFdBQVdJLE1BQU0sR0FBR0YsU0FBU0csS0FBS0MsSUFBSSxDQUFDTixXQUFXSSxNQUFNLEdBQUdGLFVBQVU7SUFDdEYsSUFBSVosVUFBVSxNQUFNYSxhQUFhLEdBQUcsdURBQXVEO0lBRTNGLCtFQUErRTtJQUMvRSxNQUFNSSxXQUFXYixZQUFZYyxJQUFJUixXQUFXUyxHQUFHLENBQUMsQ0FBQ0MsSUFBY0EsRUFBRUMsQ0FBQyxHQUFHLE1BQU0sRUFBRTtJQUM3RSxNQUFNQyxXQUFXcEIsWUFBWXFCLElBQUliLFdBQVdTLEdBQUcsQ0FBQyxDQUFDQyxJQUFjQSxFQUFFSSxDQUFDLEdBQUcsTUFBTSxFQUFFO0lBQzdFLE1BQU1DLG9CQUFvQnRCLHFCQUN0QnVCLHdCQUF3QmhC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QUFDNE4sT0FBTyxDQUFDOzs7Ozs7Ozs7Ozs7WUFHN0Q7Ozs7Ozs7QUFHTjtHQTUxQndCcFA7O1FBVUpELDhEQUFPQTs7O0tBVkhDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2Rhc2hib2FyZC9BZHZhbmNlZFByaWNlQ2hhcnQudHN4P2NlN2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyBSYW5nZUtleSB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xyXG5pbXBvcnQgeyBMYXlvdXRDb25maWcgfSBmcm9tIFwiLi9sYXlvdXRDb25maWdcIjtcclxuaW1wb3J0IHsgdXNlQXV0aCB9IGZyb20gXCIuLi9hdXRoLWNvbnRleHQvQXV0aENvbnRleHRcIjtcclxuXHJcbmludGVyZmFjZSBDYW5kbGUge1xyXG4gIHQ6IHN0cmluZztcclxuICBvOiBudW1iZXI7XHJcbiAgaDogbnVtYmVyO1xyXG4gIGw6IG51bWJlcjtcclxuICBjOiBudW1iZXI7XHJcbiAgdjogbnVtYmVyO1xyXG59XHJcbmludGVyZmFjZSBQcm9wcyB7XHJcbiAgZGF0YTogQ2FuZGxlW107XHJcbiAgbW9kZTogXCJsaW5lXCIgfCBcImNhbmRsZXNcIjtcclxuICByYW5nZTogUmFuZ2VLZXk7XHJcbiAgbG9nU2NhbGU6IGJvb2xlYW47XHJcbiAgc2hvd1ZvbE1BOiBib29sZWFuO1xyXG4gIHNob3dCb2xsaW5nZXJCYW5kcz86IGJvb2xlYW47XHJcbiAgc2hvd0VNQTIwPzogYm9vbGVhbjtcclxuICBzeW1ib2w/OiBzdHJpbmc7IC8vIG9wdGlvbmFsIHN5bWJvbCB0byBzZWxmLWZldGNoIGZyb20gWWFob28gaWYgZGF0YSBub3QgcHJvdmlkZWRcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWR2YW5jZWRQcmljZUNoYXJ0KHtcclxuICBkYXRhLFxyXG4gIG1vZGUsXHJcbiAgcmFuZ2UsXHJcbiAgbG9nU2NhbGUsXHJcbiAgc2hvd1ZvbE1BLFxyXG4gIHNob3dCb2xsaW5nZXJCYW5kcyA9IGZhbHNlLFxyXG4gIHNob3dFTUEyMCA9IGZhbHNlLFxyXG4gIHN5bWJvbCxcclxufTogUHJvcHMpIHtcclxuICBjb25zdCB7IHRoZW1lIH0gPSB1c2VBdXRoKCk7XHJcbiAgY29uc3QgW2hvdmVyLCBzZXRIb3Zlcl0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcclxuXHJcbiAgLy8gTm90ZTogc3ltYm9sIHByb3AgZGVmaW5lZCBidXQgbm90IHVzZWQgLSBjaGFydCBpcyBkYXRhLWRyaXZlbiBmcm9tIHBhcmVudCdzIGRhdGEgcHJvcFxyXG4gIC8vIFBhcmVudCAoRGFzaGJvYXJkQ2xpZW50KSBoYW5kbGVzIGFsbCBkYXRhIGZldGNoaW5nIHZpYSBhcGkuaGlzdG9yeSgpXHJcbiAgLy8gQmFja2VuZCBhbHJlYWR5IGZldGNoZXMgdGhlIGNvcnJlY3QgcmFuZ2UsIHNvIHdlIHVzZSBzb3VyY2VEYXRhIGRpcmVjdGx5XHJcblxyXG4gIGNvbnN0IHNvdXJjZURhdGE6IENhbmRsZVtdID0gZGF0YSB8fCBbXTtcclxuICBcclxuICBjb25zdCBUQVJHRVRfUEVSX1JBTkdFOiBSZWNvcmQ8UmFuZ2VLZXksIG51bWJlcj4gPSB7XHJcbiAgICBcIjFkXCI6IDE4LFxyXG4gICAgXCIxd1wiOiA0MCxcclxuICAgIFwiMW1cIjogNzAsXHJcbiAgICBcIjNtXCI6IDkwLFxyXG4gICAgXCIxeVwiOiAxNDAsXHJcbiAgICBcIjV5XCI6IDIyMCxcclxuICB9O1xyXG4gIGNvbnN0IHRhcmdldCA9IFRBUkdFVF9QRVJfUkFOR0VbcmFuZ2VdIHx8IDEyMDtcclxuICBsZXQgYnVja2V0U2l6ZSA9IHNvdXJjZURhdGEubGVuZ3RoID4gdGFyZ2V0ID8gTWF0aC5jZWlsKHNvdXJjZURhdGEubGVuZ3RoIC8gdGFyZ2V0KSA6IDE7XHJcbiAgaWYgKHJhbmdlID09PSAnMWQnKSBidWNrZXRTaXplID0gMTsgLy8gbmV2ZXIgYnVja2V0IGludHJhZGF5IHNvIHRpY2tzIGFsaWduIHdpdGggcmVhbCB0aW1lc1xyXG4gIFxyXG4gIC8vIENhbGN1bGF0ZSBpbmRpY2F0b3JzIG9uIFJBVyBzb3VyY2VEYXRhIEJFRk9SRSBidWNrZXRpbmcgZm9yIG1heGltdW0gYWNjdXJhY3lcclxuICBjb25zdCByYXdFbWEyMCA9IHNob3dFTUEyMCA/IGVtYShzb3VyY2VEYXRhLm1hcCgoZDogQ2FuZGxlKSA9PiBkLmMpLCAyMCkgOiBbXTtcclxuICBjb25zdCByYXdWb2xNQSA9IHNob3dWb2xNQSA/IHNtYShzb3VyY2VEYXRhLm1hcCgoZDogQ2FuZGxlKSA9PiBkLnYpLCAyMCkgOiBbXTtcclxuICBjb25zdCByYXdCb2xsaW5nZXJCYW5kcyA9IHNob3dCb2xsaW5nZXJCYW5kcyBcclxuICAgID8gY2FsY3VsYXRlQm9sbGluZ2VyQmFuZHMoc291cmNlRGF0YS5tYXAoKGQ6IENhbmRsZSkgPT4gZC5jKSkgXHJcbiAgICA6IHsgdXBwZXI6IFtdLCBsb3dlcjogW10sIG1pZGRsZTogW10gfTtcclxuICBcclxuICBmdW5jdGlvbiBidWNrZXRBZ2dyZWdhdGUoc3JjOiBDYW5kbGVbXSwgc2l6ZTogbnVtYmVyKSB7XHJcbiAgICBpZiAoc2l6ZSA8PSAxKSByZXR1cm4gc3JjO1xyXG4gICAgY29uc3Qgb3V0OiBDYW5kbGVbXSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcmMubGVuZ3RoOyBpICs9IHNpemUpIHtcclxuICAgICAgY29uc3Qgc2xpY2UgPSBzcmMuc2xpY2UoaSwgaSArIHNpemUpO1xyXG4gICAgICBpZiAoIXNsaWNlLmxlbmd0aCkgY29udGludWU7XHJcbiAgICAgIGNvbnN0IG8gPSBzbGljZVswXS5vO1xyXG4gICAgICBjb25zdCBjID0gc2xpY2Vbc2xpY2UubGVuZ3RoIC0gMV0uYztcclxuICAgICAgbGV0IGggPSAtSW5maW5pdHksXHJcbiAgICAgICAgbCA9IEluZmluaXR5LFxyXG4gICAgICAgIHYgPSAwO1xyXG4gICAgICBmb3IgKGNvbnN0IHMgb2Ygc2xpY2UpIHtcclxuICAgICAgICBpZiAocy5oID4gaCkgaCA9IHMuaDtcclxuICAgICAgICBpZiAocy5sIDwgbCkgbCA9IHMubDtcclxuICAgICAgICB2ICs9IHMudjtcclxuICAgICAgfVxyXG4gICAgICBvdXQucHVzaCh7IHQ6IHNsaWNlWzBdLnQsIG8sIGgsIGwsIGMsIHYgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG4gIH1cclxuICBcclxuICAvLyBCdWNrZXQgaW5kaWNhdG9ycyBhbG9uZ3NpZGUgdGhlIGRhdGEgKHRha2UgZXZlcnkgTnRoIHZhbHVlIHRvIG1hdGNoIGJ1Y2tldGluZylcclxuICBmdW5jdGlvbiBidWNrZXRJbmRpY2F0b3IodmFsdWVzOiAobnVtYmVyIHwgbnVsbClbXSwgc2l6ZTogbnVtYmVyKTogKG51bWJlciB8IG51bGwpW10ge1xyXG4gICAgaWYgKHNpemUgPD0gMSkgcmV0dXJuIHZhbHVlcztcclxuICAgIGNvbnN0IG91dDogKG51bWJlciB8IG51bGwpW10gPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArPSBzaXplKSB7XHJcbiAgICAgIG91dC5wdXNoKHZhbHVlc1tpXSk7IC8vIFRha2UgdGhlIGZpcnN0IHZhbHVlIG9mIGVhY2ggYnVja2V0XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG4gIH1cclxuICBcclxuICBjb25zdCBiYXNlRGF0YSA9IGJ1Y2tldFNpemUgPT09IDEgPyBzb3VyY2VEYXRhIDogYnVja2V0QWdncmVnYXRlKHNvdXJjZURhdGEsIGJ1Y2tldFNpemUpO1xyXG4gIGNvbnN0IGJ1Y2tldGVkRW1hMjAgPSBidWNrZXRTaXplID09PSAxID8gcmF3RW1hMjAgOiBidWNrZXRJbmRpY2F0b3IocmF3RW1hMjAsIGJ1Y2tldFNpemUpO1xyXG4gIGNvbnN0IGJ1Y2tldGVkVm9sTUEgPSBidWNrZXRTaXplID09PSAxID8gcmF3Vm9sTUEgOiBidWNrZXRJbmRpY2F0b3IocmF3Vm9sTUEsIGJ1Y2tldFNpemUpO1xyXG4gIGNvbnN0IGJ1Y2tldGVkQm9sbGluZ2VyQmFuZHMgPSBidWNrZXRTaXplID09PSAxID8gcmF3Qm9sbGluZ2VyQmFuZHMgOiB7XHJcbiAgICB1cHBlcjogYnVja2V0SW5kaWNhdG9yKHJhd0JvbGxpbmdlckJhbmRzLnVwcGVyLCBidWNrZXRTaXplKSxcclxuICAgIGxvd2VyOiBidWNrZXRJbmRpY2F0b3IocmF3Qm9sbGluZ2VyQmFuZHMubG93ZXIsIGJ1Y2tldFNpemUpLFxyXG4gICAgbWlkZGxlOiBidWNrZXRJbmRpY2F0b3IocmF3Qm9sbGluZ2VyQmFuZHMubWlkZGxlLCBidWNrZXRTaXplKSxcclxuICB9O1xyXG4gIFxyXG4gIC8vIEJhY2tlbmQgZmV0Y2hlcyBleHRyYSBjYW5kbGVzIGZvciBpbmRpY2F0b3IgY2FsY3VsYXRpb24gKDIwLTUwIGRlcGVuZGluZyBvbiByYW5nZSlcclxuICAvLyBBZnRlciBidWNrZXRpbmcsIHdlIGhpZGUgcHJvcG9ydGlvbmFsbHkgZmV3ZXIgY2FuZGxlc1xyXG4gIGNvbnN0IGJ1ZmZlclBlclJhbmdlOiBSZWNvcmQ8UmFuZ2VLZXksIG51bWJlcj4gPSB7XHJcbiAgICBcIjFkXCI6IDUwLCAgIC8vIFdvcmtzIHBlcmZlY3RseVxyXG4gICAgXCIxd1wiOiA1MCwgICAvLyBOb3cgbXVjaCBzbWFsbGVyIHNpbmNlIGluZGljYXRvcnMgcHJlLWNhbGN1bGF0ZWRcclxuICAgIFwiMW1cIjogNTAsICAgLy8gTm93IG11Y2ggc21hbGxlciBzaW5jZSBpbmRpY2F0b3JzIHByZS1jYWxjdWxhdGVkXHJcbiAgICBcIjNtXCI6IDUwLCAgIC8vIFBlcmZlY3QgYWxyZWFkeVxyXG4gICAgXCIxeVwiOiA1MCwgICAvLyBXb3JrcyBwZXJmZWN0bHlcclxuICAgIFwiNXlcIjogNTAsICAgLy8gV29ya3MgcGVyZmVjdGx5XHJcbiAgfTtcclxuICBjb25zdCBidWZmZXJDYW5kbGVzID0gTWF0aC5taW4oYnVmZmVyUGVyUmFuZ2VbcmFuZ2VdLCBNYXRoLmZsb29yKGJhc2VEYXRhLmxlbmd0aCAqIDAuMikpO1xyXG4gIGNvbnN0IGRpc3BsYXlEYXRhID0gYmFzZURhdGEuc2xpY2UoYnVmZmVyQ2FuZGxlcyk7IC8vIEhpZGUgZmlyc3QgY2FuZGxlcyBmcm9tIHVzZXJcclxuICBcclxuICBjb25zdCBbd2luZG93SWR4LCBzZXRXaW5kb3dJZHhdID0gUmVhY3QudXNlU3RhdGU8W251bWJlciwgbnVtYmVyXT4oKCkgPT4gWzAsIGRpc3BsYXlEYXRhLmxlbmd0aCAtIDFdKTtcclxuICAvLyBSZXNldCB3aW5kb3cgd2hlbiBkaXNwbGF5RGF0YSBsZW5ndGggY2hhbmdlcyAocmFuZ2UgY2hhbmdlIG9yIG5ldyBkYXRhKVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBzZXRXaW5kb3dJZHgoWzAsIGRpc3BsYXlEYXRhLmxlbmd0aCAtIDFdKTtcclxuICB9LCBbZGlzcGxheURhdGEubGVuZ3RoXSk7XHJcbiAgXHJcbiAgLy8gQWx3YXlzIHNob3cgZnVsbCByYW5nZSB1bmxlc3MgdXNlciB6b29tcy9wYW5zICh3aW5kb3dJZHggYWN0cyBhcyB1c2VyIG92ZXJyaWRlIGFmdGVyIGZpcnN0IHdoZWVsL2RyYWcpXHJcbiAgY29uc3QgW3dTdGFydCwgd0VuZF0gPSB3aW5kb3dJZHg7XHJcbiAgY29uc3QgZnVsbFN0YXJ0ID0gMDtcclxuICBjb25zdCBmdWxsRW5kID0gZGlzcGxheURhdGEubGVuZ3RoIC0gMTtcclxuICBjb25zdCBlZmZlY3RpdmVTdGFydCA9XHJcbiAgICB3U3RhcnQgPT09IDAgJiYgd0VuZCA9PT0gZGlzcGxheURhdGEubGVuZ3RoIC0gMSA/IGZ1bGxTdGFydCA6IE1hdGgubWF4KDAsIE1hdGgubWluKHdTdGFydCwgZnVsbEVuZCkpO1xyXG4gIGNvbnN0IGVmZmVjdGl2ZUVuZCA9IHdTdGFydCA9PT0gMCAmJiB3RW5kID09PSBkaXNwbGF5RGF0YS5sZW5ndGggLSAxID8gZnVsbEVuZCA6IE1hdGgubWluKHdFbmQsIGZ1bGxFbmQpO1xyXG4gIGNvbnN0IHNhZmVFbmQgPSBNYXRoLm1pbihlZmZlY3RpdmVFbmQsIGRpc3BsYXlEYXRhLmxlbmd0aCAtIDEpO1xyXG4gIGNvbnN0IHNhZmVTdGFydCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGVmZmVjdGl2ZVN0YXJ0LCBzYWZlRW5kIC0gNSkpO1xyXG4gIGNvbnN0IGRyYXdEYXRhID0gZGlzcGxheURhdGEuc2xpY2Uoc2FmZVN0YXJ0LCBzYWZlRW5kICsgMSk7XHJcbiAgXHJcbiAgLy8gU2xpY2UgcHJlLWNhbGN1bGF0ZWQgaW5kaWNhdG9ycyB0byBtYXRjaCBkcmF3RGF0YSAob2Zmc2V0IGJ5IGJ1ZmZlciArIHdpbmRvdylcclxuICBjb25zdCBpbmRpY2F0b3JTdGFydCA9IGJ1ZmZlckNhbmRsZXMgKyBzYWZlU3RhcnQ7XHJcbiAgY29uc3QgaW5kaWNhdG9yRW5kID0gYnVmZmVyQ2FuZGxlcyArIHNhZmVFbmQgKyAxO1xyXG4gIGNvbnN0IGVtYTIwID0gYnVja2V0ZWRFbWEyMC5zbGljZShpbmRpY2F0b3JTdGFydCwgaW5kaWNhdG9yRW5kKTtcclxuICBjb25zdCB2b2xNQSA9IGJ1Y2tldGVkVm9sTUEuc2xpY2UoaW5kaWNhdG9yU3RhcnQsIGluZGljYXRvckVuZCk7XHJcbiAgY29uc3QgYm9sbGluZ2VyQmFuZHMgPSB7XHJcbiAgICB1cHBlcjogYnVja2V0ZWRCb2xsaW5nZXJCYW5kcy51cHBlci5zbGljZShpbmRpY2F0b3JTdGFydCwgaW5kaWNhdG9yRW5kKSxcclxuICAgIGxvd2VyOiBidWNrZXRlZEJvbGxpbmdlckJhbmRzLmxvd2VyLnNsaWNlKGluZGljYXRvclN0YXJ0LCBpbmRpY2F0b3JFbmQpLFxyXG4gICAgbWlkZGxlOiBidWNrZXRlZEJvbGxpbmdlckJhbmRzLm1pZGRsZS5zbGljZShpbmRpY2F0b3JTdGFydCwgaW5kaWNhdG9yRW5kKSxcclxuICB9O1xyXG4gIFxyXG4gIGNvbnN0IGNsb3NlcyA9IGRyYXdEYXRhLm1hcCgoZDogQ2FuZGxlKSA9PiBkLmMpLFxyXG4gICAgaGlnaHMgPSBkcmF3RGF0YS5tYXAoKGQ6IENhbmRsZSkgPT4gZC5oKSxcclxuICAgIGxvd3MgPSBkcmF3RGF0YS5tYXAoKGQ6IENhbmRsZSkgPT4gZC5sKTtcclxuICBmdW5jdGlvbiBxdWFudGlsZShhcnI6IG51bWJlcltdLCBxOiBudW1iZXIpIHtcclxuICAgIGlmICghYXJyLmxlbmd0aCkgcmV0dXJuIDA7XHJcbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4uYXJyXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcbiAgICBjb25zdCBwb3MgPSAoc29ydGVkLmxlbmd0aCAtIDEpICogcTtcclxuICAgIGNvbnN0IGJhc2UgPSBNYXRoLmZsb29yKHBvcyk7XHJcbiAgICBjb25zdCByZXN0ID0gcG9zIC0gYmFzZTtcclxuICAgIHJldHVybiBzb3J0ZWRbYmFzZSArIDFdICE9PSB1bmRlZmluZWRcclxuICAgICAgPyBzb3J0ZWRbYmFzZV0gKyByZXN0ICogKHNvcnRlZFtiYXNlICsgMV0gLSBzb3J0ZWRbYmFzZV0pXHJcbiAgICAgIDogc29ydGVkW2Jhc2VdO1xyXG4gIH1cclxuICBsZXQgbWluID0gcXVhbnRpbGUobG93cywgMC4wMDUpLFxyXG4gICAgbWF4ID0gcXVhbnRpbGUoaGlnaHMsIDAuOTk1KTtcclxuICBjb25zdCBsYXN0QyA9IGRyYXdEYXRhW2RyYXdEYXRhLmxlbmd0aCAtIDFdO1xyXG4gIGlmIChsYXN0Qykge1xyXG4gICAgaWYgKGxhc3RDLmwgPCBtaW4pIG1pbiA9IGxhc3RDLmw7XHJcbiAgICBpZiAobGFzdEMuaCA+IG1heCkgbWF4ID0gbGFzdEMuaDtcclxuICB9XHJcbiAgY29uc3Qgc3BhbiA9IG1heCAtIG1pbiB8fCAxO1xyXG4gIC8vIFNpbmdsZSBzY2FsZSB2YXJpYWJsZVxyXG4gIGNvbnN0IFMgPSBMYXlvdXRDb25maWcuQ0hBUlRfU0NBTEU7IC8vIGFmZmVjdHMgdmVydGljYWwgcmVhbCBlc3RhdGVcclxuICBjb25zdCBoVmlzdWFsQmFzZSA9IExheW91dENvbmZpZy5HUkFQSF9IRUlHSFQ7IC8vIGJhc2VsaW5lIHZpc3VhbCBoZWlnaHQgZnJvbSBjb25maWdcclxuICBjb25zdCB2b2x1bWVQb3J0aW9uID0gMC4yMzsgLy8gZnJhY3Rpb24gcmVzZXJ2ZWQgZm9yIHZvbHVtZSBhcmVhXHJcbiAgY29uc3QgaFZpc3VhbCA9IGhWaXN1YWxCYXNlICogUztcclxuICBjb25zdCB2b2xIID0gaFZpc3VhbCAqIHZvbHVtZVBvcnRpb247XHJcbiAgY29uc3QgcHJpY2VIID0gaFZpc3VhbCAtIHZvbEg7XHJcbiAgY29uc3QgYXhpc0Zvb3RlciA9IExheW91dENvbmZpZy5BWElTX0ZPT1RFUl9IRUlHSFQ7XHJcbiAgY29uc3QgaCA9IGhWaXN1YWwgKyBheGlzRm9vdGVyO1xyXG4gIGNvbnN0IHcgPSBMYXlvdXRDb25maWcuR1JBUEhfV0lEVEg7XHJcbiAgY29uc3QgZ3V0dGVyUmlnaHQgPSBMYXlvdXRDb25maWcuQVhJU19SSUdIVF9HVVRURVI7XHJcbiAgY29uc3QgcGFkVG9wID0gOCxcclxuICAgIHBhZEJvdHRvbSA9IDYsXHJcbiAgICBwYWRMZWZ0ID0gNDtcclxuICBjb25zdCBwcmljZUFyZWEgPSBwcmljZUggLSBwYWRUb3AgLSBwYWRCb3R0b207XHJcbiAgY29uc3QgdXAgPSBjbG9zZXNbY2xvc2VzLmxlbmd0aCAtIDFdID49IGNsb3Nlc1swXTtcclxuICBjb25zdCBwcmljZVcgPSB3IC0gZ3V0dGVyUmlnaHQgLSBwYWRMZWZ0O1xyXG4gIFxyXG4gIC8vIEluZGV4LWJhc2VkIGhvcml6b250YWwgc2NhbGUgKHJlbW92ZXMgdGltZSBnYXBzIGZvciBjb250aW51b3VzIGRpc3BsYXkpXHJcbiAgY29uc3QgbnVtQ2FuZGxlcyA9IGRyYXdEYXRhLmxlbmd0aDtcclxuICBmdW5jdGlvbiB4Rm9ySWR4KGlkeDogbnVtYmVyKSB7IHJldHVybiBwYWRMZWZ0ICsgKGlkeCAvIE1hdGgubWF4KDEsIG51bUNhbmRsZXMgLSAxKSkgKiBwcmljZVc7IH1cclxuICBcclxuICAvLyBTdG9yZSB0aW1lc3RhbXBzIGZvciBsYWJlbHNcclxuICBjb25zdCBkcmF3VGltZXMgPSBkcmF3RGF0YS5tYXAoZCA9PiBuZXcgRGF0ZShkLnQpLmdldFRpbWUoKSk7XHJcbiAgXHJcbiAgLy8gQWRhcHRpdmUgY2FuZGxlIHdpZHRoIGZyb20gZGF0YSBkZW5zaXR5XHJcbiAgbGV0IGNhbmRsZVdpZHRoOiBudW1iZXI7XHJcbiAgaWYgKG51bUNhbmRsZXMgPD0gMikge1xyXG4gICAgY2FuZGxlV2lkdGggPSAocHJpY2VXIC8gTWF0aC5tYXgoMSwgbnVtQ2FuZGxlcykpICogMC42O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjYW5kbGVXaWR0aCA9IChwcmljZVcgLyBudW1DYW5kbGVzKSAqIDAuODtcclxuICB9XHJcbiAgaWYgKGNhbmRsZVdpZHRoIDwgMykgY2FuZGxlV2lkdGggPSAzOyBpZiAoY2FuZGxlV2lkdGggPiAyMikgY2FuZGxlV2lkdGggPSAyMjtcclxuICBjb25zdCBsaW5lUHRzID0gZHJhd0RhdGEubWFwKChkLCBpZHgpID0+IHtcclxuICAgIGNvbnN0IHggPSB4Rm9ySWR4KGlkeCk7XHJcbiAgICBjb25zdCB2YWwgPSBsb2dTY2FsZSA/IChNYXRoLmxvZzEwKGQuYykgLSBNYXRoLmxvZzEwKG1pbikpIC8gKE1hdGgubG9nMTAobWF4KSAtIE1hdGgubG9nMTAobWluIHx8IDEpKSA6IChkLmMgLSBtaW4pIC8gc3BhbjtcclxuICAgIGNvbnN0IHkgPSBwYWRUb3AgKyAocHJpY2VBcmVhIC0gdmFsICogcHJpY2VBcmVhKTtcclxuICAgIHJldHVybiBgJHt4fSwke3l9YDtcclxuICB9KS5qb2luKFwiIFwiKTtcclxuICBjb25zdCBob3ZlclBvaW50ID0gaG92ZXIgIT0gbnVsbCA/IGRyYXdEYXRhW2hvdmVyXSA6IG51bGw7XHJcbiAgZnVuY3Rpb24gb25Nb3ZlKGU6IFJlYWN0Lk1vdXNlRXZlbnQ8U1ZHU1ZHRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHJlY3QgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBjb25zdCB4ID0gZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xyXG4gICAgXHJcbiAgICAvLyBJbmRleC1iYXNlZCBob3ZlcjogZmluZCBuZWFyZXN0IGNhbmRsZSBieSB4IHBvc2l0aW9uXHJcbiAgICBpZiAoZHJhd0RhdGEubGVuZ3RoID09PSAwKSByZXR1cm47XHJcbiAgICBcclxuICAgIGNvbnN0IHhSYXRpbyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsICh4IC0gcGFkTGVmdCkgLyAocmVjdC53aWR0aCAtIChndXR0ZXJSaWdodCAvIHcpICogcmVjdC53aWR0aCkpKTtcclxuICAgIGNvbnN0IGlkeCA9IE1hdGgucm91bmQoeFJhdGlvICogKG51bUNhbmRsZXMgLSAxKSk7XHJcbiAgICBcclxuICAgIHNldEhvdmVyKE1hdGgubWF4KDAsIE1hdGgubWluKG51bUNhbmRsZXMgLSAxLCBpZHgpKSk7XHJcbiAgfVxyXG4gIGNvbnN0IGRyYWdTdGF0ZSA9IHVzZVJlZjx7IHN0YXJ0WDogbnVtYmVyOyBzdGFydFJhbmdlOiBbbnVtYmVyLCBudW1iZXJdIH0gfCBudWxsPihudWxsKTtcclxuICBmdW5jdGlvbiBvbldoZWVsKGU6IFJlYWN0LldoZWVsRXZlbnQ8U1ZHU1ZHRWxlbWVudD4pIHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIGlmIChkcmF3RGF0YS5sZW5ndGggPCAxMCkgcmV0dXJuO1xyXG4gICAgY29uc3QgZGVsdGEgPSBlLmRlbHRhWTtcclxuICAgIGNvbnN0IGZhY3RvciA9IGRlbHRhID4gMCA/IDEuMSA6IDAuOTtcclxuICAgIGNvbnN0IGN1cnJlbnRMZW4gPSB3RW5kIC0gd1N0YXJ0ICsgMTtcclxuICAgIGNvbnN0IG5ld0xlbiA9IE1hdGgubWF4KDIwLCBNYXRoLm1pbihkaXNwbGF5RGF0YS5sZW5ndGgsIE1hdGgucm91bmQoY3VycmVudExlbiAqIGZhY3RvcikpKTtcclxuICAgIGNvbnN0IHJlY3QgPSAoZS5jdXJyZW50VGFyZ2V0IGFzIFNWR1NWR0VsZW1lbnQpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgY29uc3QgeFJhdGlvID0gKGUuY2xpZW50WCAtIHJlY3QubGVmdCAtIHBhZExlZnQpIC8gKHJlY3Qud2lkdGggLSBndXR0ZXJSaWdodCk7XHJcbiAgICBjb25zdCBmb2N1c0lkeCA9IHdTdGFydCArIE1hdGgucm91bmQoY3VycmVudExlbiAqIHhSYXRpbyk7XHJcbiAgICBsZXQgbmV3U3RhcnQgPSBmb2N1c0lkeCAtIE1hdGgucm91bmQobmV3TGVuICogeFJhdGlvKTtcclxuICAgIGxldCBuZXdFbmQgPSBuZXdTdGFydCArIG5ld0xlbiAtIDE7XHJcbiAgICBpZiAobmV3U3RhcnQgPCAwKSB7XHJcbiAgICAgIG5ld1N0YXJ0ID0gMDtcclxuICAgICAgbmV3RW5kID0gbmV3TGVuIC0gMTtcclxuICAgIH1cclxuICAgIGlmIChuZXdFbmQgPiBkaXNwbGF5RGF0YS5sZW5ndGggLSAxKSB7XHJcbiAgICAgIG5ld0VuZCA9IGRpc3BsYXlEYXRhLmxlbmd0aCAtIDE7XHJcbiAgICAgIG5ld1N0YXJ0ID0gbmV3RW5kIC0gbmV3TGVuICsgMTtcclxuICAgIH1cclxuICAgIHNldFdpbmRvd0lkeChbbmV3U3RhcnQsIG5ld0VuZF0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBvblBvaW50ZXJEb3duKGU6IFJlYWN0LlBvaW50ZXJFdmVudDxTVkdTVkdFbGVtZW50Pikge1xyXG4gICAgZS5jdXJyZW50VGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTtcclxuICAgIGRyYWdTdGF0ZS5jdXJyZW50ID0geyBzdGFydFg6IGUuY2xpZW50WCwgc3RhcnRSYW5nZTogd2luZG93SWR4IH07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoZTogUmVhY3QuUG9pbnRlckV2ZW50PFNWR1NWR0VsZW1lbnQ+KSB7XHJcbiAgICBpZiAoIWRyYWdTdGF0ZS5jdXJyZW50KSByZXR1cm47XHJcbiAgICBjb25zdCBbcywgZUlkeF0gPSBkcmFnU3RhdGUuY3VycmVudC5zdGFydFJhbmdlO1xyXG4gICAgY29uc3QgbGVuID0gZUlkeCAtIHMgKyAxO1xyXG4gICAgY29uc3QgcGl4ZWxQZXJDYW5kbGUgPSBwcmljZVcgLyBkcmF3RGF0YS5sZW5ndGg7XHJcbiAgICBjb25zdCBkZWx0YVB4ID0gZS5jbGllbnRYIC0gZHJhZ1N0YXRlLmN1cnJlbnQuc3RhcnRYO1xyXG4gICAgY29uc3Qgc2hpZnQgPSBNYXRoLnJvdW5kKC1kZWx0YVB4IC8gcGl4ZWxQZXJDYW5kbGUpO1xyXG4gICAgbGV0IG5ld1N0YXJ0ID0gcyArIHNoaWZ0O1xyXG4gICAgbGV0IG5ld0VuZCA9IG5ld1N0YXJ0ICsgbGVuIC0gMTtcclxuICAgIGlmIChuZXdTdGFydCA8IDApIHtcclxuICAgICAgbmV3U3RhcnQgPSAwO1xyXG4gICAgICBuZXdFbmQgPSBsZW4gLSAxO1xyXG4gICAgfVxyXG4gICAgaWYgKG5ld0VuZCA+IGRpc3BsYXlEYXRhLmxlbmd0aCAtIDEpIHtcclxuICAgICAgbmV3RW5kID0gZGlzcGxheURhdGEubGVuZ3RoIC0gMTtcclxuICAgICAgbmV3U3RhcnQgPSBuZXdFbmQgLSBsZW4gKyAxO1xyXG4gICAgfVxyXG4gICAgc2V0V2luZG93SWR4KFtuZXdTdGFydCwgbmV3RW5kXSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIG9uUG9pbnRlclVwKCkge1xyXG4gICAgZHJhZ1N0YXRlLmN1cnJlbnQgPSBudWxsO1xyXG4gIH1cclxuICBmdW5jdGlvbiBuaWNlVGlja3MobG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdGFyZ2V0ID0gNSkge1xyXG4gICAgY29uc3QgcmF3U3BhbiA9IGhpZ2ggLSBsb3cgfHwgMTtcclxuICAgIGNvbnN0IHJvdWdoU3RlcCA9IHJhd1NwYW4gLyAodGFyZ2V0IC0gMSk7XHJcbiAgICBjb25zdCBwb3cxMCA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nMTAocm91Z2hTdGVwKSkpO1xyXG4gICAgY29uc3QgbXVsdGlwbGVzID0gWzEsIDIsIDIuNSwgNSwgMTBdO1xyXG4gICAgY29uc3QgZm91bmQgPSBtdWx0aXBsZXMuZmluZCgobSkgPT4gbSAqIHBvdzEwID49IHJvdWdoU3RlcCkgfHwgbXVsdGlwbGVzW211bHRpcGxlcy5sZW5ndGggLSAxXTtcclxuICAgIGNvbnN0IHN0ZXAgPSBmb3VuZCAqIHBvdzEwO1xyXG4gICAgY29uc3QgZmlyc3QgPSBNYXRoLmNlaWwobG93IC8gc3RlcCkgKiBzdGVwO1xyXG4gICAgY29uc3QgdGlja3M6IG51bWJlcltdID0gW107XHJcbiAgICBmb3IgKGxldCB2ID0gZmlyc3Q7IHYgPD0gaGlnaDsgdiArPSBzdGVwKSB0aWNrcy5wdXNoKHYpO1xyXG4gICAgcmV0dXJuIHRpY2tzO1xyXG4gIH1cclxuICAvLyBUaW1lIHRpY2tzIHBlciBleHBsaWNpdCBzcGVjXHJcbiAgY29uc3QgdGltZVRpY2tzOiBBcnJheTx7IHg6IG51bWJlcjsgbGFiZWw6IHN0cmluZyB9PiA9IFtdO1xyXG4gIGlmIChkcmF3RGF0YS5sZW5ndGggPiAxKSB7XHJcbiAgICBpZiAocmFuZ2UgPT09ICcxZCcpIHtcclxuICAgICAgLy8gU2hvdyBsYWJlbCBldmVyeSBob3VyIGZvciBjbGVhbmVyIGRpc3BsYXlcclxuICAgICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG4gICAgICBkcmF3RGF0YS5mb3JFYWNoKChjLCBpZHgpID0+IHtcclxuICAgICAgICBjb25zdCBkID0gbmV3IERhdGUoYy50KTtcclxuICAgICAgICBjb25zdCBoaCA9IGQuZ2V0SG91cnMoKTtcclxuICAgICAgICBjb25zdCBtbSA9IGQuZ2V0TWludXRlcygpO1xyXG4gICAgICAgIC8vIFNob3cgbGFiZWwgZXZlcnkgaG91ciBvbiB0aGUgaG91clxyXG4gICAgICAgIGlmIChtbSA9PT0gMCkge1xyXG4gICAgICAgICAgY29uc3QgdGltZUtleSA9IGAke2hofTowMGA7XHJcbiAgICAgICAgICBpZiAoIXNlZW4uaGFzKHRpbWVLZXkpKSB7XHJcbiAgICAgICAgICAgIHNlZW4uYWRkKHRpbWVLZXkpO1xyXG4gICAgICAgICAgICB0aW1lVGlja3MucHVzaCh7IFxyXG4gICAgICAgICAgICAgIHg6IHhGb3JJZHgoaWR4KSwgXHJcbiAgICAgICAgICAgICAgbGFiZWw6IGQudG9Mb2NhbGVUaW1lU3RyaW5nKCdlbi1VUycsIHsgaG91cjogJ251bWVyaWMnLCBtaW51dGU6ICcyLWRpZ2l0JywgaG91cjEyOiBmYWxzZSB9KSBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAocmFuZ2UgPT09ICcxdycpIHtcclxuICAgICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpOyBkcmF3RGF0YS5mb3JFYWNoKChjLCBpZHgpID0+IHsgY29uc3QgZCA9IG5ldyBEYXRlKGMudCk7IGNvbnN0IGsgPSBkLnRvRGF0ZVN0cmluZygpOyBpZiAoIXNlZW4uaGFzKGspKSB7IHNlZW4uYWRkKGspOyB0aW1lVGlja3MucHVzaCh7IHg6IHhGb3JJZHgoaWR4KSwgbGFiZWw6IGQudG9Mb2NhbGVEYXRlU3RyaW5nKHVuZGVmaW5lZCx7IHdlZWtkYXk6J3Nob3J0J30pLnRvVXBwZXJDYXNlKCkgfSk7IH0gfSk7XHJcbiAgICB9IGVsc2UgaWYgKHJhbmdlID09PSAnMW0nKSB7XHJcbiAgICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTsgZHJhd0RhdGEuZm9yRWFjaCgoYywgaWR4KSA9PiB7IGNvbnN0IGQgPSBuZXcgRGF0ZShjLnQpOyBpZiAoZC5nZXREYXkoKSA9PT0gMSkgeyBjb25zdCBrZXkgPSBkLmdldEZ1bGxZZWFyKCkrXCItXCIrZC5nZXRNb250aCgpK1wiLVwiK2QuZ2V0RGF0ZSgpOyBpZiAoIXNlZW4uaGFzKGtleSkpIHsgc2Vlbi5hZGQoa2V5KTsgdGltZVRpY2tzLnB1c2goeyB4OiB4Rm9ySWR4KGlkeCksIGxhYmVsOiAoZC5nZXRNb250aCgpKzEpK1wiL1wiK2QuZ2V0RGF0ZSgpIH0pOyB9IH0gfSk7XHJcbiAgICB9IGVsc2UgaWYgKHJhbmdlID09PSAnM20nKSB7XHJcbiAgICAgIGxldCBtb25kYXlDb3VudCA9IDA7IGRyYXdEYXRhLmZvckVhY2goKGMsIGlkeCkgPT4geyBjb25zdCBkID0gbmV3IERhdGUoYy50KTsgaWYgKGQuZ2V0RGF5KCkgPT09IDEpIHsgaWYgKG1vbmRheUNvdW50ICUgMyA9PT0gMCkgdGltZVRpY2tzLnB1c2goeyB4OiB4Rm9ySWR4KGlkeCksIGxhYmVsOiAoZC5nZXRNb250aCgpKzEpK1wiL1wiK2QuZ2V0RGF0ZSgpIH0pOyBtb25kYXlDb3VudCsrOyB9IH0pO1xyXG4gICAgfSBlbHNlIGlmIChyYW5nZSA9PT0gJzF5Jykge1xyXG4gICAgICBjb25zdCBzZWVuTW9udGggPSBuZXcgU2V0PHN0cmluZz4oKTsgZHJhd0RhdGEuZm9yRWFjaCgoYywgaWR4KSA9PiB7IGNvbnN0IGQgPSBuZXcgRGF0ZShjLnQpOyBjb25zdCBtayA9IGQuZ2V0RnVsbFllYXIoKStcIi1cIitkLmdldE1vbnRoKCk7IGlmICghc2Vlbk1vbnRoLmhhcyhtaykgJiYgZC5nZXREYXRlKCkgPD0gNykgeyBzZWVuTW9udGguYWRkKG1rKTsgdGltZVRpY2tzLnB1c2goeyB4OiB4Rm9ySWR4KGlkeCksIGxhYmVsOiBkLnRvTG9jYWxlU3RyaW5nKHVuZGVmaW5lZCx7IG1vbnRoOidzaG9ydCd9KS50b1VwcGVyQ2FzZSgpIH0pOyB9IH0pO1xyXG4gICAgfSBlbHNlIGlmIChyYW5nZSA9PT0gJzV5Jykge1xyXG4gICAgICBjb25zdCBzZWVuWWVhciA9IG5ldyBTZXQ8bnVtYmVyPigpOyBkcmF3RGF0YS5mb3JFYWNoKChjLCBpZHgpID0+IHsgY29uc3QgZCA9IG5ldyBEYXRlKGMudCk7IGlmICghc2VlblllYXIuaGFzKGQuZ2V0RnVsbFllYXIoKSkgJiYgZC5nZXRNb250aCgpIDwgMikgeyBzZWVuWWVhci5hZGQoZC5nZXRGdWxsWWVhcigpKTsgdGltZVRpY2tzLnB1c2goeyB4OiB4Rm9ySWR4KGlkeCksIGxhYmVsOiBTdHJpbmcoZC5nZXRGdWxsWWVhcigpKSB9KTsgfSB9KTtcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgbWF4Vm9sID0gTWF0aC5tYXgoLi4uZHJhd0RhdGEubWFwKChkOiBDYW5kbGUpID0+IGQudiksIDEpO1xyXG4gIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGguYWJzKG1heCk7XHJcbiAgY29uc3QgZGVjaW1hbHMgPSBtYWduaXR1ZGUgPj0gNTAwID8gMCA6IG1hZ25pdHVkZSA+PSAxMDAgPyAxIDogMjtcclxuICBmdW5jdGlvbiBzbWEoc3JjOiBudW1iZXJbXSwgcGVyaW9kOiBudW1iZXIpIHtcclxuICAgIGlmIChzcmMubGVuZ3RoIDwgcGVyaW9kKSByZXR1cm4gW107XHJcbiAgICBjb25zdCBvdXQ6IChudW1iZXIgfCBudWxsKVtdID0gbmV3IEFycmF5KHBlcmlvZCAtIDEpLmZpbGwobnVsbCk7IC8vIFBhZCBiZWdpbm5pbmcgd2l0aCBudWxsc1xyXG4gICAgbGV0IHN1bSA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNyYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBzdW0gKz0gc3JjW2ldO1xyXG4gICAgICBpZiAoaSA+PSBwZXJpb2QpIHN1bSAtPSBzcmNbaSAtIHBlcmlvZF07XHJcbiAgICAgIGlmIChpID49IHBlcmlvZCAtIDEpIG91dC5wdXNoKHN1bSAvIHBlcmlvZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZW1hKHNyYzogbnVtYmVyW10sIHBlcmlvZDogbnVtYmVyKTogKG51bWJlciB8IG51bGwpW10ge1xyXG4gICAgaWYgKHNyYy5sZW5ndGggPCBwZXJpb2QpIHJldHVybiBbXTtcclxuICAgIGNvbnN0IGsgPSAyIC8gKHBlcmlvZCArIDEpO1xyXG4gICAgY29uc3Qgb3V0OiAobnVtYmVyIHwgbnVsbClbXSA9IG5ldyBBcnJheShwZXJpb2QgLSAxKS5maWxsKG51bGwpOyAvLyBQYWQgYmVnaW5uaW5nIHdpdGggbnVsbHNcclxuICAgIFxyXG4gICAgLy8gU3RhcnQgd2l0aCBTTUEgZm9yIGZpcnN0IHZhbHVlXHJcbiAgICBsZXQgc3VtID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVyaW9kOyBpKyspIHtcclxuICAgICAgc3VtICs9IHNyY1tpXTtcclxuICAgIH1cclxuICAgIG91dC5wdXNoKHN1bSAvIHBlcmlvZCk7XHJcbiAgICBcclxuICAgIC8vIFRoZW4gdXNlIEVNQSBmb3JtdWxhXHJcbiAgICBmb3IgKGxldCBpID0gcGVyaW9kOyBpIDwgc3JjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIG91dC5wdXNoKHNyY1tpXSAqIGsgKyAob3V0W291dC5sZW5ndGggLSAxXSBhcyBudW1iZXIpICogKDEgLSBrKSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBvdXQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjYWxjdWxhdGVCb2xsaW5nZXJCYW5kcyhjbG9zZXM6IG51bWJlcltdLCBwZXJpb2Q6IG51bWJlciA9IDIwLCBzdGREZXZNdWx0aXBsaWVyOiBudW1iZXIgPSAyKSB7XHJcbiAgICBpZiAoY2xvc2VzLmxlbmd0aCA8IHBlcmlvZCkgcmV0dXJuIHsgdXBwZXI6IFtdLCBsb3dlcjogW10sIG1pZGRsZTogW10gfTtcclxuICAgIFxyXG4gICAgY29uc3QgbWlkZGxlOiAobnVtYmVyIHwgbnVsbClbXSA9IG5ldyBBcnJheShwZXJpb2QgLSAxKS5maWxsKG51bGwpO1xyXG4gICAgY29uc3QgdXBwZXI6IChudW1iZXIgfCBudWxsKVtdID0gbmV3IEFycmF5KHBlcmlvZCAtIDEpLmZpbGwobnVsbCk7XHJcbiAgICBjb25zdCBsb3dlcjogKG51bWJlciB8IG51bGwpW10gPSBuZXcgQXJyYXkocGVyaW9kIC0gMSkuZmlsbChudWxsKTtcclxuICAgIFxyXG4gICAgZm9yIChsZXQgaSA9IHBlcmlvZCAtIDE7IGkgPCBjbG9zZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3Qgc2xpY2UgPSBjbG9zZXMuc2xpY2UoaSAtIHBlcmlvZCArIDEsIGkgKyAxKTtcclxuICAgICAgY29uc3QgYXZnID0gc2xpY2UucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKSAvIHBlcmlvZDtcclxuICAgICAgY29uc3QgdmFyaWFuY2UgPSBzbGljZS5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyBNYXRoLnBvdyh2YWwgLSBhdmcsIDIpLCAwKSAvIHBlcmlvZDtcclxuICAgICAgY29uc3Qgc3RkRGV2ID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcclxuICAgICAgXHJcbiAgICAgIG1pZGRsZS5wdXNoKGF2Zyk7XHJcbiAgICAgIHVwcGVyLnB1c2goYXZnICsgc3RkRGV2TXVsdGlwbGllciAqIHN0ZERldik7XHJcbiAgICAgIGxvd2VyLnB1c2goYXZnIC0gc3RkRGV2TXVsdGlwbGllciAqIHN0ZERldik7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB7IHVwcGVyLCBsb3dlciwgbWlkZGxlIH07XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IHN0eWxlPXt7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIGluc2V0OiAwLCBmb250U2l6ZTogMTEgfX0+XHJcbiAgICAgIDxzdmdcclxuICAgICAgICB2aWV3Qm94PXtgMCAwICR7d30gJHtofWB9XHJcbiAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbz1cIm5vbmVcIlxyXG4gICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICB3aWR0aDogXCIxMDAlXCIsXHJcbiAgICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgY3Vyc29yOiBcImNyb3NzaGFpclwiLFxyXG4gICAgICAgICAgdXNlclNlbGVjdDogXCJub25lXCIsXHJcbiAgICAgICAgICBmb250RmFtaWx5OiBcInN5c3RlbS11aSwgdWktbW9ub3NwYWNlLCBNZW5sbywgbW9ub3NwYWNlXCIsXHJcbiAgICAgICAgfX1cclxuICAgICAgICBvbk1vdXNlTW92ZT17b25Nb3ZlfVxyXG4gICAgICAgIG9uTW91c2VMZWF2ZT17KCkgPT4gc2V0SG92ZXIobnVsbCl9XHJcbiAgICAgICAgb25XaGVlbD17b25XaGVlbH1cclxuICAgICAgICBvblBvaW50ZXJEb3duPXtvblBvaW50ZXJEb3dufVxyXG4gICAgICAgIG9uUG9pbnRlck1vdmU9e29uUG9pbnRlck1vdmV9XHJcbiAgICAgICAgb25Qb2ludGVyVXA9e29uUG9pbnRlclVwfVxyXG4gICAgICA+XHJcbiAgICAgICAge25pY2VUaWNrcyhtaW4sIG1heCwgNSkubWFwKCh0KSA9PiB7XHJcbiAgICAgICAgICBjb25zdCB5ID0gOCArIChwcmljZUFyZWEgLSAoKHQgLSBtaW4pIC8gc3BhbikgKiBwcmljZUFyZWEpO1xyXG4gICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGcga2V5PXt0LnRvRml4ZWQoNil9PlxyXG4gICAgICAgICAgICAgIDxsaW5lXHJcbiAgICAgICAgICAgICAgICB4MT17cGFkTGVmdH1cclxuICAgICAgICAgICAgICAgIHgyPXtwYWRMZWZ0ICsgcHJpY2VXfVxyXG4gICAgICAgICAgICAgICAgeTE9e3l9XHJcbiAgICAgICAgICAgICAgICB5Mj17eX1cclxuICAgICAgICAgICAgICAgIHN0cm9rZT17dGhlbWUgPT09IFwibGlnaHRcIiA/IFwiI2QwZDdkZVwiIDogXCIjMzAzNjNkXCJ9XHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD17MX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgIDx0ZXh0XHJcbiAgICAgICAgICAgICAgICB4PXtwYWRMZWZ0ICsgcHJpY2VXICsgTGF5b3V0Q29uZmlnLkFYSVNfWV9MQUJFTF9YX09GRlNFVH1cclxuICAgICAgICAgICAgICAgIHk9e3kgKyBMYXlvdXRDb25maWcuQVhJU19ZX0ZPTlRfU0laRSAvIDN9XHJcbiAgICAgICAgICAgICAgICBmaWxsPXt0aGVtZSA9PT0gXCJsaWdodFwiID8gXCIjMDAwMDAwXCIgOiBcIiNmZmZmZmZcIn1cclxuICAgICAgICAgICAgICAgIGZvbnRTaXplPXtMYXlvdXRDb25maWcuQVhJU19ZX0ZPTlRfU0laRX1cclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICB7dC50b0ZpeGVkKGRlY2ltYWxzKX1cclxuICAgICAgICAgICAgICA8L3RleHQ+XHJcbiAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSl9XHJcblxyXG4gICAgICAgIHsvKiBWZXJ0aWNhbCBncmlkIGxpbmVzIChyZW5kZXIgYmVmb3JlIGNoYXJ0IGRhdGEgc28gdGhleSBhcHBlYXIgYmVoaW5kKSAqL31cclxuICAgICAgICB7dGltZVRpY2tzLm1hcCgodCwgaSkgPT4gKFxyXG4gICAgICAgICAgPGxpbmVcclxuICAgICAgICAgICAga2V5PXtcInh0aWNrLVwiICsgaX1cclxuICAgICAgICAgICAgeDE9e3QueH1cclxuICAgICAgICAgICAgeDI9e3QueH1cclxuICAgICAgICAgICAgeTE9ezB9XHJcbiAgICAgICAgICAgIHkyPXtoVmlzdWFsfVxyXG4gICAgICAgICAgICBzdHJva2U9e3RoZW1lID09PSBcImxpZ2h0XCIgPyBcIiNkMGQ3ZGVcIiA6IFwiIzMwMzYzZFwifVxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aD17MX1cclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgKSl9XHJcblxyXG4gICAgICAgIHsvKiBCb2xsaW5nZXIgQmFuZHMgKi99XHJcbiAgICAgICAge3Nob3dCb2xsaW5nZXJCYW5kcyAmJiBib2xsaW5nZXJCYW5kcy51cHBlci5sZW5ndGggPiAwICYmIChcclxuICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgIHsvKiBGaWxsIGFyZWEgKi99XHJcbiAgICAgICAgICAgIDxwb2x5Z29uXHJcbiAgICAgICAgICAgICAgcG9pbnRzPXsoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnRzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy8gVXBwZXIgYmFuZFxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2xsaW5nZXJCYW5kcy51cHBlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB1cHBlclZhbCA9IGJvbGxpbmdlckJhbmRzLnVwcGVyW2ldO1xyXG4gICAgICAgICAgICAgICAgICBpZiAodXBwZXJWYWwgPT09IG51bGwpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB4ID0geEZvcklkeChpKTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gKHVwcGVyVmFsIC0gbWluKSAvIHNwYW47XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBwYWRUb3AgKyAocHJpY2VBcmVhIC0gdmFsICogcHJpY2VBcmVhKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKHgpICYmIGlzRmluaXRlKHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYCR7eH0sJHt5fWApO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBMb3dlciBiYW5kIChyZXZlcnNlZClcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBib2xsaW5nZXJCYW5kcy5sb3dlci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBsb3dlclZhbCA9IGJvbGxpbmdlckJhbmRzLmxvd2VyW2ldO1xyXG4gICAgICAgICAgICAgICAgICBpZiAobG93ZXJWYWwgPT09IG51bGwpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB4ID0geEZvcklkeChpKTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gKGxvd2VyVmFsIC0gbWluKSAvIHNwYW47XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBwYWRUb3AgKyAocHJpY2VBcmVhIC0gdmFsICogcHJpY2VBcmVhKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKHgpICYmIGlzRmluaXRlKHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYCR7eH0sJHt5fWApO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRzLmpvaW4oXCIgXCIpO1xyXG4gICAgICAgICAgICAgIH0pKCl9XHJcbiAgICAgICAgICAgICAgZmlsbD1cInJnYmEoMTM1LCAyMDYsIDIzNSwgMC4xNSlcIlxyXG4gICAgICAgICAgICAgIHN0cm9rZT1cIm5vbmVcIlxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgey8qIFVwcGVyIGJhbmQgb3V0bGluZSAqL31cclxuICAgICAgICAgICAgPHBvbHlsaW5lXHJcbiAgICAgICAgICAgICAgcG9pbnRzPXtib2xsaW5nZXJCYW5kcy51cHBlclxyXG4gICAgICAgICAgICAgICAgLm1hcCgodiwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICBpZiAodiA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSB4Rm9ySWR4KGkpO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSAodiAtIG1pbikgLyBzcGFuO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB5ID0gcGFkVG9wICsgKHByaWNlQXJlYSAtIHZhbCAqIHByaWNlQXJlYSk7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgJHt4fSwke3l9YDtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHAgPT4gcCAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIC5qb2luKFwiIFwiKX1cclxuICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXHJcbiAgICAgICAgICAgICAgc3Ryb2tlPVwicmdiYSgxMzUsIDIwNiwgMjM1LCAwLjgpXCJcclxuICAgICAgICAgICAgICBzdHJva2VXaWR0aD17MX1cclxuICAgICAgICAgICAgICB2ZWN0b3JFZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgey8qIExvd2VyIGJhbmQgb3V0bGluZSAqL31cclxuICAgICAgICAgICAgPHBvbHlsaW5lXHJcbiAgICAgICAgICAgICAgcG9pbnRzPXtib2xsaW5nZXJCYW5kcy5sb3dlclxyXG4gICAgICAgICAgICAgICAgLm1hcCgodiwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICBpZiAodiA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSB4Rm9ySWR4KGkpO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSAodiAtIG1pbikgLyBzcGFuO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB5ID0gcGFkVG9wICsgKHByaWNlQXJlYSAtIHZhbCAqIHByaWNlQXJlYSk7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgJHt4fSwke3l9YDtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHAgPT4gcCAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIC5qb2luKFwiIFwiKX1cclxuICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXHJcbiAgICAgICAgICAgICAgc3Ryb2tlPVwicmdiYSgxMzUsIDIwNiwgMjM1LCAwLjgpXCJcclxuICAgICAgICAgICAgICBzdHJva2VXaWR0aD17MX1cclxuICAgICAgICAgICAgICB2ZWN0b3JFZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgPC8+XHJcbiAgICAgICAgKX1cclxuICAgICAgICB7bW9kZSA9PT0gXCJsaW5lXCIgJiYgKFxyXG4gICAgICAgICAgPHBvbHlsaW5lXHJcbiAgICAgICAgICAgIHBvaW50cz17bGluZVB0c31cclxuICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxyXG4gICAgICAgICAgICBzdHJva2U9e3VwID8gXCJ2YXIoLS1jb2xvci1zdWNjZXNzKVwiIDogXCJ2YXIoLS1jb2xvci1kYW5nZXIpXCJ9XHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsyfVxyXG4gICAgICAgICAgICB2ZWN0b3JFZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxyXG4gICAgICAgICAgLz5cclxuICAgICAgICApfVxyXG4gICAgICAgIHttb2RlID09PSBcImNhbmRsZXNcIiAmJlxyXG4gICAgICAgICAgZHJhd0RhdGEubWFwKChkOiBDYW5kbGUsIGlkeDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlclggPSB4Rm9ySWR4KGlkeCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBjZW50ZXJYIC0gY2FuZGxlV2lkdGggLyAyO1xyXG4gICAgICAgICAgICBjb25zdCB2YWxPcGVuID0gbG9nU2NhbGVcclxuICAgICAgICAgICAgICA/IChNYXRoLmxvZzEwKGQubykgLSBNYXRoLmxvZzEwKG1pbikpIC8gKE1hdGgubG9nMTAobWF4KSAtIE1hdGgubG9nMTAobWluIHx8IDEpKVxyXG4gICAgICAgICAgICAgIDogKGQubyAtIG1pbikgLyBzcGFuO1xyXG4gICAgICAgICAgICBjb25zdCB2YWxDbG9zZSA9IGxvZ1NjYWxlXHJcbiAgICAgICAgICAgICAgPyAoTWF0aC5sb2cxMChkLmMpIC0gTWF0aC5sb2cxMChtaW4pKSAvIChNYXRoLmxvZzEwKG1heCkgLSBNYXRoLmxvZzEwKG1pbiB8fCAxKSlcclxuICAgICAgICAgICAgICA6IChkLmMgLSBtaW4pIC8gc3BhbjtcclxuICAgICAgICAgICAgY29uc3QgdmFsSGlnaCA9IGxvZ1NjYWxlXHJcbiAgICAgICAgICAgICAgPyAoTWF0aC5sb2cxMChkLmgpIC0gTWF0aC5sb2cxMChtaW4pKSAvIChNYXRoLmxvZzEwKG1heCkgLSBNYXRoLmxvZzEwKG1pbiB8fCAxKSlcclxuICAgICAgICAgICAgICA6IChkLmggLSBtaW4pIC8gc3BhbjtcclxuICAgICAgICAgICAgY29uc3QgdmFsTG93ID0gbG9nU2NhbGVcclxuICAgICAgICAgICAgICA/IChNYXRoLmxvZzEwKGQubCkgLSBNYXRoLmxvZzEwKG1pbikpIC8gKE1hdGgubG9nMTAobWF4KSAtIE1hdGgubG9nMTAobWluIHx8IDEpKVxyXG4gICAgICAgICAgICAgIDogKGQubCAtIG1pbikgLyBzcGFuO1xyXG4gICAgICAgICAgICBjb25zdCBvcGVuWSA9IDggKyAocHJpY2VBcmVhIC0gdmFsT3BlbiAqIHByaWNlQXJlYSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlWSA9IDggKyAocHJpY2VBcmVhIC0gdmFsQ2xvc2UgKiBwcmljZUFyZWEpO1xyXG4gICAgICAgICAgICBjb25zdCBoaWdoWSA9IDggKyAocHJpY2VBcmVhIC0gdmFsSGlnaCAqIHByaWNlQXJlYSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvd1kgPSA4ICsgKHByaWNlQXJlYSAtIHZhbExvdyAqIHByaWNlQXJlYSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJpc2luZyA9IGQuYyA+PSBkLm87XHJcbiAgICAgICAgICAgIGNvbnN0IHBjdCA9IE1hdGgubWluKDAuMDUsIE1hdGgubWF4KC0wLjA1LCAoZC5jIC0gZC5vKSAvIGQubykpO1xyXG4gICAgICAgICAgICBjb25zdCBpbnRlbnNpdHkgPSBNYXRoLmFicyhwY3QpIC8gMC4wNTtcclxuICAgICAgICAgICAgY29uc3QgYmFzZUNvbG9yID0gcmlzaW5nID8gXCJ2YXIoLS1jb2xvci1zdWNjZXNzKVwiIDogXCJ2YXIoLS1jb2xvci1kYW5nZXIpXCI7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGwgPSByaXNpbmdcclxuICAgICAgICAgICAgICA/IGByZ2JhKDM1LDEzNCw1NCwkezAuMzUgKyAwLjU1ICogaW50ZW5zaXR5fSlgXHJcbiAgICAgICAgICAgICAgOiBgcmdiYSgyNDgsODEsNzMsJHswLjM1ICsgMC41NSAqIGludGVuc2l0eX0pYDtcclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICA8ZyBrZXk9e2QudH0+XHJcbiAgICAgICAgICAgICAgICA8bGluZVxyXG4gICAgICAgICAgICAgICAgICB4MT17eCArIGNhbmRsZVdpZHRoIC8gMn1cclxuICAgICAgICAgICAgICAgICAgeDI9e3ggKyBjYW5kbGVXaWR0aCAvIDJ9XHJcbiAgICAgICAgICAgICAgICAgIHkxPXtoaWdoWX1cclxuICAgICAgICAgICAgICAgICAgeTI9e2xvd1l9XHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZT17YmFzZUNvbG9yfVxyXG4gICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD17MX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8cmVjdFxyXG4gICAgICAgICAgICAgICAgICB4PXt4fVxyXG4gICAgICAgICAgICAgICAgICB5PXtNYXRoLm1pbihvcGVuWSwgY2xvc2VZKX1cclxuICAgICAgICAgICAgICAgICAgd2lkdGg9e2NhbmRsZVdpZHRofVxyXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ9e01hdGgubWF4KDIsIE1hdGguYWJzKGNsb3NlWSAtIG9wZW5ZKSl9XHJcbiAgICAgICAgICAgICAgICAgIGZpbGw9e2ZpbGx9XHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZT17YmFzZUNvbG9yfVxyXG4gICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD17MC41fVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9KX1cclxuXHJcbiAgICAgICAgey8qIEVNQSAyMCAqL31cclxuICAgICAgICB7c2hvd0VNQTIwICYmIGVtYTIwLmxlbmd0aCAmJiAoXHJcbiAgICAgICAgICA8cG9seWxpbmVcclxuICAgICAgICAgICAgcG9pbnRzPXtlbWEyMFxyXG4gICAgICAgICAgICAgIC5tYXAoKHYsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh2ID09PSBudWxsKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB4Rm9ySWR4KGkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gbG9nU2NhbGVcclxuICAgICAgICAgICAgICAgICAgPyAoTWF0aC5sb2cxMCh2KSAtIE1hdGgubG9nMTAobWluKSkgLyAoTWF0aC5sb2cxMChtYXgpIC0gTWF0aC5sb2cxMChtaW4gfHwgMSkpXHJcbiAgICAgICAgICAgICAgICAgIDogKHYgLSBtaW4pIC8gc3BhbjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSA4ICsgKHByaWNlQXJlYSAtIHZhbCAqIHByaWNlQXJlYSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7eH0sJHt5fWA7XHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAuZmlsdGVyKHAgPT4gcCAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAuam9pbihcIiBcIil9XHJcbiAgICAgICAgICAgIGZpbGw9XCJub25lXCJcclxuICAgICAgICAgICAgc3Ryb2tlPVwiI2ZmOTUwMFwiXHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxLjR9XHJcbiAgICAgICAgICAgIHZlY3RvckVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICl9XHJcblxyXG4gICAgICAgIHtkcmF3RGF0YS5tYXAoKGQsIGlkeCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgY2VudGVyWCA9IHhGb3JJZHgoaWR4KTtcclxuICAgICAgICAgIGNvbnN0IHggPSBjZW50ZXJYIC0gY2FuZGxlV2lkdGggLyAyO1xyXG4gICAgICAgICAgY29uc3Qgdm9sUmF0aW8gPSBkLnYgLyBtYXhWb2w7XHJcbiAgICAgICAgICBsZXQgYmFySCA9IHZvbFJhdGlvICogKHZvbEggLSAxNik7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIE1pbmltdW0gYmFyIGhlaWdodCBmb3IgdmlzaWJpbGl0eSAoZXNwZWNpYWxseSBmb3IgbG93IGFmdGVyLWhvdXJzIHZvbHVtZSlcclxuICAgICAgICAgIGNvbnN0IG1pbkJhckhlaWdodCA9IDI7XHJcbiAgICAgICAgICBpZiAoYmFySCA+IDAgJiYgYmFySCA8IG1pbkJhckhlaWdodCkgYmFySCA9IG1pbkJhckhlaWdodDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgeSA9IHByaWNlSCArICh2b2xIIC0gYmFySCk7XHJcbiAgICAgICAgICBjb25zdCByaXNpbmcgPSBkLmMgPj0gZC5vO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGV4dGVuZGVkIGhvdXJzIChiZWZvcmUgOTozMCBvciBhZnRlciAxNjowMCBFVClcclxuICAgICAgICAgIGNvbnN0IGNhbmRsZURhdGUgPSBuZXcgRGF0ZShkLnQpO1xyXG4gICAgICAgICAgY29uc3QgaG91ciA9IGNhbmRsZURhdGUuZ2V0SG91cnMoKTtcclxuICAgICAgICAgIGNvbnN0IG1pbnV0ZSA9IGNhbmRsZURhdGUuZ2V0TWludXRlcygpO1xyXG4gICAgICAgICAgY29uc3QgdGltZUluTWludXRlcyA9IGhvdXIgKiA2MCArIG1pbnV0ZTtcclxuICAgICAgICAgIGNvbnN0IG1hcmtldE9wZW4gPSA5ICogNjAgKyAzMDsgLy8gOTozMCBBTVxyXG4gICAgICAgICAgY29uc3QgbWFya2V0Q2xvc2UgPSAxNiAqIDYwOyAvLyA0OjAwIFBNXHJcbiAgICAgICAgICBjb25zdCBpc0V4dGVuZGVkSG91cnMgPSB0aW1lSW5NaW51dGVzIDwgbWFya2V0T3BlbiB8fCB0aW1lSW5NaW51dGVzID49IG1hcmtldENsb3NlO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8cmVjdFxyXG4gICAgICAgICAgICAgIGtleT17ZC50ICsgXCI6dm9sXCJ9XHJcbiAgICAgICAgICAgICAgeD17eH1cclxuICAgICAgICAgICAgICB5PXt5fVxyXG4gICAgICAgICAgICAgIHdpZHRoPXtjYW5kbGVXaWR0aH1cclxuICAgICAgICAgICAgICBoZWlnaHQ9e2Jhckh9XHJcbiAgICAgICAgICAgICAgZmlsbD17cmlzaW5nID8gXCJ2YXIoLS1jb2xvci1zdWNjZXNzKVwiIDogXCJ2YXIoLS1jb2xvci1kYW5nZXIpXCJ9XHJcbiAgICAgICAgICAgICAgb3BhY2l0eT17aXNFeHRlbmRlZEhvdXJzID8gMC4yIDogMC4zNX1cclxuICAgICAgICAgICAgLz5cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSl9XHJcbiAgICAgICAge3Nob3dWb2xNQSAmJiB2b2xNQS5sZW5ndGggJiYgKFxyXG4gICAgICAgICAgPHBvbHlsaW5lXHJcbiAgICAgICAgICAgIHBvaW50cz17dm9sTUFcclxuICAgICAgICAgICAgICAubWFwKCh2LCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0geEZvcklkeChpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gdiAvIG1heFZvbDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhckggPSByYXRpbyAqICh2b2xIIC0gMTYpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHByaWNlSCArICh2b2xIIC0gYmFySCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7eH0sJHt5fWA7XHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAuZmlsdGVyKHAgPT4gcCAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAuam9pbihcIiBcIil9XHJcbiAgICAgICAgICAgIGZpbGw9XCJub25lXCJcclxuICAgICAgICAgICAgc3Ryb2tlPVwiIzU4YTZmZlwiXHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxfVxyXG4gICAgICAgICAgICB2ZWN0b3JFZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxyXG4gICAgICAgICAgLz5cclxuICAgICAgICApfVxyXG4gICAgICAgIHtob3ZlclBvaW50ICYmXHJcbiAgICAgICAgICAoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB4ID0geEZvcklkeChob3ZlciEpO1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gOCArIChwcmljZUFyZWEgLSAoKGhvdmVyUG9pbnQuYyAtIG1pbikgLyBzcGFuKSAqIHByaWNlQXJlYSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgPGc+XHJcbiAgICAgICAgICAgICAgICA8bGluZVxyXG4gICAgICAgICAgICAgICAgICB4MT17eH1cclxuICAgICAgICAgICAgICAgICAgeDI9e3h9XHJcbiAgICAgICAgICAgICAgICAgIHkxPXswfVxyXG4gICAgICAgICAgICAgICAgICB5Mj17cHJpY2VIfVxyXG4gICAgICAgICAgICAgICAgICBzdHJva2U9e3RoZW1lID09PSBcImxpZ2h0XCIgPyBcIiM2NTZkNzZcIiA6IFwiIzdkODU5MFwifVxyXG4gICAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk9XCI0IDNcIlxyXG4gICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD17MX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8bGluZVxyXG4gICAgICAgICAgICAgICAgICB4MT17MH1cclxuICAgICAgICAgICAgICAgICAgeDI9e3d9XHJcbiAgICAgICAgICAgICAgICAgIHkxPXt5fVxyXG4gICAgICAgICAgICAgICAgICB5Mj17eX1cclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlPXt0aGVtZSA9PT0gXCJsaWdodFwiID8gXCIjNjU2ZDc2XCIgOiBcIiM3ZDg1OTBcIn1cclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5PVwiNCAzXCJcclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPGNpcmNsZVxyXG4gICAgICAgICAgICAgICAgICBjeD17eH1cclxuICAgICAgICAgICAgICAgICAgY3k9e3l9XHJcbiAgICAgICAgICAgICAgICAgIHI9ezV9XHJcbiAgICAgICAgICAgICAgICAgIGZpbGw9XCJ2YXIoLS1jb2xvci1iZylcIlxyXG4gICAgICAgICAgICAgICAgICBzdHJva2U9e3VwID8gXCJ2YXIoLS1jb2xvci1zdWNjZXNzKVwiIDogXCJ2YXIoLS1jb2xvci1kYW5nZXIpXCJ9XHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsyfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9KSgpfVxyXG4gICAgICAgIHtkcmF3RGF0YS5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgICAoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0ID0gZHJhd0RhdGFbZHJhd0RhdGEubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSA4ICsgKHByaWNlQXJlYSAtICgobGFzdC5jIC0gbWluKSAvIHNwYW4pICogcHJpY2VBcmVhKTtcclxuICAgICAgICAgICAgY29uc3QgaXNVcCA9IGxhc3QuYyA+PSBjbG9zZXNbMF07XHJcbiAgICAgICAgICAgIC8vIEJyaWdodGVyLCBoaWdoZXIgY29udHJhc3QgY29sb3JzIGZvciBsYXN0IHByaWNlIGxhYmVsXHJcbiAgICAgICAgICAgIGNvbnN0IGJyaWdodEdyZWVuID0gXCIjMDBmZjQxXCI7IC8vIEJyaWdodCBuZW9uIGdyZWVuXHJcbiAgICAgICAgICAgIGNvbnN0IGJyaWdodFJlZCA9IFwiI2ZmMzM2NlwiOyAvLyBCcmlnaHQgcmVkXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gaXNVcCA/IGJyaWdodEdyZWVuIDogYnJpZ2h0UmVkO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICA8Zz5cclxuICAgICAgICAgICAgICAgIDxsaW5lXHJcbiAgICAgICAgICAgICAgICAgIHgxPXtwYWRMZWZ0fVxyXG4gICAgICAgICAgICAgICAgICB4Mj17cGFkTGVmdCArIHByaWNlV31cclxuICAgICAgICAgICAgICAgICAgeTE9e3l9XHJcbiAgICAgICAgICAgICAgICAgIHkyPXt5fVxyXG4gICAgICAgICAgICAgICAgICBzdHJva2U9e2NvbG9yfVxyXG4gICAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk9XCIyIDRcIlxyXG4gICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD17MX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8cmVjdFxyXG4gICAgICAgICAgICAgICAgICB4PXtwYWRMZWZ0ICsgcHJpY2VXICsgNH1cclxuICAgICAgICAgICAgICAgICAgeT17eSAtIExheW91dENvbmZpZy5MQVNUX1BSSUNFX0xBQkVMX0hFSUdIVCAvIDJ9XHJcbiAgICAgICAgICAgICAgICAgIHdpZHRoPXtMYXlvdXRDb25maWcuTEFTVF9QUklDRV9MQUJFTF9XSURUSH1cclxuICAgICAgICAgICAgICAgICAgaGVpZ2h0PXtMYXlvdXRDb25maWcuTEFTVF9QUklDRV9MQUJFTF9IRUlHSFR9XHJcbiAgICAgICAgICAgICAgICAgIGZpbGw9e2lzVXAgXHJcbiAgICAgICAgICAgICAgICAgICAgPyAodGhlbWUgPT09IFwibGlnaHRcIiA/IFwiI2U2ZmZmMFwiIDogXCIjMDAyMjExXCIpIFxyXG4gICAgICAgICAgICAgICAgICAgIDogKHRoZW1lID09PSBcImxpZ2h0XCIgPyBcIiNmZmU2ZWVcIiA6IFwiIzJkMDAxMVwiKX1cclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlPXtjb2xvcn1cclxuICAgICAgICAgICAgICAgICAgcng9ezN9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPHRleHRcclxuICAgICAgICAgICAgICAgICAgeD17cGFkTGVmdCArIHByaWNlVyArIDQgKyBMYXlvdXRDb25maWcuTEFTVF9QUklDRV9MQUJFTF9XSURUSCAvIDJ9XHJcbiAgICAgICAgICAgICAgICAgIHk9e3kgKyBMYXlvdXRDb25maWcuTEFTVF9QUklDRV9MQUJFTF9GT05UX1NJWkUgLyAzfVxyXG4gICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcclxuICAgICAgICAgICAgICAgICAgZmlsbD17Y29sb3J9XHJcbiAgICAgICAgICAgICAgICAgIGZvbnRTaXplPXtMYXlvdXRDb25maWcuTEFTVF9QUklDRV9MQUJFTF9GT05UX1NJWkV9XHJcbiAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ9ezYwMH1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAge2xhc3QuYy50b0ZpeGVkKGRlY2ltYWxzKX1cclxuICAgICAgICAgICAgICAgIDwvdGV4dD5cclxuICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9KSgpfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHsvKiBJbmRpY2F0b3IgbGFiZWxzIHdpdGggc21hcnQgb3ZlcmxhcCBhdm9pZGFuY2UgKi99XHJcbiAgICAgICAgeygoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBsYWJlbHM6IEFycmF5PHsgeTogbnVtYmVyOyB2YWx1ZTogbnVtYmVyOyBjb2xvcjogc3RyaW5nOyBiZ0NvbG9yOiBzdHJpbmc7IHN0cm9rZTogc3RyaW5nIH0+ID0gW107XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIE1haW4gcHJpY2UgcG9zaXRpb25cclxuICAgICAgICAgIGNvbnN0IGxhc3RQcmljZSA9IGRyYXdEYXRhW2RyYXdEYXRhLmxlbmd0aCAtIDFdPy5jIHx8IDA7XHJcbiAgICAgICAgICBjb25zdCBwcmljZVkgPSA4ICsgKHByaWNlQXJlYSAtICgobGFzdFByaWNlIC0gbWluKSAvIHNwYW4pICogcHJpY2VBcmVhKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gRU1BMjBcclxuICAgICAgICAgIGlmIChzaG93RU1BMjAgJiYgZW1hMjAubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0RW1hID0gZW1hMjBbZW1hMjAubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGlmIChsYXN0RW1hICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgbGFiZWxzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgeTogOCArIChwcmljZUFyZWEgLSAoKGxhc3RFbWEgLSBtaW4pIC8gc3BhbikgKiBwcmljZUFyZWEpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxhc3RFbWEsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIjZmY5NTAwXCIsXHJcbiAgICAgICAgICAgICAgICBiZ0NvbG9yOiB0aGVtZSA9PT0gXCJsaWdodFwiID8gXCIjZmZmNWU2XCIgOiBcIiMyZDI0MDBcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjZmY5NTAwXCIsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQm9sbGluZ2VyIEJhbmRzIFVwcGVyXHJcbiAgICAgICAgICBpZiAoc2hvd0JvbGxpbmdlckJhbmRzICYmIGJvbGxpbmdlckJhbmRzLnVwcGVyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgbGFzdFVwcGVyID0gYm9sbGluZ2VyQmFuZHMudXBwZXJbYm9sbGluZ2VyQmFuZHMudXBwZXIubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGlmIChsYXN0VXBwZXIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICBsYWJlbHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB5OiA4ICsgKHByaWNlQXJlYSAtICgobGFzdFVwcGVyIC0gbWluKSAvIHNwYW4pICogcHJpY2VBcmVhKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBsYXN0VXBwZXIsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJyZ2JhKDEzNSwgMjA2LCAyMzUsIDEpXCIsXHJcbiAgICAgICAgICAgICAgICBiZ0NvbG9yOiB0aGVtZSA9PT0gXCJsaWdodFwiID8gXCIjZTZmN2ZmXCIgOiBcIiMwMDFhMmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCJyZ2JhKDEzNSwgMjA2LCAyMzUsIDAuOClcIixcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBCb2xsaW5nZXIgQmFuZHMgTG93ZXJcclxuICAgICAgICAgIGlmIChzaG93Qm9sbGluZ2VyQmFuZHMgJiYgYm9sbGluZ2VyQmFuZHMubG93ZXIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0TG93ZXIgPSBib2xsaW5nZXJCYW5kcy5sb3dlcltib2xsaW5nZXJCYW5kcy5sb3dlci5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgaWYgKGxhc3RMb3dlciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIGxhYmVscy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHk6IDggKyAocHJpY2VBcmVhIC0gKChsYXN0TG93ZXIgLSBtaW4pIC8gc3BhbikgKiBwcmljZUFyZWEpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxhc3RMb3dlcixcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBcInJnYmEoMTM1LCAyMDYsIDIzNSwgMSlcIixcclxuICAgICAgICAgICAgICAgIGJnQ29sb3I6IHRoZW1lID09PSBcImxpZ2h0XCIgPyBcIiNlNmY3ZmZcIiA6IFwiIzAwMWEyZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcInJnYmEoMTM1LCAyMDYsIDIzNSwgMC44KVwiLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEFkanVzdCBwb3NpdGlvbnMgdG8gYXZvaWQgb3ZlcmxhcHNcclxuICAgICAgICAgIGNvbnN0IG1pbkdhcCA9IExheW91dENvbmZpZy5JTkRJQ0FUT1JfTEFCRUxfSEVJR0hUICsgMjtcclxuICAgICAgICAgIGNvbnN0IGFkanVzdGVkTGFiZWxzID0gbGFiZWxzLm1hcCgobGFiZWwpID0+IHtcclxuICAgICAgICAgICAgbGV0IGFkanVzdGVkWSA9IGxhYmVsLnk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBDaGVjayBvdmVybGFwIHdpdGggbWFpbiBwcmljZSBsYWJlbFxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoYWRqdXN0ZWRZIC0gcHJpY2VZKSA8IG1pbkdhcCkge1xyXG4gICAgICAgICAgICAgIC8vIE1vdmUgYWJvdmUgb3IgYmVsb3cgYmFzZWQgb24gd2hpY2ggc2lkZSBoYXMgbW9yZSBzcGFjZVxyXG4gICAgICAgICAgICAgIGlmIChhZGp1c3RlZFkgPCBwcmljZVkpIHtcclxuICAgICAgICAgICAgICAgIC8vIExhYmVsIGlzIGFib3ZlIHByaWNlLCBtb3ZlIGl0IGZ1cnRoZXIgdXBcclxuICAgICAgICAgICAgICAgIGFkanVzdGVkWSA9IHByaWNlWSAtIG1pbkdhcDtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTGFiZWwgaXMgYmVsb3cgcHJpY2UsIG1vdmUgaXQgZnVydGhlciBkb3duXHJcbiAgICAgICAgICAgICAgICBhZGp1c3RlZFkgPSBwcmljZVkgKyBtaW5HYXA7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4geyAuLi5sYWJlbCwgeTogYWRqdXN0ZWRZIH07XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gU29ydCBieSBZIHBvc2l0aW9uIGFuZCBhZGp1c3QgZm9yIG92ZXJsYXBzIGJldHdlZW4gaW5kaWNhdG9yc1xyXG4gICAgICAgICAgYWRqdXN0ZWRMYWJlbHMuc29ydCgoYSwgYikgPT4gYS55IC0gYi55KTtcclxuICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYWRqdXN0ZWRMYWJlbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGFkanVzdGVkTGFiZWxzW2ldLnkgLSBhZGp1c3RlZExhYmVsc1tpIC0gMV0ueSA8IG1pbkdhcCkge1xyXG4gICAgICAgICAgICAgIGFkanVzdGVkTGFiZWxzW2ldLnkgPSBhZGp1c3RlZExhYmVsc1tpIC0gMV0ueSArIG1pbkdhcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByZXR1cm4gYWRqdXN0ZWRMYWJlbHMubWFwKChsYWJlbCwgaWR4KSA9PiAoXHJcbiAgICAgICAgICAgIDxnIGtleT17YGluZGljYXRvci1sYWJlbC0ke2lkeH1gfT5cclxuICAgICAgICAgICAgICA8cmVjdFxyXG4gICAgICAgICAgICAgICAgeD17cGFkTGVmdCArIHByaWNlVyArIDR9XHJcbiAgICAgICAgICAgICAgICB5PXtsYWJlbC55IC0gTGF5b3V0Q29uZmlnLklORElDQVRPUl9MQUJFTF9IRUlHSFQgLyAyfVxyXG4gICAgICAgICAgICAgICAgd2lkdGg9e0xheW91dENvbmZpZy5JTkRJQ0FUT1JfTEFCRUxfV0lEVEh9XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ9e0xheW91dENvbmZpZy5JTkRJQ0FUT1JfTEFCRUxfSEVJR0hUfVxyXG4gICAgICAgICAgICAgICAgZmlsbD17bGFiZWwuYmdDb2xvcn1cclxuICAgICAgICAgICAgICAgIHN0cm9rZT17bGFiZWwuc3Ryb2tlfVxyXG4gICAgICAgICAgICAgICAgcng9ezJ9XHJcbiAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICA8dGV4dFxyXG4gICAgICAgICAgICAgICAgeD17cGFkTGVmdCArIHByaWNlVyArIDQgKyBMYXlvdXRDb25maWcuSU5ESUNBVE9SX0xBQkVMX1dJRFRIIC8gMn1cclxuICAgICAgICAgICAgICAgIHk9e2xhYmVsLnkgKyBMYXlvdXRDb25maWcuSU5ESUNBVE9SX0xBQkVMX0ZPTlRfU0laRSAvIDN9XHJcbiAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcclxuICAgICAgICAgICAgICAgIGZpbGw9e2xhYmVsLmNvbG9yfVxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU9e0xheW91dENvbmZpZy5JTkRJQ0FUT1JfTEFCRUxfRk9OVF9TSVpFfVxyXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodD17NjAwfVxyXG4gICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIHtsYWJlbC52YWx1ZS50b0ZpeGVkKGRlY2ltYWxzKX1cclxuICAgICAgICAgICAgICA8L3RleHQ+XHJcbiAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICkpO1xyXG4gICAgICAgIH0pKCl9XHJcbiAgICAgICAgXHJcbiAgICAgICAge3RpbWVUaWNrcy5tYXAoKHQsIGkpID0+IChcclxuICAgICAgICAgIDx0ZXh0XHJcbiAgICAgICAgICAgIGtleT17XCJ4bGFiZWwtXCIgKyBpfVxyXG4gICAgICAgICAgICB4PXt0Lnh9XHJcbiAgICAgICAgICAgIHk9e2ggLSA2fVxyXG4gICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcclxuICAgICAgICAgICAgZm9udFNpemU9e0xheW91dENvbmZpZy5BWElTX1hfRk9OVF9TSVpFfVxyXG4gICAgICAgICAgICBmaWxsPXt0aGVtZSA9PT0gXCJsaWdodFwiID8gXCIjMDAwMDAwXCIgOiBcIiNmZmZmZmZcIn1cclxuICAgICAgICAgID5cclxuICAgICAgICAgICAge3QubGFiZWx9XHJcbiAgICAgICAgICA8L3RleHQ+XHJcbiAgICAgICAgKSl9XHJcbiAgICAgIDwvc3ZnPlxyXG4gICAgICB7aG92ZXJQb2ludCAmJiAoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhvdmVyWCA9IHhGb3JJZHgoaG92ZXIhKTtcclxuICAgICAgICBjb25zdCBob3ZlclhQZXJjZW50ID0gKChob3ZlclggLSBwYWRMZWZ0KSAvIHByaWNlVykgKiAxMDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRXN0aW1hdGUgdG9vbHRpcCB3aWR0aCAoYXBwcm94aW1hdGUpXHJcbiAgICAgICAgY29uc3QgdG9vbHRpcFdpZHRoID0gMTIwOyAvLyBwaXhlbHNcclxuICAgICAgICBjb25zdCBjaGFydExlZnRQeCA9IHBhZExlZnQ7XHJcbiAgICAgICAgY29uc3QgY2hhcnRSaWdodFB4ID0gcGFkTGVmdCArIHByaWNlVztcclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBpZiB0b29sdGlwIHdvdWxkIG92ZXJmbG93IG9uIHJpZ2h0IG9yIGxlZnRcclxuICAgICAgICBjb25zdCB3b3VsZE92ZXJmbG93UmlnaHQgPSAoaG92ZXJYICsgdG9vbHRpcFdpZHRoIC8gMikgPiBjaGFydFJpZ2h0UHg7XHJcbiAgICAgICAgY29uc3Qgd291bGRPdmVyZmxvd0xlZnQgPSAoaG92ZXJYIC0gdG9vbHRpcFdpZHRoIC8gMikgPCBjaGFydExlZnRQeDtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgbGVmdFBvczogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGxldCByaWdodFBvczogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGxldCB0cmFuc2Zvcm06IHN0cmluZztcclxuICAgICAgICBcclxuICAgICAgICBpZiAod291bGRPdmVyZmxvd1JpZ2h0KSB7XHJcbiAgICAgICAgICAvLyBBbmNob3IgdG8gcmlnaHQgc2lkZSBvZiBob3ZlciBwb2ludFxyXG4gICAgICAgICAgcmlnaHRQb3MgPSBgJHsxMDAgLSBob3ZlclhQZXJjZW50fSVgO1xyXG4gICAgICAgICAgdHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVYKDEwMCUpXCI7XHJcbiAgICAgICAgfSBlbHNlIGlmICh3b3VsZE92ZXJmbG93TGVmdCkge1xyXG4gICAgICAgICAgLy8gQW5jaG9yIHRvIGxlZnQgc2lkZSBvZiBob3ZlciBwb2ludFxyXG4gICAgICAgICAgbGVmdFBvcyA9IGAke2hvdmVyWFBlcmNlbnR9JWA7XHJcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZVgoMClcIjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gQ2VudGVyIG9uIGhvdmVyIHBvaW50IChkZWZhdWx0KVxyXG4gICAgICAgICAgbGVmdFBvcyA9IGAke2hvdmVyWFBlcmNlbnR9JWA7XHJcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZVgoLTUwJSlcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICAgIGxlZnQ6IGxlZnRQb3MsXHJcbiAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0UG9zLFxyXG4gICAgICAgICAgICAgIHRvcDogOCxcclxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiB0aGVtZSA9PT0gXCJsaWdodFwiID8gXCJyZ2JhKDI1NSwyNTUsMjU1LDAuOTUpXCIgOiBcInJnYmEoMCwwLDAsMC43OClcIixcclxuICAgICAgICAgICAgICBwYWRkaW5nOiBcIjZweCA4cHhcIixcclxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDQsXHJcbiAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgYm9yZGVyOiB0aGVtZSA9PT0gXCJsaWdodFwiID8gXCIxcHggc29saWQgI2QwZDdkZVwiIDogXCIxcHggc29saWQgIzMwMzYzZFwiLFxyXG4gICAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCIsXHJcbiAgICAgICAgICAgICAgYmFja2Ryb3BGaWx0ZXI6IFwiYmx1cigycHgpXCIsXHJcbiAgICAgICAgICAgICAgY29sb3I6IHRoZW1lID09PSBcImxpZ2h0XCIgPyBcIiMyNDI5MmZcIiA6IFwiI2U2ZWRmM1wiLFxyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybSxcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgID5cclxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBmb250U2l6ZTogMTEsIG9wYWNpdHk6IDAuNyB9fT5cclxuICAgICAgICAgICAgICB7bmV3IERhdGUoaG92ZXJQb2ludC50KS50b0xvY2FsZVN0cmluZygpfVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBmb250V2VpZ2h0OiA2MDAgfX0+e2hvdmVyUG9pbnQuYy50b0ZpeGVkKDIpfTwvZGl2PlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgICAgfSkoKX1cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwiTGF5b3V0Q29uZmlnIiwidXNlQXV0aCIsIkFkdmFuY2VkUHJpY2VDaGFydCIsImRhdGEiLCJtb2RlIiwicmFuZ2UiLCJsb2dTY2FsZSIsInNob3dWb2xNQSIsInNob3dCb2xsaW5nZXJCYW5kcyIsInNob3dFTUEyMCIsInN5bWJvbCIsInRoZW1lIiwiaG92ZXIiLCJzZXRIb3ZlciIsInVzZVN0YXRlIiwic291cmNlRGF0YSIsIlRBUkdFVF9QRVJfUkFOR0UiLCJ0YXJnZXQiLCJidWNrZXRTaXplIiwibGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJyYXdFbWEyMCIsImVtYSIsIm1hcCIsImQiLCJjIiwicmF3Vm9sTUEiLCJzbWEiLCJ2IiwicmF3Qm9sbGluZ2VyQmFuZHMiLCJjYWxjdWxhdGVCb2xsaW5nZXJCYW5kcyIsInVwcGVyIiwibG93ZXIiLCJtaWRkbGUiLCJidWNrZXRBZ2dyZWdhdGUiLCJzcmMiLCJzaXplIiwib3V0IiwiaSIsInNsaWNlIiwibyIsImgiLCJJbmZpbml0eSIsImwiLCJzIiwicHVzaCIsInQiLCJidWNrZXRJbmRpY2F0b3IiLCJ2YWx1ZXMiLCJiYXNlRGF0YSIsImJ1Y2tldGVkRW1hMjAiLCJidWNrZXRlZFZvbE1BIiwiYnVja2V0ZWRCb2xsaW5nZXJCYW5kcyIsImJ1ZmZlclBlclJhbmdlIiwiYnVmZmVyQ2FuZGxlcyIsIm1pbiIsImZsb29yIiwiZGlzcGxheURhdGEiLCJ3aW5kb3dJZHgiLCJzZXRXaW5kb3dJZHgiLCJ3U3RhcnQiLCJ3RW5kIiwiZnVsbFN0YXJ0IiwiZnVsbEVuZCIsImVmZmVjdGl2ZVN0YXJ0IiwibWF4IiwiZWZmZWN0aXZlRW5kIiwic2FmZUVuZCIsInNhZmVTdGFydCIsImRyYXdEYXRhIiwiaW5kaWNhdG9yU3RhcnQiLCJpbmRpY2F0b3JFbmQiLCJlbWEyMCIsInZvbE1BIiwiYm9sbGluZ2VyQmFuZHMiLCJjbG9zZXMiLCJoaWdocyIsImxvd3MiLCJxdWFudGlsZSIsImFyciIsInEiLCJzb3J0ZWQiLCJzb3J0IiwiYSIsImIiLCJwb3MiLCJiYXNlIiwicmVzdCIsInVuZGVmaW5lZCIsImxhc3RDIiwic3BhbiIsIlMiLCJDSEFSVF9TQ0FMRSIsImhWaXN1YWxCYXNlIiwiR1JBUEhfSEVJR0hUIiwidm9sdW1lUG9ydGlvbiIsImhWaXN1YWwiLCJ2b2xIIiwicHJpY2VIIiwiYXhpc0Zvb3RlciIsIkFYSVNfRk9PVEVSX0hFSUdIVCIsInciLCJHUkFQSF9XSURUSCIsImd1dHRlclJpZ2h0IiwiQVhJU19SSUdIVF9HVVRURVIiLCJwYWRUb3AiLCJwYWRCb3R0b20iLCJwYWRMZWZ0IiwicHJpY2VBcmVhIiwidXAiLCJwcmljZVciLCJudW1DYW5kbGVzIiwieEZvcklkeCIsImlkeCIsImRyYXdUaW1lcyIsIkRhdGUiLCJnZXRUaW1lIiwiY2FuZGxlV2lkdGgiLCJsaW5lUHRzIiwieCIsInZhbCIsImxvZzEwIiwieSIsImpvaW4iLCJob3ZlclBvaW50Iiwib25Nb3ZlIiwiZSIsInJlY3QiLCJjdXJyZW50VGFyZ2V0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50WCIsImxlZnQiLCJ4UmF0aW8iLCJ3aWR0aCIsInJvdW5kIiwiZHJhZ1N0YXRlIiwib25XaGVlbCIsInByZXZlbnREZWZhdWx0IiwiZGVsdGEiLCJkZWx0YVkiLCJmYWN0b3IiLCJjdXJyZW50TGVuIiwibmV3TGVuIiwiZm9jdXNJZHgiLCJuZXdTdGFydCIsIm5ld0VuZCIsIm9uUG9pbnRlckRvd24iLCJzZXRQb2ludGVyQ2FwdHVyZSIsInBvaW50ZXJJZCIsImN1cnJlbnQiLCJzdGFydFgiLCJzdGFydFJhbmdlIiwib25Qb2ludGVyTW92ZSIsImVJZHgiLCJsZW4iLCJwaXhlbFBlckNhbmRsZSIsImRlbHRhUHgiLCJzaGlmdCIsIm9uUG9pbnRlclVwIiwibmljZVRpY2tzIiwibG93IiwiaGlnaCIsInJhd1NwYW4iLCJyb3VnaFN0ZXAiLCJwb3cxMCIsInBvdyIsIm11bHRpcGxlcyIsImZvdW5kIiwiZmluZCIsIm0iLCJzdGVwIiwiZmlyc3QiLCJ0aWNrcyIsInRpbWVUaWNrcyIsInNlZW4iLCJTZXQiLCJmb3JFYWNoIiwiaGgiLCJnZXRIb3VycyIsIm1tIiwiZ2V0TWludXRlcyIsInRpbWVLZXkiLCJoYXMiLCJhZGQiLCJsYWJlbCIsInRvTG9jYWxlVGltZVN0cmluZyIsImhvdXIiLCJtaW51dGUiLCJob3VyMTIiLCJrIiwidG9EYXRlU3RyaW5nIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwid2Vla2RheSIsInRvVXBwZXJDYXNlIiwiZ2V0RGF5Iiwia2V5IiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJtb25kYXlDb3VudCIsInNlZW5Nb250aCIsIm1rIiwidG9Mb2NhbGVTdHJpbmciLCJtb250aCIsInNlZW5ZZWFyIiwiU3RyaW5nIiwibWF4Vm9sIiwibWFnbml0dWRlIiwiYWJzIiwiZGVjaW1hbHMiLCJwZXJpb2QiLCJBcnJheSIsImZpbGwiLCJzdW0iLCJzdGREZXZNdWx0aXBsaWVyIiwiYXZnIiwicmVkdWNlIiwidmFyaWFuY2UiLCJzdGREZXYiLCJzcXJ0IiwiZGl2Iiwic3R5bGUiLCJwb3NpdGlvbiIsImluc2V0IiwiZm9udFNpemUiLCJzdmciLCJ2aWV3Qm94IiwicHJlc2VydmVBc3BlY3RSYXRpbyIsImhlaWdodCIsImN1cnNvciIsInVzZXJTZWxlY3QiLCJmb250RmFtaWx5Iiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlTGVhdmUiLCJnIiwibGluZSIsIngxIiwieDIiLCJ5MSIsInkyIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJ0ZXh0IiwiQVhJU19ZX0xBQkVMX1hfT0ZGU0VUIiwiQVhJU19ZX0ZPTlRfU0laRSIsInRvRml4ZWQiLCJwb2x5Z29uIiwicG9pbnRzIiwidXBwZXJWYWwiLCJpc0Zpbml0ZSIsImxvd2VyVmFsIiwicG9seWxpbmUiLCJmaWx0ZXIiLCJwIiwidmVjdG9yRWZmZWN0IiwiY2VudGVyWCIsInZhbE9wZW4iLCJ2YWxDbG9zZSIsInZhbEhpZ2giLCJ2YWxMb3ciLCJvcGVuWSIsImNsb3NlWSIsImhpZ2hZIiwibG93WSIsInJpc2luZyIsInBjdCIsImludGVuc2l0eSIsImJhc2VDb2xvciIsInZvbFJhdGlvIiwiYmFySCIsIm1pbkJhckhlaWdodCIsImNhbmRsZURhdGUiLCJ0aW1lSW5NaW51dGVzIiwibWFya2V0T3BlbiIsIm1hcmtldENsb3NlIiwiaXNFeHRlbmRlZEhvdXJzIiwib3BhY2l0eSIsInJhdGlvIiwic3Ryb2tlRGFzaGFycmF5IiwiY2lyY2xlIiwiY3giLCJjeSIsInIiLCJsYXN0IiwiaXNVcCIsImJyaWdodEdyZWVuIiwiYnJpZ2h0UmVkIiwiY29sb3IiLCJMQVNUX1BSSUNFX0xBQkVMX0hFSUdIVCIsIkxBU1RfUFJJQ0VfTEFCRUxfV0lEVEgiLCJyeCIsIkxBU1RfUFJJQ0VfTEFCRUxfRk9OVF9TSVpFIiwidGV4dEFuY2hvciIsImZvbnRXZWlnaHQiLCJsYWJlbHMiLCJsYXN0UHJpY2UiLCJwcmljZVkiLCJsYXN0RW1hIiwidmFsdWUiLCJiZ0NvbG9yIiwibGFzdFVwcGVyIiwibGFzdExvd2VyIiwibWluR2FwIiwiSU5ESUNBVE9SX0xBQkVMX0hFSUdIVCIsImFkanVzdGVkTGFiZWxzIiwiYWRqdXN0ZWRZIiwiSU5ESUNBVE9SX0xBQkVMX1dJRFRIIiwiSU5ESUNBVE9SX0xBQkVMX0ZPTlRfU0laRSIsIkFYSVNfWF9GT05UX1NJWkUiLCJob3ZlclgiLCJob3ZlclhQZXJjZW50IiwidG9vbHRpcFdpZHRoIiwiY2hhcnRMZWZ0UHgiLCJjaGFydFJpZ2h0UHgiLCJ3b3VsZE92ZXJmbG93UmlnaHQiLCJ3b3VsZE92ZXJmbG93TGVmdCIsImxlZnRQb3MiLCJyaWdodFBvcyIsInRyYW5zZm9ybSIsInJpZ2h0IiwidG9wIiwiYmFja2dyb3VuZCIsInBhZGRpbmciLCJib3JkZXJSYWRpdXMiLCJwb2ludGVyRXZlbnRzIiwiYm9yZGVyIiwid2hpdGVTcGFjZSIsImJhY2tkcm9wRmlsdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/dashboard/AdvancedPriceChart.tsx\n"));

/***/ })

});