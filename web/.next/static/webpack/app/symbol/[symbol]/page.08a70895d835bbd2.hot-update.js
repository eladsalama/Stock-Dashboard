"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/symbol/[symbol]/page",{

/***/ "(app-pages-browser)/./src/components/dashboard/AdvancedPriceChart.tsx":
/*!*********************************************************!*\
  !*** ./src/components/dashboard/AdvancedPriceChart.tsx ***!
  \*********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ AdvancedPriceChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _layoutConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layoutConfig */ \"(app-pages-browser)/./src/components/dashboard/layoutConfig.ts\");\n/* harmony import */ var _auth_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../auth-context/AuthContext */ \"(app-pages-browser)/./src/components/auth-context/AuthContext.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction AdvancedPriceChart(param) {\n    let { data, mode, range, logScale, showVolMA, showBollingerBands = false, showEMA20 = false, symbol } = param;\n    _s();\n    const { theme } = (0,_auth_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [hover, setHover] = react__WEBPACK_IMPORTED_MODULE_1___default().useState(null);\n    // Note: symbol prop defined but not used - chart is data-driven from parent's data prop\n    // Parent (DashboardClient) handles all data fetching via api.history()\n    // Backend already fetches the correct range, so we use sourceData directly\n    const sourceData = data || [];\n    const TARGET_PER_RANGE = {\n        \"1d\": 18,\n        \"1w\": 40,\n        \"1m\": 70,\n        \"3m\": 90,\n        \"1y\": 140,\n        \"5y\": 220\n    };\n    const target = TARGET_PER_RANGE[range] || 120;\n    let bucketSize = sourceData.length > target ? Math.ceil(sourceData.length / target) : 1;\n    if (range === \"1d\") bucketSize = 1; // never bucket intraday so ticks align with real times\n    // Calculate indicators on RAW sourceData BEFORE bucketing for maximum accuracy\n    const rawEma20 = showEMA20 ? ema(sourceData.map((d)=>d.c), 20) : [];\n    const rawVolMA = showVolMA ? sma(sourceData.map((d)=>d.v), 20) : [];\n    const rawBollingerBands = showBollingerBands ? calculateBollingerBands(sourceData.map((d)=>d.c)) : {\n        upper: [],\n        lower: [],\n        middle: []\n    };\n    function bucketAggregate(src, size) {\n        if (size <= 1) return src;\n        const out = [];\n        for(let i = 0; i < src.length; i += size){\n            const slice = src.slice(i, i + size);\n            if (!slice.length) continue;\n            const o = slice[0].o;\n            const c = slice[slice.length - 1].c;\n            let h = -Infinity, l = Infinity, v = 0;\n            for (const s of slice){\n                if (s.h > h) h = s.h;\n                if (s.l < l) l = s.l;\n                v += s.v;\n            }\n            out.push({\n                t: slice[0].t,\n                o,\n                h,\n                l,\n                c,\n                v\n            });\n        }\n        return out;\n    }\n    // Bucket indicators alongside the data (take every Nth value to match bucketing)\n    function bucketIndicator(values, size) {\n        if (size <= 1) return values;\n        const out = [];\n        for(let i = 0; i < values.length; i += size){\n            out.push(values[i]); // Take the first value of each bucket\n        }\n        return out;\n    }\n    const baseData = bucketSize === 1 ? sourceData : bucketAggregate(sourceData, bucketSize);\n    const bucketedEma20 = bucketSize === 1 ? rawEma20 : bucketIndicator(rawEma20, bucketSize);\n    const bucketedVolMA = bucketSize === 1 ? rawVolMA : bucketIndicator(rawVolMA, bucketSize);\n    const bucketedBollingerBands = bucketSize === 1 ? rawBollingerBands : {\n        upper: bucketIndicator(rawBollingerBands.upper, bucketSize),\n        lower: bucketIndicator(rawBollingerBands.lower, bucketSize),\n        middle: bucketIndicator(rawBollingerBands.middle, bucketSize)\n    };\n    // Backend fetches extra candles for indicator calculation (20-50 depending on range)\n    // After bucketing, we hide proportionally fewer candles\n    const bufferPerRange = {\n        \"1d\": 50,\n        \"1w\": 50,\n        \"1m\": 50,\n        \"3m\": 50,\n        \"1y\": 50,\n        \"5y\": 50\n    };\n    const bufferCandles = Math.min(bufferPerRange[range], Math.floor(baseData.length * 0.2));\n    const displayData = baseData.slice(bufferCandles); // Hide first candles from user\n    const [windowIdx, setWindowIdx] = react__WEBPACK_IMPORTED_MODULE_1___default().useState(()=>[\n            0,\n            displayData.length - 1\n        ]);\n    // Reset window when displayData length changes (range change or new data)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setWindowIdx([\n            0,\n            displayData.length - 1\n        ]);\n    }, [\n        displayData.length\n    ]);\n    // Always show full range unless user zooms/pans (windowIdx acts as user override after first wheel/drag)\n    const [wStart, wEnd] = windowIdx;\n    const fullStart = 0;\n    const fullEnd = displayData.length - 1;\n    const effectiveStart = wStart === 0 && wEnd === displayData.length - 1 ? fullStart : Math.max(0, Math.min(wStart, fullEnd));\n    const effectiveEnd = wStart === 0 && wEnd === displayData.length - 1 ? fullEnd : Math.min(wEnd, fullEnd);\n    const safeEnd = Math.min(effectiveEnd, displayData.length - 1);\n    const safeStart = Math.max(0, Math.min(effectiveStart, safeEnd - 5));\n    const drawData = displayData.slice(safeStart, safeEnd + 1);\n    // Slice pre-calculated indicators to match drawData (offset by buffer + window)\n    const indicatorStart = bufferCandles + safeStart;\n    const indicatorEnd = bufferCandles + safeEnd + 1;\n    const ema20 = bucketedEma20.slice(indicatorStart, indicatorEnd);\n    const volMA = bucketedVolMA.slice(indicatorStart, indicatorEnd);\n    const bollingerBands = {\n        upper: bucketedBollingerBands.upper.slice(indicatorStart, indicatorEnd),\n        lower: bucketedBollingerBands.lower.slice(indicatorStart, indicatorEnd),\n        middle: bucketedBollingerBands.middle.slice(indicatorStart, indicatorEnd)\n    };\n    const closes = drawData.map((d)=>d.c), highs = drawData.map((d)=>d.h), lows = drawData.map((d)=>d.l);\n    function quantile(arr, q) {\n        if (!arr.length) return 0;\n        const sorted = [\n            ...arr\n        ].sort((a, b)=>a - b);\n        const pos = (sorted.length - 1) * q;\n        const base = Math.floor(pos);\n        const rest = pos - base;\n        return sorted[base + 1] !== undefined ? sorted[base] + rest * (sorted[base + 1] - sorted[base]) : sorted[base];\n    }\n    let min = quantile(lows, 0.005), max = quantile(highs, 0.995);\n    const lastC = drawData[drawData.length - 1];\n    if (lastC) {\n        if (lastC.l < min) min = lastC.l;\n        if (lastC.h > max) max = lastC.h;\n    }\n    const span = max - min || 1;\n    // Single scale variable\n    const S = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.CHART_SCALE; // affects vertical real estate\n    const hVisualBase = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.GRAPH_HEIGHT; // baseline visual height from config\n    const volumePortion = 0.23; // fraction reserved for volume area\n    const hVisual = hVisualBase * S;\n    const volH = hVisual * volumePortion;\n    const priceH = hVisual - volH;\n    const axisFooter = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_FOOTER_HEIGHT;\n    const h = hVisual + axisFooter;\n    const w = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.GRAPH_WIDTH;\n    const gutterRight = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_RIGHT_GUTTER;\n    const padTop = 8, padBottom = 6, padLeft = 4;\n    const priceArea = priceH - padTop - padBottom;\n    const up = closes[closes.length - 1] >= closes[0];\n    const priceW = w - gutterRight - padLeft;\n    // Index-based horizontal scale (removes time gaps for continuous display)\n    const numCandles = drawData.length;\n    function xForIdx(idx) {\n        return padLeft + idx / Math.max(1, numCandles - 1) * priceW;\n    }\n    // Store timestamps for labels\n    const drawTimes = drawData.map((d)=>new Date(d.t).getTime());\n    // Adaptive candle width from data density\n    let candleWidth;\n    if (numCandles <= 2) {\n        candleWidth = priceW / Math.max(1, numCandles) * 0.6;\n    } else {\n        candleWidth = priceW / numCandles * 0.8;\n    }\n    if (candleWidth < 3) candleWidth = 3;\n    if (candleWidth > 22) candleWidth = 22;\n    const linePts = drawData.map((d, idx)=>{\n        const x = xForIdx(idx);\n        const val = logScale ? (Math.log10(d.c) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (d.c - min) / span;\n        const y = padTop + (priceArea - val * priceArea);\n        return \"\".concat(x, \",\").concat(y);\n    }).join(\" \");\n    const hoverPoint = hover != null ? drawData[hover] : null;\n    function onMove(e) {\n        const rect = e.currentTarget.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        // Index-based hover: find nearest candle by x position\n        if (drawData.length === 0) return;\n        const xRatio = Math.max(0, Math.min(1, (x - padLeft) / (rect.width - gutterRight / w * rect.width)));\n        const idx = Math.round(xRatio * (numCandles - 1));\n        setHover(Math.max(0, Math.min(numCandles - 1, idx)));\n    }\n    const dragState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    function onWheel(e) {\n        e.preventDefault();\n        if (drawData.length < 10) return;\n        const delta = e.deltaY;\n        const factor = delta > 0 ? 1.1 : 0.9;\n        const currentLen = wEnd - wStart + 1;\n        const newLen = Math.max(20, Math.min(displayData.length, Math.round(currentLen * factor)));\n        const rect = e.currentTarget.getBoundingClientRect();\n        const xRatio = (e.clientX - rect.left - padLeft) / (rect.width - gutterRight);\n        const focusIdx = wStart + Math.round(currentLen * xRatio);\n        let newStart = focusIdx - Math.round(newLen * xRatio);\n        let newEnd = newStart + newLen - 1;\n        if (newStart < 0) {\n            newStart = 0;\n            newEnd = newLen - 1;\n        }\n        if (newEnd > displayData.length - 1) {\n            newEnd = displayData.length - 1;\n            newStart = newEnd - newLen + 1;\n        }\n        setWindowIdx([\n            newStart,\n            newEnd\n        ]);\n    }\n    function onPointerDown(e) {\n        e.currentTarget.setPointerCapture(e.pointerId);\n        dragState.current = {\n            startX: e.clientX,\n            startRange: windowIdx\n        };\n    }\n    function onPointerMove(e) {\n        if (!dragState.current) return;\n        const [s, eIdx] = dragState.current.startRange;\n        const len = eIdx - s + 1;\n        const pixelPerCandle = priceW / drawData.length;\n        const deltaPx = e.clientX - dragState.current.startX;\n        const shift = Math.round(-deltaPx / pixelPerCandle);\n        let newStart = s + shift;\n        let newEnd = newStart + len - 1;\n        if (newStart < 0) {\n            newStart = 0;\n            newEnd = len - 1;\n        }\n        if (newEnd > displayData.length - 1) {\n            newEnd = displayData.length - 1;\n            newStart = newEnd - len + 1;\n        }\n        setWindowIdx([\n            newStart,\n            newEnd\n        ]);\n    }\n    function onPointerUp() {\n        dragState.current = null;\n    }\n    function niceTicks(low, high) {\n        let target = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5;\n        const rawSpan = high - low || 1;\n        const roughStep = rawSpan / (target - 1);\n        const pow10 = Math.pow(10, Math.floor(Math.log10(roughStep)));\n        const multiples = [\n            1,\n            2,\n            2.5,\n            5,\n            10\n        ];\n        const found = multiples.find((m)=>m * pow10 >= roughStep) || multiples[multiples.length - 1];\n        const step = found * pow10;\n        const first = Math.ceil(low / step) * step;\n        const ticks = [];\n        for(let v = first; v <= high; v += step)ticks.push(v);\n        return ticks;\n    }\n    // Time ticks per explicit spec\n    const timeTicks = [];\n    if (drawData.length > 1) {\n        if (range === \"1d\") {\n            // Show label every hour for cleaner display\n            const seen = new Set();\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                const hh = d.getHours();\n                const mm = d.getMinutes();\n                // Show label every hour on the hour\n                if (mm === 0) {\n                    const timeKey = \"\".concat(hh, \":00\");\n                    if (!seen.has(timeKey)) {\n                        seen.add(timeKey);\n                        timeTicks.push({\n                            x: xForIdx(idx),\n                            label: d.toLocaleTimeString(\"en-US\", {\n                                hour: \"numeric\",\n                                minute: \"2-digit\",\n                                hour12: false\n                            })\n                        });\n                    }\n                }\n            });\n        } else if (range === \"1w\") {\n            const seen = new Set();\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                const k = d.toDateString();\n                if (!seen.has(k)) {\n                    seen.add(k);\n                    timeTicks.push({\n                        x: xForIdx(idx),\n                        label: d.toLocaleDateString(undefined, {\n                            weekday: \"short\"\n                        }).toUpperCase()\n                    });\n                }\n            });\n        } else if (range === \"1m\") {\n            const seen = new Set();\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                if (d.getDay() === 1) {\n                    const key = d.getFullYear() + \"-\" + d.getMonth() + \"-\" + d.getDate();\n                    if (!seen.has(key)) {\n                        seen.add(key);\n                        timeTicks.push({\n                            x: xForIdx(idx),\n                            label: d.getMonth() + 1 + \"/\" + d.getDate()\n                        });\n                    }\n                }\n            });\n        } else if (range === \"3m\") {\n            let mondayCount = 0;\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                if (d.getDay() === 1) {\n                    if (mondayCount % 3 === 0) timeTicks.push({\n                        x: xForIdx(idx),\n                        label: d.getMonth() + 1 + \"/\" + d.getDate()\n                    });\n                    mondayCount++;\n                }\n            });\n        } else if (range === \"1y\") {\n            const seenMonth = new Set();\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                const mk = d.getFullYear() + \"-\" + d.getMonth();\n                if (!seenMonth.has(mk) && d.getDate() <= 7) {\n                    seenMonth.add(mk);\n                    timeTicks.push({\n                        x: xForIdx(idx),\n                        label: d.toLocaleString(undefined, {\n                            month: \"short\"\n                        }).toUpperCase()\n                    });\n                }\n            });\n        } else if (range === \"5y\") {\n            const seenYear = new Set();\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                if (!seenYear.has(d.getFullYear()) && d.getMonth() < 2) {\n                    seenYear.add(d.getFullYear());\n                    timeTicks.push({\n                        x: xForIdx(idx),\n                        label: String(d.getFullYear())\n                    });\n                }\n            });\n        }\n    }\n    const maxVol = Math.max(...drawData.map((d)=>d.v), 1);\n    const magnitude = Math.abs(max);\n    const decimals = magnitude >= 500 ? 0 : magnitude >= 100 ? 1 : 2;\n    function sma(src, period) {\n        if (src.length < period) return [];\n        const out = new Array(period - 1).fill(null); // Pad beginning with nulls\n        let sum = 0;\n        for(let i = 0; i < src.length; i++){\n            sum += src[i];\n            if (i >= period) sum -= src[i - period];\n            if (i >= period - 1) out.push(sum / period);\n        }\n        return out;\n    }\n    function ema(src, period) {\n        if (src.length < period) return [];\n        const k = 2 / (period + 1);\n        const out = new Array(period - 1).fill(null); // Pad beginning with nulls\n        // Start with SMA for first value\n        let sum = 0;\n        for(let i = 0; i < period; i++){\n            sum += src[i];\n        }\n        out.push(sum / period);\n        // Then use EMA formula\n        for(let i = period; i < src.length; i++){\n            out.push(src[i] * k + out[out.length - 1] * (1 - k));\n        }\n        return out;\n    }\n    function calculateBollingerBands(closes) {\n        let period = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20, stdDevMultiplier = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n        if (closes.length < period) return {\n            upper: [],\n            lower: [],\n            middle: []\n        };\n        const middle = new Array(period - 1).fill(null);\n        const upper = new Array(period - 1).fill(null);\n        const lower = new Array(period - 1).fill(null);\n        for(let i = period - 1; i < closes.length; i++){\n            const slice = closes.slice(i - period + 1, i + 1);\n            const avg = slice.reduce((sum, val)=>sum + val, 0) / period;\n            const variance = slice.reduce((sum, val)=>sum + Math.pow(val - avg, 2), 0) / period;\n            const stdDev = Math.sqrt(variance);\n            middle.push(avg);\n            upper.push(avg + stdDevMultiplier * stdDev);\n            lower.push(avg - stdDevMultiplier * stdDev);\n        }\n        return {\n            upper,\n            lower,\n            middle\n        };\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            position: \"absolute\",\n            inset: 0,\n            fontSize: 11\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                viewBox: \"0 0 \".concat(w, \" \").concat(h),\n                preserveAspectRatio: \"none\",\n                style: {\n                    width: \"100%\",\n                    height: \"100%\",\n                    cursor: \"crosshair\",\n                    userSelect: \"none\",\n                    fontFamily: \"system-ui, ui-monospace, Menlo, monospace\"\n                },\n                onMouseMove: onMove,\n                onMouseLeave: ()=>setHover(null),\n                onWheel: onWheel,\n                onPointerDown: onPointerDown,\n                onPointerMove: onPointerMove,\n                onPointerUp: onPointerUp,\n                children: [\n                    niceTicks(min, max, 5).map((t)=>{\n                        const y = 8 + (priceArea - (t - min) / span * priceArea);\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                    x1: padLeft,\n                                    x2: padLeft + priceW,\n                                    y1: y,\n                                    y2: y,\n                                    stroke: theme === \"light\" ? \"#d0d7de\" : \"#30363d\",\n                                    strokeWidth: 1\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 392,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                                    x: padLeft + priceW + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_Y_LABEL_X_OFFSET,\n                                    y: y + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_Y_FONT_SIZE / 3,\n                                    fill: theme === \"light\" ? \"#000000\" : \"#ffffff\",\n                                    fontSize: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_Y_FONT_SIZE,\n                                    children: t.toFixed(decimals)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 400,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, t.toFixed(6), true, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 391,\n                            columnNumber: 13\n                        }, this);\n                    }),\n                    timeTicks.map((t, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                            x1: t.x,\n                            x2: t.x,\n                            y1: 0,\n                            y2: hVisual,\n                            stroke: theme === \"light\" ? \"#d0d7de\" : \"#30363d\",\n                            strokeWidth: 1\n                        }, \"xtick-\" + i, false, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 414,\n                            columnNumber: 11\n                        }, this)),\n                    showBollingerBands && bollingerBands.upper.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polygon\", {\n                                points: (()=>{\n                                    const points = [];\n                                    // Upper band\n                                    for(let i = 0; i < bollingerBands.upper.length; i++){\n                                        const upperVal = bollingerBands.upper[i];\n                                        if (upperVal === null) continue;\n                                        const x = xForIdx(i);\n                                        const val = (upperVal - min) / span;\n                                        const y = padTop + (priceArea - val * priceArea);\n                                        if (isFinite(x) && isFinite(y)) {\n                                            points.push(\"\".concat(x, \",\").concat(y));\n                                        }\n                                    }\n                                    // Lower band (reversed)\n                                    for(let i = bollingerBands.lower.length - 1; i >= 0; i--){\n                                        const lowerVal = bollingerBands.lower[i];\n                                        if (lowerVal === null) continue;\n                                        const x = xForIdx(i);\n                                        const val = (lowerVal - min) / span;\n                                        const y = padTop + (priceArea - val * priceArea);\n                                        if (isFinite(x) && isFinite(y)) {\n                                            points.push(\"\".concat(x, \",\").concat(y));\n                                        }\n                                    }\n                                    return points.join(\" \");\n                                })(),\n                                fill: \"rgba(135, 206, 235, 0.15)\",\n                                stroke: \"none\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                lineNumber: 429,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polyline\", {\n                                points: bollingerBands.upper.map((v, i)=>{\n                                    if (v === null) return null;\n                                    const x = xForIdx(i);\n                                    const val = (v - min) / span;\n                                    const y = padTop + (priceArea - val * priceArea);\n                                    return \"\".concat(x, \",\").concat(y);\n                                }).filter((p)=>p !== null).join(\" \"),\n                                fill: \"none\",\n                                stroke: \"rgba(135, 206, 235, 0.8)\",\n                                strokeWidth: 1,\n                                vectorEffect: \"non-scaling-stroke\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                lineNumber: 461,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polyline\", {\n                                points: bollingerBands.lower.map((v, i)=>{\n                                    if (v === null) return null;\n                                    const x = xForIdx(i);\n                                    const val = (v - min) / span;\n                                    const y = padTop + (priceArea - val * priceArea);\n                                    return \"\".concat(x, \",\").concat(y);\n                                }).filter((p)=>p !== null).join(\" \"),\n                                fill: \"none\",\n                                stroke: \"rgba(135, 206, 235, 0.8)\",\n                                strokeWidth: 1,\n                                vectorEffect: \"non-scaling-stroke\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                lineNumber: 479,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true),\n                    mode === \"line\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polyline\", {\n                        points: linePts,\n                        fill: \"none\",\n                        stroke: up ? \"var(--color-success)\" : \"var(--color-danger)\",\n                        strokeWidth: 2,\n                        vectorEffect: \"non-scaling-stroke\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                        lineNumber: 498,\n                        columnNumber: 11\n                    }, this),\n                    mode === \"candles\" && drawData.map((d, idx)=>{\n                        const centerX = xForIdx(idx);\n                        const x = centerX - candleWidth / 2;\n                        const valOpen = logScale ? (Math.log10(d.o) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (d.o - min) / span;\n                        const valClose = logScale ? (Math.log10(d.c) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (d.c - min) / span;\n                        const valHigh = logScale ? (Math.log10(d.h) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (d.h - min) / span;\n                        const valLow = logScale ? (Math.log10(d.l) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (d.l - min) / span;\n                        const openY = 8 + (priceArea - valOpen * priceArea);\n                        const closeY = 8 + (priceArea - valClose * priceArea);\n                        const highY = 8 + (priceArea - valHigh * priceArea);\n                        const lowY = 8 + (priceArea - valLow * priceArea);\n                        const rising = d.c >= d.o;\n                        const pct = Math.min(0.05, Math.max(-0.05, (d.c - d.o) / d.o));\n                        const intensity = Math.abs(pct) / 0.05;\n                        const baseColor = rising ? \"var(--color-success)\" : \"var(--color-danger)\";\n                        const fill = rising ? \"rgba(35,134,54,\".concat(0.35 + 0.55 * intensity, \")\") : \"rgba(248,81,73,\".concat(0.35 + 0.55 * intensity, \")\");\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                    x1: x + candleWidth / 2,\n                                    x2: x + candleWidth / 2,\n                                    y1: highY,\n                                    y2: lowY,\n                                    stroke: baseColor,\n                                    strokeWidth: 1\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 535,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                                    x: x,\n                                    y: Math.min(openY, closeY),\n                                    width: candleWidth,\n                                    height: Math.max(2, Math.abs(closeY - openY)),\n                                    fill: fill,\n                                    stroke: baseColor,\n                                    strokeWidth: 0.5\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 543,\n                                    columnNumber: 17\n                                }, this)\n                            ]\n                        }, d.t, true, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 534,\n                            columnNumber: 15\n                        }, this);\n                    }),\n                    showEMA20 && ema20.length && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polyline\", {\n                        points: ema20.map((v, i)=>{\n                            if (v === null) return null;\n                            const x = xForIdx(i);\n                            const val = logScale ? (Math.log10(v) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (v - min) / span;\n                            const y = 8 + (priceArea - val * priceArea);\n                            return \"\".concat(x, \",\").concat(y);\n                        }).filter((p)=>p !== null).join(\" \"),\n                        fill: \"none\",\n                        stroke: \"#ff9500\",\n                        strokeWidth: 1.4,\n                        vectorEffect: \"non-scaling-stroke\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                        lineNumber: 558,\n                        columnNumber: 11\n                    }, this),\n                    drawData.map((d, idx)=>{\n                        const centerX = xForIdx(idx);\n                        const x = centerX - candleWidth / 2;\n                        const volRatio = d.v / maxVol;\n                        let barH = volRatio * (volH - 16);\n                        // Minimum bar height for visibility (especially for low after-hours volume)\n                        const minBarHeight = 2;\n                        if (barH > 0 && barH < minBarHeight) barH = minBarHeight;\n                        const y = priceH + (volH - barH);\n                        const rising = d.c >= d.o;\n                        // Check if this is extended hours (before 9:30 or after 16:00 ET)\n                        const candleDate = new Date(d.t);\n                        const hour = candleDate.getHours();\n                        const minute = candleDate.getMinutes();\n                        const timeInMinutes = hour * 60 + minute;\n                        const marketOpen = 9 * 60 + 30; // 9:30 AM\n                        const marketClose = 16 * 60; // 4:00 PM\n                        const isExtendedHours = timeInMinutes < marketOpen || timeInMinutes >= marketClose;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                            x: x,\n                            y: y,\n                            width: candleWidth,\n                            height: barH,\n                            fill: rising ? \"var(--color-success)\" : \"var(--color-danger)\",\n                            opacity: isExtendedHours ? 0.2 : 0.35\n                        }, d.t + \":vol\", false, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 601,\n                            columnNumber: 13\n                        }, this);\n                    }),\n                    showVolMA && volMA.length && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polyline\", {\n                        points: volMA.map((v, i)=>{\n                            if (v === null) return null;\n                            const x = xForIdx(i);\n                            const ratio = v / maxVol;\n                            const barH = ratio * (volH - 16);\n                            const y = priceH + (volH - barH);\n                            return \"\".concat(x, \",\").concat(y);\n                        }).filter((p)=>p !== null).join(\" \"),\n                        fill: \"none\",\n                        stroke: \"#58a6ff\",\n                        strokeWidth: 1,\n                        vectorEffect: \"non-scaling-stroke\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                        lineNumber: 613,\n                        columnNumber: 11\n                    }, this),\n                    hoverPoint && (()=>{\n                        const x = xForIdx(hover);\n                        const y = 8 + (priceArea - (hoverPoint.c - min) / span * priceArea);\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                    x1: x,\n                                    x2: x,\n                                    y1: 0,\n                                    y2: priceH,\n                                    stroke: theme === \"light\" ? \"#656d76\" : \"#7d8590\",\n                                    strokeDasharray: \"4 3\",\n                                    strokeWidth: 1\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 637,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                    x1: 0,\n                                    x2: w,\n                                    y1: y,\n                                    y2: y,\n                                    stroke: theme === \"light\" ? \"#656d76\" : \"#7d8590\",\n                                    strokeDasharray: \"4 3\",\n                                    strokeWidth: 1\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 646,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    cx: x,\n                                    cy: y,\n                                    r: 5,\n                                    fill: \"var(--color-bg)\",\n                                    stroke: up ? \"var(--color-success)\" : \"var(--color-danger)\",\n                                    strokeWidth: 2\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 655,\n                                    columnNumber: 17\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 636,\n                            columnNumber: 15\n                        }, this);\n                    })(),\n                    drawData.length > 0 && (()=>{\n                        const last = drawData[drawData.length - 1];\n                        const y = 8 + (priceArea - (last.c - min) / span * priceArea);\n                        const isUp = last.c >= closes[0];\n                        // Brighter, higher contrast colors for last price label\n                        const brightGreen = \"#00ff41\"; // Bright neon green\n                        const brightRed = \"#ff3366\"; // Bright red\n                        const color = isUp ? brightGreen : brightRed;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                    x1: padLeft,\n                                    x2: padLeft + priceW,\n                                    y1: y,\n                                    y2: y,\n                                    stroke: color,\n                                    strokeDasharray: \"2 4\",\n                                    strokeWidth: 1\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 678,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                                    x: padLeft + priceW + 4,\n                                    y: y - _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_HEIGHT / 2,\n                                    width: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_WIDTH,\n                                    height: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_HEIGHT,\n                                    fill: isUp ? theme === \"light\" ? \"#e6fff0\" : \"#002211\" : theme === \"light\" ? \"#ffe6ee\" : \"#2d0011\",\n                                    stroke: color,\n                                    rx: 3\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 687,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                                    x: padLeft + priceW + 4 + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_WIDTH / 2,\n                                    y: y + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_FONT_SIZE / 3,\n                                    textAnchor: \"middle\",\n                                    fill: color,\n                                    fontSize: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_FONT_SIZE,\n                                    fontWeight: 600,\n                                    children: last.c.toFixed(decimals)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 698,\n                                    columnNumber: 17\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 677,\n                            columnNumber: 15\n                        }, this);\n                    })(),\n                    (()=>{\n                        var _drawData_;\n                        const labels = [];\n                        // Main price position\n                        const lastPrice = ((_drawData_ = drawData[drawData.length - 1]) === null || _drawData_ === void 0 ? void 0 : _drawData_.c) || 0;\n                        const priceY = 8 + (priceArea - (lastPrice - min) / span * priceArea);\n                        // EMA20\n                        if (showEMA20 && ema20.length > 0) {\n                            const lastEma = ema20[ema20.length - 1];\n                            if (lastEma !== null) {\n                                labels.push({\n                                    y: 8 + (priceArea - (lastEma - min) / span * priceArea),\n                                    value: lastEma,\n                                    color: \"#ff9500\",\n                                    bgColor: theme === \"light\" ? \"#fff5e6\" : \"#2d2400\",\n                                    stroke: \"#ff9500\"\n                                });\n                            }\n                        }\n                        // Bollinger Bands Upper\n                        if (showBollingerBands && bollingerBands.upper.length > 0) {\n                            const lastUpper = bollingerBands.upper[bollingerBands.upper.length - 1];\n                            if (lastUpper !== null) {\n                                labels.push({\n                                    y: 8 + (priceArea - (lastUpper - min) / span * priceArea),\n                                    value: lastUpper,\n                                    color: \"rgba(135, 206, 235, 1)\",\n                                    bgColor: theme === \"light\" ? \"#e6f7ff\" : \"#001a2d\",\n                                    stroke: \"rgba(135, 206, 235, 0.8)\"\n                                });\n                            }\n                        }\n                        // Bollinger Bands Lower\n                        if (showBollingerBands && bollingerBands.lower.length > 0) {\n                            const lastLower = bollingerBands.lower[bollingerBands.lower.length - 1];\n                            if (lastLower !== null) {\n                                labels.push({\n                                    y: 8 + (priceArea - (lastLower - min) / span * priceArea),\n                                    value: lastLower,\n                                    color: \"rgba(135, 206, 235, 1)\",\n                                    bgColor: theme === \"light\" ? \"#e6f7ff\" : \"#001a2d\",\n                                    stroke: \"rgba(135, 206, 235, 0.8)\"\n                                });\n                            }\n                        }\n                        // Adjust positions to avoid overlaps\n                        const minGap = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_HEIGHT + 2;\n                        const adjustedLabels = labels.map((label)=>{\n                            let adjustedY = label.y;\n                            // Check overlap with main price label\n                            if (Math.abs(adjustedY - priceY) < minGap) {\n                                // Move above or below based on which side has more space\n                                if (adjustedY < priceY) {\n                                    // Label is above price, move it further up\n                                    adjustedY = priceY - minGap;\n                                } else {\n                                    // Label is below price, move it further down\n                                    adjustedY = priceY + minGap;\n                                }\n                            }\n                            return {\n                                ...label,\n                                y: adjustedY\n                            };\n                        });\n                        // Sort by Y position and adjust for overlaps between indicators\n                        adjustedLabels.sort((a, b)=>a.y - b.y);\n                        for(let i = 1; i < adjustedLabels.length; i++){\n                            if (adjustedLabels[i].y - adjustedLabels[i - 1].y < minGap) {\n                                adjustedLabels[i].y = adjustedLabels[i - 1].y + minGap;\n                            }\n                        }\n                        return adjustedLabels.map((label, idx)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                                        x: padLeft + priceW + 4,\n                                        y: label.y - _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_HEIGHT / 2,\n                                        width: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_WIDTH,\n                                        height: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_HEIGHT,\n                                        fill: label.bgColor,\n                                        stroke: label.stroke,\n                                        rx: 2\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                        lineNumber: 792,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                                        x: padLeft + priceW + 4 + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_WIDTH / 2,\n                                        y: label.y + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_FONT_SIZE / 3,\n                                        textAnchor: \"middle\",\n                                        fill: label.color,\n                                        fontSize: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_FONT_SIZE,\n                                        fontWeight: 600,\n                                        children: label.value.toFixed(decimals)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                        lineNumber: 801,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, \"indicator-label-\".concat(idx), true, {\n                                fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                lineNumber: 791,\n                                columnNumber: 13\n                            }, this));\n                    })(),\n                    timeTicks.map((t, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                            x: t.x,\n                            y: h - 6,\n                            textAnchor: \"middle\",\n                            fontSize: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_X_FONT_SIZE,\n                            fill: theme === \"light\" ? \"#000000\" : \"#ffffff\",\n                            children: t.label\n                        }, \"xlabel-\" + i, false, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 816,\n                            columnNumber: 11\n                        }, this))\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                lineNumber: 371,\n                columnNumber: 7\n            }, this),\n            hoverPoint && (()=>{\n                const hoverX = xForIdx(hover);\n                const hoverXPercent = (hoverX - padLeft) / priceW * 100;\n                // Flip tooltip to left side if hovering near right edge (> 75%)\n                const flipLeft = hoverXPercent > 75;\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        position: \"absolute\",\n                        left: flipLeft ? undefined : \"\".concat(hoverXPercent, \"%\"),\n                        right: flipLeft ? \"\".concat(100 - hoverXPercent, \"%\") : undefined,\n                        top: 8,\n                        background: theme === \"light\" ? \"rgba(255,255,255,0.95)\" : \"rgba(0,0,0,0.78)\",\n                        padding: \"6px 8px\",\n                        borderRadius: 4,\n                        pointerEvents: \"none\",\n                        border: theme === \"light\" ? \"1px solid #d0d7de\" : \"1px solid #30363d\",\n                        whiteSpace: \"nowrap\",\n                        backdropFilter: \"blur(2px)\",\n                        color: theme === \"light\" ? \"#24292f\" : \"#e6edf3\",\n                        transform: flipLeft ? \"translateX(100%)\" : \"translateX(-50%)\"\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontSize: 11,\n                                opacity: 0.7\n                            },\n                            children: new Date(hoverPoint.t).toLocaleString()\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 852,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: 600\n                            },\n                            children: hoverPoint.c.toFixed(2)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 855,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                    lineNumber: 835,\n                    columnNumber: 11\n                }, this);\n            })()\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n        lineNumber: 370,\n        columnNumber: 5\n    }, this);\n}\n_s(AdvancedPriceChart, \"lHy/StbT2zLTwfx1ruRUmtw45WE=\", false, function() {\n    return [\n        _auth_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth\n    ];\n});\n_c = AdvancedPriceChart;\nvar _c;\n$RefreshReg$(_c, \"AdvancedPriceChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Rhc2hib2FyZC9BZHZhbmNlZFByaWNlQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQ2lEO0FBRUg7QUFDUTtBQXFCdkMsU0FBU0ssbUJBQW1CLEtBU25DO1FBVG1DLEVBQ3pDQyxJQUFJLEVBQ0pDLElBQUksRUFDSkMsS0FBSyxFQUNMQyxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMscUJBQXFCLEtBQUssRUFDMUJDLFlBQVksS0FBSyxFQUNqQkMsTUFBTSxFQUNBLEdBVG1DOztJQVV6QyxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHVixrRUFBT0E7SUFDekIsTUFBTSxDQUFDVyxPQUFPQyxTQUFTLEdBQUdoQixxREFBYyxDQUFnQjtJQUV4RCx3RkFBd0Y7SUFDeEYsdUVBQXVFO0lBQ3ZFLDJFQUEyRTtJQUUzRSxNQUFNa0IsYUFBdUJaLFFBQVEsRUFBRTtJQUV2QyxNQUFNYSxtQkFBNkM7UUFDakQsTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO1FBQ04sTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO0lBQ1I7SUFDQSxNQUFNQyxTQUFTRCxnQkFBZ0IsQ0FBQ1gsTUFBTSxJQUFJO0lBQzFDLElBQUlhLGFBQWFILFdBQVdJLE1BQU0sR0FBR0YsU0FBU0csS0FBS0MsSUFBSSxDQUFDTixXQUFXSSxNQUFNLEdBQUdGLFVBQVU7SUFDdEYsSUFBSVosVUFBVSxNQUFNYSxhQUFhLEdBQUcsdURBQXVEO0lBRTNGLCtFQUErRTtJQUMvRSxNQUFNSSxXQUFXYixZQUFZYyxJQUFJUixXQUFXUyxHQUFHLENBQUMsQ0FBQ0MsSUFBY0EsRUFBRUMsQ0FBQyxHQUFHLE1BQU0sRUFBRTtJQUM3RSxNQUFNQyxXQUFXcEIsWUFBWXFCLElBQUliLFdBQVdTLEdBQUcsQ0FBQyxDQUFDQyxJQUFjQSxFQUFFSSxDQUFDLEdBQUcsTUFBTSxFQUFFO0lBQzdFLE1BQU1DLG9CQUFvQnRCLHFCQUN0QnVCLHdCQUF3QmhC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T0FBTSxJQUFLRyxTQUFVO2dCQUN0RCxnRUFBZ0U7Z0JBQ2hFLE1BQU15TSxXQUFXRCxnQkFBZ0I7Z0JBRWpDLHFCQUNFLDhEQUFDMUY7b0JBQ0NDLE9BQU87d0JBQ0xDLFVBQVU7d0JBQ1YzRixNQUFNb0wsV0FBVy9OLFlBQVksR0FBaUIsT0FBZDhOLGVBQWM7d0JBQzlDRSxPQUFPRCxXQUFXLEdBQXVCLE9BQXBCLE1BQU1ELGVBQWMsT0FBSzlOO3dCQUM5Q2lPLEtBQUs7d0JBQ0xDLFlBQVloVCxVQUFVLFVBQVUsMkJBQTJCO3dCQUMzRGlULFNBQVM7d0JBQ1RDLGNBQWM7d0JBQ2RDLGVBQWU7d0JBQ2ZDLFFBQVFwVCxVQUFVLFVBQVUsc0JBQXNCO3dCQUNsRHFULFlBQVk7d0JBQ1pDLGdCQUFnQjt3QkFDaEJqQyxPQUFPclIsVUFBVSxVQUFVLFlBQVk7d0JBQ3ZDdVQsV0FBV1YsV0FBVyxxQkFBcUI7b0JBQzdDOztzQ0FFQSw4REFBQzNGOzRCQUFJQyxPQUFPO2dDQUFFRyxVQUFVO2dDQUFJb0QsU0FBUzs0QkFBSTtzQ0FDdEMsSUFBSWpLLEtBQUtTLFdBQVc5RSxDQUFDLEVBQUU0SixjQUFjOzs7Ozs7c0NBRXhDLDhEQUFDa0I7NEJBQUlDLE9BQU87Z0NBQUV3RSxZQUFZOzRCQUFJO3NDQUFJekssV0FBV25HLENBQUMsQ0FBQzROLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7O1lBRzdEOzs7Ozs7O0FBR047R0FuMEJ3QnBQOztRQVVKRCw4REFBT0E7OztLQVZIQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9kYXNoYm9hcmQvQWR2YW5jZWRQcmljZUNoYXJ0LnRzeD9jZTdiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgUmFuZ2VLZXkgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcclxuaW1wb3J0IHsgTGF5b3V0Q29uZmlnIH0gZnJvbSBcIi4vbGF5b3V0Q29uZmlnXCI7XHJcbmltcG9ydCB7IHVzZUF1dGggfSBmcm9tIFwiLi4vYXV0aC1jb250ZXh0L0F1dGhDb250ZXh0XCI7XHJcblxyXG5pbnRlcmZhY2UgQ2FuZGxlIHtcclxuICB0OiBzdHJpbmc7XHJcbiAgbzogbnVtYmVyO1xyXG4gIGg6IG51bWJlcjtcclxuICBsOiBudW1iZXI7XHJcbiAgYzogbnVtYmVyO1xyXG4gIHY6IG51bWJlcjtcclxufVxyXG5pbnRlcmZhY2UgUHJvcHMge1xyXG4gIGRhdGE6IENhbmRsZVtdO1xyXG4gIG1vZGU6IFwibGluZVwiIHwgXCJjYW5kbGVzXCI7XHJcbiAgcmFuZ2U6IFJhbmdlS2V5O1xyXG4gIGxvZ1NjYWxlOiBib29sZWFuO1xyXG4gIHNob3dWb2xNQTogYm9vbGVhbjtcclxuICBzaG93Qm9sbGluZ2VyQmFuZHM/OiBib29sZWFuO1xyXG4gIHNob3dFTUEyMD86IGJvb2xlYW47XHJcbiAgc3ltYm9sPzogc3RyaW5nOyAvLyBvcHRpb25hbCBzeW1ib2wgdG8gc2VsZi1mZXRjaCBmcm9tIFlhaG9vIGlmIGRhdGEgbm90IHByb3ZpZGVkXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFkdmFuY2VkUHJpY2VDaGFydCh7XHJcbiAgZGF0YSxcclxuICBtb2RlLFxyXG4gIHJhbmdlLFxyXG4gIGxvZ1NjYWxlLFxyXG4gIHNob3dWb2xNQSxcclxuICBzaG93Qm9sbGluZ2VyQmFuZHMgPSBmYWxzZSxcclxuICBzaG93RU1BMjAgPSBmYWxzZSxcclxuICBzeW1ib2wsXHJcbn06IFByb3BzKSB7XHJcbiAgY29uc3QgeyB0aGVtZSB9ID0gdXNlQXV0aCgpO1xyXG4gIGNvbnN0IFtob3Zlciwgc2V0SG92ZXJdID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIC8vIE5vdGU6IHN5bWJvbCBwcm9wIGRlZmluZWQgYnV0IG5vdCB1c2VkIC0gY2hhcnQgaXMgZGF0YS1kcml2ZW4gZnJvbSBwYXJlbnQncyBkYXRhIHByb3BcclxuICAvLyBQYXJlbnQgKERhc2hib2FyZENsaWVudCkgaGFuZGxlcyBhbGwgZGF0YSBmZXRjaGluZyB2aWEgYXBpLmhpc3RvcnkoKVxyXG4gIC8vIEJhY2tlbmQgYWxyZWFkeSBmZXRjaGVzIHRoZSBjb3JyZWN0IHJhbmdlLCBzbyB3ZSB1c2Ugc291cmNlRGF0YSBkaXJlY3RseVxyXG5cclxuICBjb25zdCBzb3VyY2VEYXRhOiBDYW5kbGVbXSA9IGRhdGEgfHwgW107XHJcbiAgXHJcbiAgY29uc3QgVEFSR0VUX1BFUl9SQU5HRTogUmVjb3JkPFJhbmdlS2V5LCBudW1iZXI+ID0ge1xyXG4gICAgXCIxZFwiOiAxOCxcclxuICAgIFwiMXdcIjogNDAsXHJcbiAgICBcIjFtXCI6IDcwLFxyXG4gICAgXCIzbVwiOiA5MCxcclxuICAgIFwiMXlcIjogMTQwLFxyXG4gICAgXCI1eVwiOiAyMjAsXHJcbiAgfTtcclxuICBjb25zdCB0YXJnZXQgPSBUQVJHRVRfUEVSX1JBTkdFW3JhbmdlXSB8fCAxMjA7XHJcbiAgbGV0IGJ1Y2tldFNpemUgPSBzb3VyY2VEYXRhLmxlbmd0aCA+IHRhcmdldCA/IE1hdGguY2VpbChzb3VyY2VEYXRhLmxlbmd0aCAvIHRhcmdldCkgOiAxO1xyXG4gIGlmIChyYW5nZSA9PT0gJzFkJykgYnVja2V0U2l6ZSA9IDE7IC8vIG5ldmVyIGJ1Y2tldCBpbnRyYWRheSBzbyB0aWNrcyBhbGlnbiB3aXRoIHJlYWwgdGltZXNcclxuICBcclxuICAvLyBDYWxjdWxhdGUgaW5kaWNhdG9ycyBvbiBSQVcgc291cmNlRGF0YSBCRUZPUkUgYnVja2V0aW5nIGZvciBtYXhpbXVtIGFjY3VyYWN5XHJcbiAgY29uc3QgcmF3RW1hMjAgPSBzaG93RU1BMjAgPyBlbWEoc291cmNlRGF0YS5tYXAoKGQ6IENhbmRsZSkgPT4gZC5jKSwgMjApIDogW107XHJcbiAgY29uc3QgcmF3Vm9sTUEgPSBzaG93Vm9sTUEgPyBzbWEoc291cmNlRGF0YS5tYXAoKGQ6IENhbmRsZSkgPT4gZC52KSwgMjApIDogW107XHJcbiAgY29uc3QgcmF3Qm9sbGluZ2VyQmFuZHMgPSBzaG93Qm9sbGluZ2VyQmFuZHMgXHJcbiAgICA/IGNhbGN1bGF0ZUJvbGxpbmdlckJhbmRzKHNvdXJjZURhdGEubWFwKChkOiBDYW5kbGUpID0+IGQuYykpIFxyXG4gICAgOiB7IHVwcGVyOiBbXSwgbG93ZXI6IFtdLCBtaWRkbGU6IFtdIH07XHJcbiAgXHJcbiAgZnVuY3Rpb24gYnVja2V0QWdncmVnYXRlKHNyYzogQ2FuZGxlW10sIHNpemU6IG51bWJlcikge1xyXG4gICAgaWYgKHNpemUgPD0gMSkgcmV0dXJuIHNyYztcclxuICAgIGNvbnN0IG91dDogQ2FuZGxlW10gPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSArPSBzaXplKSB7XHJcbiAgICAgIGNvbnN0IHNsaWNlID0gc3JjLnNsaWNlKGksIGkgKyBzaXplKTtcclxuICAgICAgaWYgKCFzbGljZS5sZW5ndGgpIGNvbnRpbnVlO1xyXG4gICAgICBjb25zdCBvID0gc2xpY2VbMF0ubztcclxuICAgICAgY29uc3QgYyA9IHNsaWNlW3NsaWNlLmxlbmd0aCAtIDFdLmM7XHJcbiAgICAgIGxldCBoID0gLUluZmluaXR5LFxyXG4gICAgICAgIGwgPSBJbmZpbml0eSxcclxuICAgICAgICB2ID0gMDtcclxuICAgICAgZm9yIChjb25zdCBzIG9mIHNsaWNlKSB7XHJcbiAgICAgICAgaWYgKHMuaCA+IGgpIGggPSBzLmg7XHJcbiAgICAgICAgaWYgKHMubCA8IGwpIGwgPSBzLmw7XHJcbiAgICAgICAgdiArPSBzLnY7XHJcbiAgICAgIH1cclxuICAgICAgb3V0LnB1c2goeyB0OiBzbGljZVswXS50LCBvLCBoLCBsLCBjLCB2IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dDtcclxuICB9XHJcbiAgXHJcbiAgLy8gQnVja2V0IGluZGljYXRvcnMgYWxvbmdzaWRlIHRoZSBkYXRhICh0YWtlIGV2ZXJ5IE50aCB2YWx1ZSB0byBtYXRjaCBidWNrZXRpbmcpXHJcbiAgZnVuY3Rpb24gYnVja2V0SW5kaWNhdG9yKHZhbHVlczogKG51bWJlciB8IG51bGwpW10sIHNpemU6IG51bWJlcik6IChudW1iZXIgfCBudWxsKVtdIHtcclxuICAgIGlmIChzaXplIDw9IDEpIHJldHVybiB2YWx1ZXM7XHJcbiAgICBjb25zdCBvdXQ6IChudW1iZXIgfCBudWxsKVtdID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gc2l6ZSkge1xyXG4gICAgICBvdXQucHVzaCh2YWx1ZXNbaV0pOyAvLyBUYWtlIHRoZSBmaXJzdCB2YWx1ZSBvZiBlYWNoIGJ1Y2tldFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dDtcclxuICB9XHJcbiAgXHJcbiAgY29uc3QgYmFzZURhdGEgPSBidWNrZXRTaXplID09PSAxID8gc291cmNlRGF0YSA6IGJ1Y2tldEFnZ3JlZ2F0ZShzb3VyY2VEYXRhLCBidWNrZXRTaXplKTtcclxuICBjb25zdCBidWNrZXRlZEVtYTIwID0gYnVja2V0U2l6ZSA9PT0gMSA/IHJhd0VtYTIwIDogYnVja2V0SW5kaWNhdG9yKHJhd0VtYTIwLCBidWNrZXRTaXplKTtcclxuICBjb25zdCBidWNrZXRlZFZvbE1BID0gYnVja2V0U2l6ZSA9PT0gMSA/IHJhd1ZvbE1BIDogYnVja2V0SW5kaWNhdG9yKHJhd1ZvbE1BLCBidWNrZXRTaXplKTtcclxuICBjb25zdCBidWNrZXRlZEJvbGxpbmdlckJhbmRzID0gYnVja2V0U2l6ZSA9PT0gMSA/IHJhd0JvbGxpbmdlckJhbmRzIDoge1xyXG4gICAgdXBwZXI6IGJ1Y2tldEluZGljYXRvcihyYXdCb2xsaW5nZXJCYW5kcy51cHBlciwgYnVja2V0U2l6ZSksXHJcbiAgICBsb3dlcjogYnVja2V0SW5kaWNhdG9yKHJhd0JvbGxpbmdlckJhbmRzLmxvd2VyLCBidWNrZXRTaXplKSxcclxuICAgIG1pZGRsZTogYnVja2V0SW5kaWNhdG9yKHJhd0JvbGxpbmdlckJhbmRzLm1pZGRsZSwgYnVja2V0U2l6ZSksXHJcbiAgfTtcclxuICBcclxuICAvLyBCYWNrZW5kIGZldGNoZXMgZXh0cmEgY2FuZGxlcyBmb3IgaW5kaWNhdG9yIGNhbGN1bGF0aW9uICgyMC01MCBkZXBlbmRpbmcgb24gcmFuZ2UpXHJcbiAgLy8gQWZ0ZXIgYnVja2V0aW5nLCB3ZSBoaWRlIHByb3BvcnRpb25hbGx5IGZld2VyIGNhbmRsZXNcclxuICBjb25zdCBidWZmZXJQZXJSYW5nZTogUmVjb3JkPFJhbmdlS2V5LCBudW1iZXI+ID0ge1xyXG4gICAgXCIxZFwiOiA1MCwgICAvLyBXb3JrcyBwZXJmZWN0bHlcclxuICAgIFwiMXdcIjogNTAsICAgLy8gTm93IG11Y2ggc21hbGxlciBzaW5jZSBpbmRpY2F0b3JzIHByZS1jYWxjdWxhdGVkXHJcbiAgICBcIjFtXCI6IDUwLCAgIC8vIE5vdyBtdWNoIHNtYWxsZXIgc2luY2UgaW5kaWNhdG9ycyBwcmUtY2FsY3VsYXRlZFxyXG4gICAgXCIzbVwiOiA1MCwgICAvLyBQZXJmZWN0IGFscmVhZHlcclxuICAgIFwiMXlcIjogNTAsICAgLy8gV29ya3MgcGVyZmVjdGx5XHJcbiAgICBcIjV5XCI6IDUwLCAgIC8vIFdvcmtzIHBlcmZlY3RseVxyXG4gIH07XHJcbiAgY29uc3QgYnVmZmVyQ2FuZGxlcyA9IE1hdGgubWluKGJ1ZmZlclBlclJhbmdlW3JhbmdlXSwgTWF0aC5mbG9vcihiYXNlRGF0YS5sZW5ndGggKiAwLjIpKTtcclxuICBjb25zdCBkaXNwbGF5RGF0YSA9IGJhc2VEYXRhLnNsaWNlKGJ1ZmZlckNhbmRsZXMpOyAvLyBIaWRlIGZpcnN0IGNhbmRsZXMgZnJvbSB1c2VyXHJcbiAgXHJcbiAgY29uc3QgW3dpbmRvd0lkeCwgc2V0V2luZG93SWR4XSA9IFJlYWN0LnVzZVN0YXRlPFtudW1iZXIsIG51bWJlcl0+KCgpID0+IFswLCBkaXNwbGF5RGF0YS5sZW5ndGggLSAxXSk7XHJcbiAgLy8gUmVzZXQgd2luZG93IHdoZW4gZGlzcGxheURhdGEgbGVuZ3RoIGNoYW5nZXMgKHJhbmdlIGNoYW5nZSBvciBuZXcgZGF0YSlcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgc2V0V2luZG93SWR4KFswLCBkaXNwbGF5RGF0YS5sZW5ndGggLSAxXSk7XHJcbiAgfSwgW2Rpc3BsYXlEYXRhLmxlbmd0aF0pO1xyXG4gIFxyXG4gIC8vIEFsd2F5cyBzaG93IGZ1bGwgcmFuZ2UgdW5sZXNzIHVzZXIgem9vbXMvcGFucyAod2luZG93SWR4IGFjdHMgYXMgdXNlciBvdmVycmlkZSBhZnRlciBmaXJzdCB3aGVlbC9kcmFnKVxyXG4gIGNvbnN0IFt3U3RhcnQsIHdFbmRdID0gd2luZG93SWR4O1xyXG4gIGNvbnN0IGZ1bGxTdGFydCA9IDA7XHJcbiAgY29uc3QgZnVsbEVuZCA9IGRpc3BsYXlEYXRhLmxlbmd0aCAtIDE7XHJcbiAgY29uc3QgZWZmZWN0aXZlU3RhcnQgPVxyXG4gICAgd1N0YXJ0ID09PSAwICYmIHdFbmQgPT09IGRpc3BsYXlEYXRhLmxlbmd0aCAtIDEgPyBmdWxsU3RhcnQgOiBNYXRoLm1heCgwLCBNYXRoLm1pbih3U3RhcnQsIGZ1bGxFbmQpKTtcclxuICBjb25zdCBlZmZlY3RpdmVFbmQgPSB3U3RhcnQgPT09IDAgJiYgd0VuZCA9PT0gZGlzcGxheURhdGEubGVuZ3RoIC0gMSA/IGZ1bGxFbmQgOiBNYXRoLm1pbih3RW5kLCBmdWxsRW5kKTtcclxuICBjb25zdCBzYWZlRW5kID0gTWF0aC5taW4oZWZmZWN0aXZlRW5kLCBkaXNwbGF5RGF0YS5sZW5ndGggLSAxKTtcclxuICBjb25zdCBzYWZlU3RhcnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihlZmZlY3RpdmVTdGFydCwgc2FmZUVuZCAtIDUpKTtcclxuICBjb25zdCBkcmF3RGF0YSA9IGRpc3BsYXlEYXRhLnNsaWNlKHNhZmVTdGFydCwgc2FmZUVuZCArIDEpO1xyXG4gIFxyXG4gIC8vIFNsaWNlIHByZS1jYWxjdWxhdGVkIGluZGljYXRvcnMgdG8gbWF0Y2ggZHJhd0RhdGEgKG9mZnNldCBieSBidWZmZXIgKyB3aW5kb3cpXHJcbiAgY29uc3QgaW5kaWNhdG9yU3RhcnQgPSBidWZmZXJDYW5kbGVzICsgc2FmZVN0YXJ0O1xyXG4gIGNvbnN0IGluZGljYXRvckVuZCA9IGJ1ZmZlckNhbmRsZXMgKyBzYWZlRW5kICsgMTtcclxuICBjb25zdCBlbWEyMCA9IGJ1Y2tldGVkRW1hMjAuc2xpY2UoaW5kaWNhdG9yU3RhcnQsIGluZGljYXRvckVuZCk7XHJcbiAgY29uc3Qgdm9sTUEgPSBidWNrZXRlZFZvbE1BLnNsaWNlKGluZGljYXRvclN0YXJ0LCBpbmRpY2F0b3JFbmQpO1xyXG4gIGNvbnN0IGJvbGxpbmdlckJhbmRzID0ge1xyXG4gICAgdXBwZXI6IGJ1Y2tldGVkQm9sbGluZ2VyQmFuZHMudXBwZXIuc2xpY2UoaW5kaWNhdG9yU3RhcnQsIGluZGljYXRvckVuZCksXHJcbiAgICBsb3dlcjogYnVja2V0ZWRCb2xsaW5nZXJCYW5kcy5sb3dlci5zbGljZShpbmRpY2F0b3JTdGFydCwgaW5kaWNhdG9yRW5kKSxcclxuICAgIG1pZGRsZTogYnVja2V0ZWRCb2xsaW5nZXJCYW5kcy5taWRkbGUuc2xpY2UoaW5kaWNhdG9yU3RhcnQsIGluZGljYXRvckVuZCksXHJcbiAgfTtcclxuICBcclxuICBjb25zdCBjbG9zZXMgPSBkcmF3RGF0YS5tYXAoKGQ6IENhbmRsZSkgPT4gZC5jKSxcclxuICAgIGhpZ2hzID0gZHJhd0RhdGEubWFwKChkOiBDYW5kbGUpID0+IGQuaCksXHJcbiAgICBsb3dzID0gZHJhd0RhdGEubWFwKChkOiBDYW5kbGUpID0+IGQubCk7XHJcbiAgZnVuY3Rpb24gcXVhbnRpbGUoYXJyOiBudW1iZXJbXSwgcTogbnVtYmVyKSB7XHJcbiAgICBpZiAoIWFyci5sZW5ndGgpIHJldHVybiAwO1xyXG4gICAgY29uc3Qgc29ydGVkID0gWy4uLmFycl0uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG4gICAgY29uc3QgcG9zID0gKHNvcnRlZC5sZW5ndGggLSAxKSAqIHE7XHJcbiAgICBjb25zdCBiYXNlID0gTWF0aC5mbG9vcihwb3MpO1xyXG4gICAgY29uc3QgcmVzdCA9IHBvcyAtIGJhc2U7XHJcbiAgICByZXR1cm4gc29ydGVkW2Jhc2UgKyAxXSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgID8gc29ydGVkW2Jhc2VdICsgcmVzdCAqIChzb3J0ZWRbYmFzZSArIDFdIC0gc29ydGVkW2Jhc2VdKVxyXG4gICAgICA6IHNvcnRlZFtiYXNlXTtcclxuICB9XHJcbiAgbGV0IG1pbiA9IHF1YW50aWxlKGxvd3MsIDAuMDA1KSxcclxuICAgIG1heCA9IHF1YW50aWxlKGhpZ2hzLCAwLjk5NSk7XHJcbiAgY29uc3QgbGFzdEMgPSBkcmF3RGF0YVtkcmF3RGF0YS5sZW5ndGggLSAxXTtcclxuICBpZiAobGFzdEMpIHtcclxuICAgIGlmIChsYXN0Qy5sIDwgbWluKSBtaW4gPSBsYXN0Qy5sO1xyXG4gICAgaWYgKGxhc3RDLmggPiBtYXgpIG1heCA9IGxhc3RDLmg7XHJcbiAgfVxyXG4gIGNvbnN0IHNwYW4gPSBtYXggLSBtaW4gfHwgMTtcclxuICAvLyBTaW5nbGUgc2NhbGUgdmFyaWFibGVcclxuICBjb25zdCBTID0gTGF5b3V0Q29uZmlnLkNIQVJUX1NDQUxFOyAvLyBhZmZlY3RzIHZlcnRpY2FsIHJlYWwgZXN0YXRlXHJcbiAgY29uc3QgaFZpc3VhbEJhc2UgPSBMYXlvdXRDb25maWcuR1JBUEhfSEVJR0hUOyAvLyBiYXNlbGluZSB2aXN1YWwgaGVpZ2h0IGZyb20gY29uZmlnXHJcbiAgY29uc3Qgdm9sdW1lUG9ydGlvbiA9IDAuMjM7IC8vIGZyYWN0aW9uIHJlc2VydmVkIGZvciB2b2x1bWUgYXJlYVxyXG4gIGNvbnN0IGhWaXN1YWwgPSBoVmlzdWFsQmFzZSAqIFM7XHJcbiAgY29uc3Qgdm9sSCA9IGhWaXN1YWwgKiB2b2x1bWVQb3J0aW9uO1xyXG4gIGNvbnN0IHByaWNlSCA9IGhWaXN1YWwgLSB2b2xIO1xyXG4gIGNvbnN0IGF4aXNGb290ZXIgPSBMYXlvdXRDb25maWcuQVhJU19GT09URVJfSEVJR0hUO1xyXG4gIGNvbnN0IGggPSBoVmlzdWFsICsgYXhpc0Zvb3RlcjtcclxuICBjb25zdCB3ID0gTGF5b3V0Q29uZmlnLkdSQVBIX1dJRFRIO1xyXG4gIGNvbnN0IGd1dHRlclJpZ2h0ID0gTGF5b3V0Q29uZmlnLkFYSVNfUklHSFRfR1VUVEVSO1xyXG4gIGNvbnN0IHBhZFRvcCA9IDgsXHJcbiAgICBwYWRCb3R0b20gPSA2LFxyXG4gICAgcGFkTGVmdCA9IDQ7XHJcbiAgY29uc3QgcHJpY2VBcmVhID0gcHJpY2VIIC0gcGFkVG9wIC0gcGFkQm90dG9tO1xyXG4gIGNvbnN0IHVwID0gY2xvc2VzW2Nsb3Nlcy5sZW5ndGggLSAxXSA+PSBjbG9zZXNbMF07XHJcbiAgY29uc3QgcHJpY2VXID0gdyAtIGd1dHRlclJpZ2h0IC0gcGFkTGVmdDtcclxuICBcclxuICAvLyBJbmRleC1iYXNlZCBob3Jpem9udGFsIHNjYWxlIChyZW1vdmVzIHRpbWUgZ2FwcyBmb3IgY29udGludW91cyBkaXNwbGF5KVxyXG4gIGNvbnN0IG51bUNhbmRsZXMgPSBkcmF3RGF0YS5sZW5ndGg7XHJcbiAgZnVuY3Rpb24geEZvcklkeChpZHg6IG51bWJlcikgeyByZXR1cm4gcGFkTGVmdCArIChpZHggLyBNYXRoLm1heCgxLCBudW1DYW5kbGVzIC0gMSkpICogcHJpY2VXOyB9XHJcbiAgXHJcbiAgLy8gU3RvcmUgdGltZXN0YW1wcyBmb3IgbGFiZWxzXHJcbiAgY29uc3QgZHJhd1RpbWVzID0gZHJhd0RhdGEubWFwKGQgPT4gbmV3IERhdGUoZC50KS5nZXRUaW1lKCkpO1xyXG4gIFxyXG4gIC8vIEFkYXB0aXZlIGNhbmRsZSB3aWR0aCBmcm9tIGRhdGEgZGVuc2l0eVxyXG4gIGxldCBjYW5kbGVXaWR0aDogbnVtYmVyO1xyXG4gIGlmIChudW1DYW5kbGVzIDw9IDIpIHtcclxuICAgIGNhbmRsZVdpZHRoID0gKHByaWNlVyAvIE1hdGgubWF4KDEsIG51bUNhbmRsZXMpKSAqIDAuNjtcclxuICB9IGVsc2Uge1xyXG4gICAgY2FuZGxlV2lkdGggPSAocHJpY2VXIC8gbnVtQ2FuZGxlcykgKiAwLjg7XHJcbiAgfVxyXG4gIGlmIChjYW5kbGVXaWR0aCA8IDMpIGNhbmRsZVdpZHRoID0gMzsgaWYgKGNhbmRsZVdpZHRoID4gMjIpIGNhbmRsZVdpZHRoID0gMjI7XHJcbiAgY29uc3QgbGluZVB0cyA9IGRyYXdEYXRhLm1hcCgoZCwgaWR4KSA9PiB7XHJcbiAgICBjb25zdCB4ID0geEZvcklkeChpZHgpO1xyXG4gICAgY29uc3QgdmFsID0gbG9nU2NhbGUgPyAoTWF0aC5sb2cxMChkLmMpIC0gTWF0aC5sb2cxMChtaW4pKSAvIChNYXRoLmxvZzEwKG1heCkgLSBNYXRoLmxvZzEwKG1pbiB8fCAxKSkgOiAoZC5jIC0gbWluKSAvIHNwYW47XHJcbiAgICBjb25zdCB5ID0gcGFkVG9wICsgKHByaWNlQXJlYSAtIHZhbCAqIHByaWNlQXJlYSk7XHJcbiAgICByZXR1cm4gYCR7eH0sJHt5fWA7XHJcbiAgfSkuam9pbihcIiBcIik7XHJcbiAgY29uc3QgaG92ZXJQb2ludCA9IGhvdmVyICE9IG51bGwgPyBkcmF3RGF0YVtob3Zlcl0gOiBudWxsO1xyXG4gIGZ1bmN0aW9uIG9uTW92ZShlOiBSZWFjdC5Nb3VzZUV2ZW50PFNWR1NWR0VsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCByZWN0ID0gZS5jdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgY29uc3QgeCA9IGUuY2xpZW50WCAtIHJlY3QubGVmdDtcclxuICAgIFxyXG4gICAgLy8gSW5kZXgtYmFzZWQgaG92ZXI6IGZpbmQgbmVhcmVzdCBjYW5kbGUgYnkgeCBwb3NpdGlvblxyXG4gICAgaWYgKGRyYXdEYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG4gICAgXHJcbiAgICBjb25zdCB4UmF0aW8gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoeCAtIHBhZExlZnQpIC8gKHJlY3Qud2lkdGggLSAoZ3V0dGVyUmlnaHQgLyB3KSAqIHJlY3Qud2lkdGgpKSk7XHJcbiAgICBjb25zdCBpZHggPSBNYXRoLnJvdW5kKHhSYXRpbyAqIChudW1DYW5kbGVzIC0gMSkpO1xyXG4gICAgXHJcbiAgICBzZXRIb3ZlcihNYXRoLm1heCgwLCBNYXRoLm1pbihudW1DYW5kbGVzIC0gMSwgaWR4KSkpO1xyXG4gIH1cclxuICBjb25zdCBkcmFnU3RhdGUgPSB1c2VSZWY8eyBzdGFydFg6IG51bWJlcjsgc3RhcnRSYW5nZTogW251bWJlciwgbnVtYmVyXSB9IHwgbnVsbD4obnVsbCk7XHJcbiAgZnVuY3Rpb24gb25XaGVlbChlOiBSZWFjdC5XaGVlbEV2ZW50PFNWR1NWR0VsZW1lbnQ+KSB7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBpZiAoZHJhd0RhdGEubGVuZ3RoIDwgMTApIHJldHVybjtcclxuICAgIGNvbnN0IGRlbHRhID0gZS5kZWx0YVk7XHJcbiAgICBjb25zdCBmYWN0b3IgPSBkZWx0YSA+IDAgPyAxLjEgOiAwLjk7XHJcbiAgICBjb25zdCBjdXJyZW50TGVuID0gd0VuZCAtIHdTdGFydCArIDE7XHJcbiAgICBjb25zdCBuZXdMZW4gPSBNYXRoLm1heCgyMCwgTWF0aC5taW4oZGlzcGxheURhdGEubGVuZ3RoLCBNYXRoLnJvdW5kKGN1cnJlbnRMZW4gKiBmYWN0b3IpKSk7XHJcbiAgICBjb25zdCByZWN0ID0gKGUuY3VycmVudFRhcmdldCBhcyBTVkdTVkdFbGVtZW50KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGNvbnN0IHhSYXRpbyA9IChlLmNsaWVudFggLSByZWN0LmxlZnQgLSBwYWRMZWZ0KSAvIChyZWN0LndpZHRoIC0gZ3V0dGVyUmlnaHQpO1xyXG4gICAgY29uc3QgZm9jdXNJZHggPSB3U3RhcnQgKyBNYXRoLnJvdW5kKGN1cnJlbnRMZW4gKiB4UmF0aW8pO1xyXG4gICAgbGV0IG5ld1N0YXJ0ID0gZm9jdXNJZHggLSBNYXRoLnJvdW5kKG5ld0xlbiAqIHhSYXRpbyk7XHJcbiAgICBsZXQgbmV3RW5kID0gbmV3U3RhcnQgKyBuZXdMZW4gLSAxO1xyXG4gICAgaWYgKG5ld1N0YXJ0IDwgMCkge1xyXG4gICAgICBuZXdTdGFydCA9IDA7XHJcbiAgICAgIG5ld0VuZCA9IG5ld0xlbiAtIDE7XHJcbiAgICB9XHJcbiAgICBpZiAobmV3RW5kID4gZGlzcGxheURhdGEubGVuZ3RoIC0gMSkge1xyXG4gICAgICBuZXdFbmQgPSBkaXNwbGF5RGF0YS5sZW5ndGggLSAxO1xyXG4gICAgICBuZXdTdGFydCA9IG5ld0VuZCAtIG5ld0xlbiArIDE7XHJcbiAgICB9XHJcbiAgICBzZXRXaW5kb3dJZHgoW25ld1N0YXJ0LCBuZXdFbmRdKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gb25Qb2ludGVyRG93bihlOiBSZWFjdC5Qb2ludGVyRXZlbnQ8U1ZHU1ZHRWxlbWVudD4pIHtcclxuICAgIGUuY3VycmVudFRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XHJcbiAgICBkcmFnU3RhdGUuY3VycmVudCA9IHsgc3RhcnRYOiBlLmNsaWVudFgsIHN0YXJ0UmFuZ2U6IHdpbmRvd0lkeCB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiBvblBvaW50ZXJNb3ZlKGU6IFJlYWN0LlBvaW50ZXJFdmVudDxTVkdTVkdFbGVtZW50Pikge1xyXG4gICAgaWYgKCFkcmFnU3RhdGUuY3VycmVudCkgcmV0dXJuO1xyXG4gICAgY29uc3QgW3MsIGVJZHhdID0gZHJhZ1N0YXRlLmN1cnJlbnQuc3RhcnRSYW5nZTtcclxuICAgIGNvbnN0IGxlbiA9IGVJZHggLSBzICsgMTtcclxuICAgIGNvbnN0IHBpeGVsUGVyQ2FuZGxlID0gcHJpY2VXIC8gZHJhd0RhdGEubGVuZ3RoO1xyXG4gICAgY29uc3QgZGVsdGFQeCA9IGUuY2xpZW50WCAtIGRyYWdTdGF0ZS5jdXJyZW50LnN0YXJ0WDtcclxuICAgIGNvbnN0IHNoaWZ0ID0gTWF0aC5yb3VuZCgtZGVsdGFQeCAvIHBpeGVsUGVyQ2FuZGxlKTtcclxuICAgIGxldCBuZXdTdGFydCA9IHMgKyBzaGlmdDtcclxuICAgIGxldCBuZXdFbmQgPSBuZXdTdGFydCArIGxlbiAtIDE7XHJcbiAgICBpZiAobmV3U3RhcnQgPCAwKSB7XHJcbiAgICAgIG5ld1N0YXJ0ID0gMDtcclxuICAgICAgbmV3RW5kID0gbGVuIC0gMTtcclxuICAgIH1cclxuICAgIGlmIChuZXdFbmQgPiBkaXNwbGF5RGF0YS5sZW5ndGggLSAxKSB7XHJcbiAgICAgIG5ld0VuZCA9IGRpc3BsYXlEYXRhLmxlbmd0aCAtIDE7XHJcbiAgICAgIG5ld1N0YXJ0ID0gbmV3RW5kIC0gbGVuICsgMTtcclxuICAgIH1cclxuICAgIHNldFdpbmRvd0lkeChbbmV3U3RhcnQsIG5ld0VuZF0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBvblBvaW50ZXJVcCgpIHtcclxuICAgIGRyYWdTdGF0ZS5jdXJyZW50ID0gbnVsbDtcclxuICB9XHJcbiAgZnVuY3Rpb24gbmljZVRpY2tzKGxvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHRhcmdldCA9IDUpIHtcclxuICAgIGNvbnN0IHJhd1NwYW4gPSBoaWdoIC0gbG93IHx8IDE7XHJcbiAgICBjb25zdCByb3VnaFN0ZXAgPSByYXdTcGFuIC8gKHRhcmdldCAtIDEpO1xyXG4gICAgY29uc3QgcG93MTAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZzEwKHJvdWdoU3RlcCkpKTtcclxuICAgIGNvbnN0IG11bHRpcGxlcyA9IFsxLCAyLCAyLjUsIDUsIDEwXTtcclxuICAgIGNvbnN0IGZvdW5kID0gbXVsdGlwbGVzLmZpbmQoKG0pID0+IG0gKiBwb3cxMCA+PSByb3VnaFN0ZXApIHx8IG11bHRpcGxlc1ttdWx0aXBsZXMubGVuZ3RoIC0gMV07XHJcbiAgICBjb25zdCBzdGVwID0gZm91bmQgKiBwb3cxMDtcclxuICAgIGNvbnN0IGZpcnN0ID0gTWF0aC5jZWlsKGxvdyAvIHN0ZXApICogc3RlcDtcclxuICAgIGNvbnN0IHRpY2tzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgZm9yIChsZXQgdiA9IGZpcnN0OyB2IDw9IGhpZ2g7IHYgKz0gc3RlcCkgdGlja3MucHVzaCh2KTtcclxuICAgIHJldHVybiB0aWNrcztcclxuICB9XHJcbiAgLy8gVGltZSB0aWNrcyBwZXIgZXhwbGljaXQgc3BlY1xyXG4gIGNvbnN0IHRpbWVUaWNrczogQXJyYXk8eyB4OiBudW1iZXI7IGxhYmVsOiBzdHJpbmcgfT4gPSBbXTtcclxuICBpZiAoZHJhd0RhdGEubGVuZ3RoID4gMSkge1xyXG4gICAgaWYgKHJhbmdlID09PSAnMWQnKSB7XHJcbiAgICAgIC8vIFNob3cgbGFiZWwgZXZlcnkgaG91ciBmb3IgY2xlYW5lciBkaXNwbGF5XHJcbiAgICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICAgICAgZHJhd0RhdGEuZm9yRWFjaCgoYywgaWR4KSA9PiB7XHJcbiAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKGMudCk7XHJcbiAgICAgICAgY29uc3QgaGggPSBkLmdldEhvdXJzKCk7XHJcbiAgICAgICAgY29uc3QgbW0gPSBkLmdldE1pbnV0ZXMoKTtcclxuICAgICAgICAvLyBTaG93IGxhYmVsIGV2ZXJ5IGhvdXIgb24gdGhlIGhvdXJcclxuICAgICAgICBpZiAobW0gPT09IDApIHtcclxuICAgICAgICAgIGNvbnN0IHRpbWVLZXkgPSBgJHtoaH06MDBgO1xyXG4gICAgICAgICAgaWYgKCFzZWVuLmhhcyh0aW1lS2V5KSkge1xyXG4gICAgICAgICAgICBzZWVuLmFkZCh0aW1lS2V5KTtcclxuICAgICAgICAgICAgdGltZVRpY2tzLnB1c2goeyBcclxuICAgICAgICAgICAgICB4OiB4Rm9ySWR4KGlkeCksIFxyXG4gICAgICAgICAgICAgIGxhYmVsOiBkLnRvTG9jYWxlVGltZVN0cmluZygnZW4tVVMnLCB7IGhvdXI6ICdudW1lcmljJywgbWludXRlOiAnMi1kaWdpdCcsIGhvdXIxMjogZmFsc2UgfSkgXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKHJhbmdlID09PSAnMXcnKSB7XHJcbiAgICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTsgZHJhd0RhdGEuZm9yRWFjaCgoYywgaWR4KSA9PiB7IGNvbnN0IGQgPSBuZXcgRGF0ZShjLnQpOyBjb25zdCBrID0gZC50b0RhdGVTdHJpbmcoKTsgaWYgKCFzZWVuLmhhcyhrKSkgeyBzZWVuLmFkZChrKTsgdGltZVRpY2tzLnB1c2goeyB4OiB4Rm9ySWR4KGlkeCksIGxhYmVsOiBkLnRvTG9jYWxlRGF0ZVN0cmluZyh1bmRlZmluZWQseyB3ZWVrZGF5OidzaG9ydCd9KS50b1VwcGVyQ2FzZSgpIH0pOyB9IH0pO1xyXG4gICAgfSBlbHNlIGlmIChyYW5nZSA9PT0gJzFtJykge1xyXG4gICAgICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCk7IGRyYXdEYXRhLmZvckVhY2goKGMsIGlkeCkgPT4geyBjb25zdCBkID0gbmV3IERhdGUoYy50KTsgaWYgKGQuZ2V0RGF5KCkgPT09IDEpIHsgY29uc3Qga2V5ID0gZC5nZXRGdWxsWWVhcigpK1wiLVwiK2QuZ2V0TW9udGgoKStcIi1cIitkLmdldERhdGUoKTsgaWYgKCFzZWVuLmhhcyhrZXkpKSB7IHNlZW4uYWRkKGtleSk7IHRpbWVUaWNrcy5wdXNoKHsgeDogeEZvcklkeChpZHgpLCBsYWJlbDogKGQuZ2V0TW9udGgoKSsxKStcIi9cIitkLmdldERhdGUoKSB9KTsgfSB9IH0pO1xyXG4gICAgfSBlbHNlIGlmIChyYW5nZSA9PT0gJzNtJykge1xyXG4gICAgICBsZXQgbW9uZGF5Q291bnQgPSAwOyBkcmF3RGF0YS5mb3JFYWNoKChjLCBpZHgpID0+IHsgY29uc3QgZCA9IG5ldyBEYXRlKGMudCk7IGlmIChkLmdldERheSgpID09PSAxKSB7IGlmIChtb25kYXlDb3VudCAlIDMgPT09IDApIHRpbWVUaWNrcy5wdXNoKHsgeDogeEZvcklkeChpZHgpLCBsYWJlbDogKGQuZ2V0TW9udGgoKSsxKStcIi9cIitkLmdldERhdGUoKSB9KTsgbW9uZGF5Q291bnQrKzsgfSB9KTtcclxuICAgIH0gZWxzZSBpZiAocmFuZ2UgPT09ICcxeScpIHtcclxuICAgICAgY29uc3Qgc2Vlbk1vbnRoID0gbmV3IFNldDxzdHJpbmc+KCk7IGRyYXdEYXRhLmZvckVhY2goKGMsIGlkeCkgPT4geyBjb25zdCBkID0gbmV3IERhdGUoYy50KTsgY29uc3QgbWsgPSBkLmdldEZ1bGxZZWFyKCkrXCItXCIrZC5nZXRNb250aCgpOyBpZiAoIXNlZW5Nb250aC5oYXMobWspICYmIGQuZ2V0RGF0ZSgpIDw9IDcpIHsgc2Vlbk1vbnRoLmFkZChtayk7IHRpbWVUaWNrcy5wdXNoKHsgeDogeEZvcklkeChpZHgpLCBsYWJlbDogZC50b0xvY2FsZVN0cmluZyh1bmRlZmluZWQseyBtb250aDonc2hvcnQnfSkudG9VcHBlckNhc2UoKSB9KTsgfSB9KTtcclxuICAgIH0gZWxzZSBpZiAocmFuZ2UgPT09ICc1eScpIHtcclxuICAgICAgY29uc3Qgc2VlblllYXIgPSBuZXcgU2V0PG51bWJlcj4oKTsgZHJhd0RhdGEuZm9yRWFjaCgoYywgaWR4KSA9PiB7IGNvbnN0IGQgPSBuZXcgRGF0ZShjLnQpOyBpZiAoIXNlZW5ZZWFyLmhhcyhkLmdldEZ1bGxZZWFyKCkpICYmIGQuZ2V0TW9udGgoKSA8IDIpIHsgc2VlblllYXIuYWRkKGQuZ2V0RnVsbFllYXIoKSk7IHRpbWVUaWNrcy5wdXNoKHsgeDogeEZvcklkeChpZHgpLCBsYWJlbDogU3RyaW5nKGQuZ2V0RnVsbFllYXIoKSkgfSk7IH0gfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IG1heFZvbCA9IE1hdGgubWF4KC4uLmRyYXdEYXRhLm1hcCgoZDogQ2FuZGxlKSA9PiBkLnYpLCAxKTtcclxuICBjb25zdCBtYWduaXR1ZGUgPSBNYXRoLmFicyhtYXgpO1xyXG4gIGNvbnN0IGRlY2ltYWxzID0gbWFnbml0dWRlID49IDUwMCA/IDAgOiBtYWduaXR1ZGUgPj0gMTAwID8gMSA6IDI7XHJcbiAgZnVuY3Rpb24gc21hKHNyYzogbnVtYmVyW10sIHBlcmlvZDogbnVtYmVyKSB7XHJcbiAgICBpZiAoc3JjLmxlbmd0aCA8IHBlcmlvZCkgcmV0dXJuIFtdO1xyXG4gICAgY29uc3Qgb3V0OiAobnVtYmVyIHwgbnVsbClbXSA9IG5ldyBBcnJheShwZXJpb2QgLSAxKS5maWxsKG51bGwpOyAvLyBQYWQgYmVnaW5uaW5nIHdpdGggbnVsbHNcclxuICAgIGxldCBzdW0gPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcmMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgc3VtICs9IHNyY1tpXTtcclxuICAgICAgaWYgKGkgPj0gcGVyaW9kKSBzdW0gLT0gc3JjW2kgLSBwZXJpb2RdO1xyXG4gICAgICBpZiAoaSA+PSBwZXJpb2QgLSAxKSBvdXQucHVzaChzdW0gLyBwZXJpb2QpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVtYShzcmM6IG51bWJlcltdLCBwZXJpb2Q6IG51bWJlcik6IChudW1iZXIgfCBudWxsKVtdIHtcclxuICAgIGlmIChzcmMubGVuZ3RoIDwgcGVyaW9kKSByZXR1cm4gW107XHJcbiAgICBjb25zdCBrID0gMiAvIChwZXJpb2QgKyAxKTtcclxuICAgIGNvbnN0IG91dDogKG51bWJlciB8IG51bGwpW10gPSBuZXcgQXJyYXkocGVyaW9kIC0gMSkuZmlsbChudWxsKTsgLy8gUGFkIGJlZ2lubmluZyB3aXRoIG51bGxzXHJcbiAgICBcclxuICAgIC8vIFN0YXJ0IHdpdGggU01BIGZvciBmaXJzdCB2YWx1ZVxyXG4gICAgbGV0IHN1bSA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlcmlvZDsgaSsrKSB7XHJcbiAgICAgIHN1bSArPSBzcmNbaV07XHJcbiAgICB9XHJcbiAgICBvdXQucHVzaChzdW0gLyBwZXJpb2QpO1xyXG4gICAgXHJcbiAgICAvLyBUaGVuIHVzZSBFTUEgZm9ybXVsYVxyXG4gICAgZm9yIChsZXQgaSA9IHBlcmlvZDsgaSA8IHNyYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBvdXQucHVzaChzcmNbaV0gKiBrICsgKG91dFtvdXQubGVuZ3RoIC0gMV0gYXMgbnVtYmVyKSAqICgxIC0gaykpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gb3V0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2FsY3VsYXRlQm9sbGluZ2VyQmFuZHMoY2xvc2VzOiBudW1iZXJbXSwgcGVyaW9kOiBudW1iZXIgPSAyMCwgc3RkRGV2TXVsdGlwbGllcjogbnVtYmVyID0gMikge1xyXG4gICAgaWYgKGNsb3Nlcy5sZW5ndGggPCBwZXJpb2QpIHJldHVybiB7IHVwcGVyOiBbXSwgbG93ZXI6IFtdLCBtaWRkbGU6IFtdIH07XHJcbiAgICBcclxuICAgIGNvbnN0IG1pZGRsZTogKG51bWJlciB8IG51bGwpW10gPSBuZXcgQXJyYXkocGVyaW9kIC0gMSkuZmlsbChudWxsKTtcclxuICAgIGNvbnN0IHVwcGVyOiAobnVtYmVyIHwgbnVsbClbXSA9IG5ldyBBcnJheShwZXJpb2QgLSAxKS5maWxsKG51bGwpO1xyXG4gICAgY29uc3QgbG93ZXI6IChudW1iZXIgfCBudWxsKVtdID0gbmV3IEFycmF5KHBlcmlvZCAtIDEpLmZpbGwobnVsbCk7XHJcbiAgICBcclxuICAgIGZvciAobGV0IGkgPSBwZXJpb2QgLSAxOyBpIDwgY2xvc2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHNsaWNlID0gY2xvc2VzLnNsaWNlKGkgLSBwZXJpb2QgKyAxLCBpICsgMSk7XHJcbiAgICAgIGNvbnN0IGF2ZyA9IHNsaWNlLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCkgLyBwZXJpb2Q7XHJcbiAgICAgIGNvbnN0IHZhcmlhbmNlID0gc2xpY2UucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgTWF0aC5wb3codmFsIC0gYXZnLCAyKSwgMCkgLyBwZXJpb2Q7XHJcbiAgICAgIGNvbnN0IHN0ZERldiA9IE1hdGguc3FydCh2YXJpYW5jZSk7XHJcbiAgICAgIFxyXG4gICAgICBtaWRkbGUucHVzaChhdmcpO1xyXG4gICAgICB1cHBlci5wdXNoKGF2ZyArIHN0ZERldk11bHRpcGxpZXIgKiBzdGREZXYpO1xyXG4gICAgICBsb3dlci5wdXNoKGF2ZyAtIHN0ZERldk11bHRpcGxpZXIgKiBzdGREZXYpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4geyB1cHBlciwgbG93ZXIsIG1pZGRsZSB9O1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBzdHlsZT17eyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCBpbnNldDogMCwgZm9udFNpemU6IDExIH19PlxyXG4gICAgICA8c3ZnXHJcbiAgICAgICAgdmlld0JveD17YDAgMCAke3d9ICR7aH1gfVxyXG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCJcclxuICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcclxuICAgICAgICAgIGN1cnNvcjogXCJjcm9zc2hhaXJcIixcclxuICAgICAgICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiLFxyXG4gICAgICAgICAgZm9udEZhbWlseTogXCJzeXN0ZW0tdWksIHVpLW1vbm9zcGFjZSwgTWVubG8sIG1vbm9zcGFjZVwiLFxyXG4gICAgICAgIH19XHJcbiAgICAgICAgb25Nb3VzZU1vdmU9e29uTW92ZX1cclxuICAgICAgICBvbk1vdXNlTGVhdmU9eygpID0+IHNldEhvdmVyKG51bGwpfVxyXG4gICAgICAgIG9uV2hlZWw9e29uV2hlZWx9XHJcbiAgICAgICAgb25Qb2ludGVyRG93bj17b25Qb2ludGVyRG93bn1cclxuICAgICAgICBvblBvaW50ZXJNb3ZlPXtvblBvaW50ZXJNb3ZlfVxyXG4gICAgICAgIG9uUG9pbnRlclVwPXtvblBvaW50ZXJVcH1cclxuICAgICAgPlxyXG4gICAgICAgIHtuaWNlVGlja3MobWluLCBtYXgsIDUpLm1hcCgodCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgeSA9IDggKyAocHJpY2VBcmVhIC0gKCh0IC0gbWluKSAvIHNwYW4pICogcHJpY2VBcmVhKTtcclxuICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxnIGtleT17dC50b0ZpeGVkKDYpfT5cclxuICAgICAgICAgICAgICA8bGluZVxyXG4gICAgICAgICAgICAgICAgeDE9e3BhZExlZnR9XHJcbiAgICAgICAgICAgICAgICB4Mj17cGFkTGVmdCArIHByaWNlV31cclxuICAgICAgICAgICAgICAgIHkxPXt5fVxyXG4gICAgICAgICAgICAgICAgeTI9e3l9XHJcbiAgICAgICAgICAgICAgICBzdHJva2U9e3RoZW1lID09PSBcImxpZ2h0XCIgPyBcIiNkMGQ3ZGVcIiA6IFwiIzMwMzYzZFwifVxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XHJcbiAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICA8dGV4dFxyXG4gICAgICAgICAgICAgICAgeD17cGFkTGVmdCArIHByaWNlVyArIExheW91dENvbmZpZy5BWElTX1lfTEFCRUxfWF9PRkZTRVR9XHJcbiAgICAgICAgICAgICAgICB5PXt5ICsgTGF5b3V0Q29uZmlnLkFYSVNfWV9GT05UX1NJWkUgLyAzfVxyXG4gICAgICAgICAgICAgICAgZmlsbD17dGhlbWUgPT09IFwibGlnaHRcIiA/IFwiIzAwMDAwMFwiIDogXCIjZmZmZmZmXCJ9XHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZT17TGF5b3V0Q29uZmlnLkFYSVNfWV9GT05UX1NJWkV9XHJcbiAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAge3QudG9GaXhlZChkZWNpbWFscyl9XHJcbiAgICAgICAgICAgICAgPC90ZXh0PlxyXG4gICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0pfVxyXG5cclxuICAgICAgICB7LyogVmVydGljYWwgZ3JpZCBsaW5lcyAocmVuZGVyIGJlZm9yZSBjaGFydCBkYXRhIHNvIHRoZXkgYXBwZWFyIGJlaGluZCkgKi99XHJcbiAgICAgICAge3RpbWVUaWNrcy5tYXAoKHQsIGkpID0+IChcclxuICAgICAgICAgIDxsaW5lXHJcbiAgICAgICAgICAgIGtleT17XCJ4dGljay1cIiArIGl9XHJcbiAgICAgICAgICAgIHgxPXt0Lnh9XHJcbiAgICAgICAgICAgIHgyPXt0Lnh9XHJcbiAgICAgICAgICAgIHkxPXswfVxyXG4gICAgICAgICAgICB5Mj17aFZpc3VhbH1cclxuICAgICAgICAgICAgc3Ryb2tlPXt0aGVtZSA9PT0gXCJsaWdodFwiID8gXCIjZDBkN2RlXCIgOiBcIiMzMDM2M2RcIn1cclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICkpfVxyXG5cclxuICAgICAgICB7LyogQm9sbGluZ2VyIEJhbmRzICovfVxyXG4gICAgICAgIHtzaG93Qm9sbGluZ2VyQmFuZHMgJiYgYm9sbGluZ2VyQmFuZHMudXBwZXIubGVuZ3RoID4gMCAmJiAoXHJcbiAgICAgICAgICA8PlxyXG4gICAgICAgICAgICB7LyogRmlsbCBhcmVhICovfVxyXG4gICAgICAgICAgICA8cG9seWdvblxyXG4gICAgICAgICAgICAgIHBvaW50cz17KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50czogc3RyaW5nW10gPSBbXTtcclxuICAgICAgICAgICAgICAgIC8vIFVwcGVyIGJhbmRcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9sbGluZ2VyQmFuZHMudXBwZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgdXBwZXJWYWwgPSBib2xsaW5nZXJCYW5kcy51cHBlcltpXTtcclxuICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyVmFsID09PSBudWxsKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IHhGb3JJZHgoaSk7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9ICh1cHBlclZhbCAtIG1pbikgLyBzcGFuO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB5ID0gcGFkVG9wICsgKHByaWNlQXJlYSAtIHZhbCAqIHByaWNlQXJlYSk7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZSh4KSAmJiBpc0Zpbml0ZSh5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGAke3h9LCR7eX1gKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gTG93ZXIgYmFuZCAocmV2ZXJzZWQpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gYm9sbGluZ2VyQmFuZHMubG93ZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgbG93ZXJWYWwgPSBib2xsaW5nZXJCYW5kcy5sb3dlcltpXTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGxvd2VyVmFsID09PSBudWxsKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IHhGb3JJZHgoaSk7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IChsb3dlclZhbCAtIG1pbikgLyBzcGFuO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB5ID0gcGFkVG9wICsgKHByaWNlQXJlYSAtIHZhbCAqIHByaWNlQXJlYSk7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZSh4KSAmJiBpc0Zpbml0ZSh5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGAke3h9LCR7eX1gKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5qb2luKFwiIFwiKTtcclxuICAgICAgICAgICAgICB9KSgpfVxyXG4gICAgICAgICAgICAgIGZpbGw9XCJyZ2JhKDEzNSwgMjA2LCAyMzUsIDAuMTUpXCJcclxuICAgICAgICAgICAgICBzdHJva2U9XCJub25lXCJcclxuICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHsvKiBVcHBlciBiYW5kIG91dGxpbmUgKi99XHJcbiAgICAgICAgICAgIDxwb2x5bGluZVxyXG4gICAgICAgICAgICAgIHBvaW50cz17Ym9sbGluZ2VyQmFuZHMudXBwZXJcclxuICAgICAgICAgICAgICAgIC5tYXAoKHYsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgaWYgKHYgPT09IG51bGwpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB4ID0geEZvcklkeChpKTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gKHYgLSBtaW4pIC8gc3BhbjtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IHBhZFRvcCArIChwcmljZUFyZWEgLSB2YWwgKiBwcmljZUFyZWEpO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gYCR7eH0sJHt5fWA7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihwID0+IHAgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAuam9pbihcIiBcIil9XHJcbiAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxyXG4gICAgICAgICAgICAgIHN0cm9rZT1cInJnYmEoMTM1LCAyMDYsIDIzNSwgMC44KVwiXHJcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XHJcbiAgICAgICAgICAgICAgdmVjdG9yRWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCJcclxuICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHsvKiBMb3dlciBiYW5kIG91dGxpbmUgKi99XHJcbiAgICAgICAgICAgIDxwb2x5bGluZVxyXG4gICAgICAgICAgICAgIHBvaW50cz17Ym9sbGluZ2VyQmFuZHMubG93ZXJcclxuICAgICAgICAgICAgICAgIC5tYXAoKHYsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgaWYgKHYgPT09IG51bGwpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB4ID0geEZvcklkeChpKTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gKHYgLSBtaW4pIC8gc3BhbjtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IHBhZFRvcCArIChwcmljZUFyZWEgLSB2YWwgKiBwcmljZUFyZWEpO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gYCR7eH0sJHt5fWA7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihwID0+IHAgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAuam9pbihcIiBcIil9XHJcbiAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxyXG4gICAgICAgICAgICAgIHN0cm9rZT1cInJnYmEoMTM1LCAyMDYsIDIzNSwgMC44KVwiXHJcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XHJcbiAgICAgICAgICAgICAgdmVjdG9yRWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCJcclxuICAgICAgICAgICAgLz5cclxuICAgICAgICAgIDwvPlxyXG4gICAgICAgICl9XHJcbiAgICAgICAge21vZGUgPT09IFwibGluZVwiICYmIChcclxuICAgICAgICAgIDxwb2x5bGluZVxyXG4gICAgICAgICAgICBwb2ludHM9e2xpbmVQdHN9XHJcbiAgICAgICAgICAgIGZpbGw9XCJub25lXCJcclxuICAgICAgICAgICAgc3Ryb2tlPXt1cCA/IFwidmFyKC0tY29sb3Itc3VjY2VzcylcIiA6IFwidmFyKC0tY29sb3ItZGFuZ2VyKVwifVxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aD17Mn1cclxuICAgICAgICAgICAgdmVjdG9yRWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgKX1cclxuICAgICAgICB7bW9kZSA9PT0gXCJjYW5kbGVzXCIgJiZcclxuICAgICAgICAgIGRyYXdEYXRhLm1hcCgoZDogQ2FuZGxlLCBpZHg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjZW50ZXJYID0geEZvcklkeChpZHgpO1xyXG4gICAgICAgICAgICBjb25zdCB4ID0gY2VudGVyWCAtIGNhbmRsZVdpZHRoIC8gMjtcclxuICAgICAgICAgICAgY29uc3QgdmFsT3BlbiA9IGxvZ1NjYWxlXHJcbiAgICAgICAgICAgICAgPyAoTWF0aC5sb2cxMChkLm8pIC0gTWF0aC5sb2cxMChtaW4pKSAvIChNYXRoLmxvZzEwKG1heCkgLSBNYXRoLmxvZzEwKG1pbiB8fCAxKSlcclxuICAgICAgICAgICAgICA6IChkLm8gLSBtaW4pIC8gc3BhbjtcclxuICAgICAgICAgICAgY29uc3QgdmFsQ2xvc2UgPSBsb2dTY2FsZVxyXG4gICAgICAgICAgICAgID8gKE1hdGgubG9nMTAoZC5jKSAtIE1hdGgubG9nMTAobWluKSkgLyAoTWF0aC5sb2cxMChtYXgpIC0gTWF0aC5sb2cxMChtaW4gfHwgMSkpXHJcbiAgICAgICAgICAgICAgOiAoZC5jIC0gbWluKSAvIHNwYW47XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbEhpZ2ggPSBsb2dTY2FsZVxyXG4gICAgICAgICAgICAgID8gKE1hdGgubG9nMTAoZC5oKSAtIE1hdGgubG9nMTAobWluKSkgLyAoTWF0aC5sb2cxMChtYXgpIC0gTWF0aC5sb2cxMChtaW4gfHwgMSkpXHJcbiAgICAgICAgICAgICAgOiAoZC5oIC0gbWluKSAvIHNwYW47XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbExvdyA9IGxvZ1NjYWxlXHJcbiAgICAgICAgICAgICAgPyAoTWF0aC5sb2cxMChkLmwpIC0gTWF0aC5sb2cxMChtaW4pKSAvIChNYXRoLmxvZzEwKG1heCkgLSBNYXRoLmxvZzEwKG1pbiB8fCAxKSlcclxuICAgICAgICAgICAgICA6IChkLmwgLSBtaW4pIC8gc3BhbjtcclxuICAgICAgICAgICAgY29uc3Qgb3BlblkgPSA4ICsgKHByaWNlQXJlYSAtIHZhbE9wZW4gKiBwcmljZUFyZWEpO1xyXG4gICAgICAgICAgICBjb25zdCBjbG9zZVkgPSA4ICsgKHByaWNlQXJlYSAtIHZhbENsb3NlICogcHJpY2VBcmVhKTtcclxuICAgICAgICAgICAgY29uc3QgaGlnaFkgPSA4ICsgKHByaWNlQXJlYSAtIHZhbEhpZ2ggKiBwcmljZUFyZWEpO1xyXG4gICAgICAgICAgICBjb25zdCBsb3dZID0gOCArIChwcmljZUFyZWEgLSB2YWxMb3cgKiBwcmljZUFyZWEpO1xyXG4gICAgICAgICAgICBjb25zdCByaXNpbmcgPSBkLmMgPj0gZC5vO1xyXG4gICAgICAgICAgICBjb25zdCBwY3QgPSBNYXRoLm1pbigwLjA1LCBNYXRoLm1heCgtMC4wNSwgKGQuYyAtIGQubykgLyBkLm8pKTtcclxuICAgICAgICAgICAgY29uc3QgaW50ZW5zaXR5ID0gTWF0aC5hYnMocGN0KSAvIDAuMDU7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhc2VDb2xvciA9IHJpc2luZyA/IFwidmFyKC0tY29sb3Itc3VjY2VzcylcIiA6IFwidmFyKC0tY29sb3ItZGFuZ2VyKVwiO1xyXG4gICAgICAgICAgICBjb25zdCBmaWxsID0gcmlzaW5nXHJcbiAgICAgICAgICAgICAgPyBgcmdiYSgzNSwxMzQsNTQsJHswLjM1ICsgMC41NSAqIGludGVuc2l0eX0pYFxyXG4gICAgICAgICAgICAgIDogYHJnYmEoMjQ4LDgxLDczLCR7MC4zNSArIDAuNTUgKiBpbnRlbnNpdHl9KWA7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgPGcga2V5PXtkLnR9PlxyXG4gICAgICAgICAgICAgICAgPGxpbmVcclxuICAgICAgICAgICAgICAgICAgeDE9e3ggKyBjYW5kbGVXaWR0aCAvIDJ9XHJcbiAgICAgICAgICAgICAgICAgIHgyPXt4ICsgY2FuZGxlV2lkdGggLyAyfVxyXG4gICAgICAgICAgICAgICAgICB5MT17aGlnaFl9XHJcbiAgICAgICAgICAgICAgICAgIHkyPXtsb3dZfVxyXG4gICAgICAgICAgICAgICAgICBzdHJva2U9e2Jhc2VDb2xvcn1cclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPHJlY3RcclxuICAgICAgICAgICAgICAgICAgeD17eH1cclxuICAgICAgICAgICAgICAgICAgeT17TWF0aC5taW4ob3BlblksIGNsb3NlWSl9XHJcbiAgICAgICAgICAgICAgICAgIHdpZHRoPXtjYW5kbGVXaWR0aH1cclxuICAgICAgICAgICAgICAgICAgaGVpZ2h0PXtNYXRoLm1heCgyLCBNYXRoLmFicyhjbG9zZVkgLSBvcGVuWSkpfVxyXG4gICAgICAgICAgICAgICAgICBmaWxsPXtmaWxsfVxyXG4gICAgICAgICAgICAgICAgICBzdHJva2U9e2Jhc2VDb2xvcn1cclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezAuNX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSl9XHJcblxyXG4gICAgICAgIHsvKiBFTUEgMjAgKi99XHJcbiAgICAgICAge3Nob3dFTUEyMCAmJiBlbWEyMC5sZW5ndGggJiYgKFxyXG4gICAgICAgICAgPHBvbHlsaW5lXHJcbiAgICAgICAgICAgIHBvaW50cz17ZW1hMjBcclxuICAgICAgICAgICAgICAubWFwKCh2LCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0geEZvcklkeChpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGxvZ1NjYWxlXHJcbiAgICAgICAgICAgICAgICAgID8gKE1hdGgubG9nMTAodikgLSBNYXRoLmxvZzEwKG1pbikpIC8gKE1hdGgubG9nMTAobWF4KSAtIE1hdGgubG9nMTAobWluIHx8IDEpKVxyXG4gICAgICAgICAgICAgICAgICA6ICh2IC0gbWluKSAvIHNwYW47XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gOCArIChwcmljZUFyZWEgLSB2YWwgKiBwcmljZUFyZWEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3h9LCR7eX1gO1xyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgLmZpbHRlcihwID0+IHAgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgLmpvaW4oXCIgXCIpfVxyXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXHJcbiAgICAgICAgICAgIHN0cm9rZT1cIiNmZjk1MDBcIlxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aD17MS40fVxyXG4gICAgICAgICAgICB2ZWN0b3JFZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxyXG4gICAgICAgICAgLz5cclxuICAgICAgICApfVxyXG5cclxuICAgICAgICB7ZHJhd0RhdGEubWFwKChkLCBpZHgpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGNlbnRlclggPSB4Rm9ySWR4KGlkeCk7XHJcbiAgICAgICAgICBjb25zdCB4ID0gY2VudGVyWCAtIGNhbmRsZVdpZHRoIC8gMjtcclxuICAgICAgICAgIGNvbnN0IHZvbFJhdGlvID0gZC52IC8gbWF4Vm9sO1xyXG4gICAgICAgICAgbGV0IGJhckggPSB2b2xSYXRpbyAqICh2b2xIIC0gMTYpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBNaW5pbXVtIGJhciBoZWlnaHQgZm9yIHZpc2liaWxpdHkgKGVzcGVjaWFsbHkgZm9yIGxvdyBhZnRlci1ob3VycyB2b2x1bWUpXHJcbiAgICAgICAgICBjb25zdCBtaW5CYXJIZWlnaHQgPSAyO1xyXG4gICAgICAgICAgaWYgKGJhckggPiAwICYmIGJhckggPCBtaW5CYXJIZWlnaHQpIGJhckggPSBtaW5CYXJIZWlnaHQ7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IHkgPSBwcmljZUggKyAodm9sSCAtIGJhckgpO1xyXG4gICAgICAgICAgY29uc3QgcmlzaW5nID0gZC5jID49IGQubztcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBleHRlbmRlZCBob3VycyAoYmVmb3JlIDk6MzAgb3IgYWZ0ZXIgMTY6MDAgRVQpXHJcbiAgICAgICAgICBjb25zdCBjYW5kbGVEYXRlID0gbmV3IERhdGUoZC50KTtcclxuICAgICAgICAgIGNvbnN0IGhvdXIgPSBjYW5kbGVEYXRlLmdldEhvdXJzKCk7XHJcbiAgICAgICAgICBjb25zdCBtaW51dGUgPSBjYW5kbGVEYXRlLmdldE1pbnV0ZXMoKTtcclxuICAgICAgICAgIGNvbnN0IHRpbWVJbk1pbnV0ZXMgPSBob3VyICogNjAgKyBtaW51dGU7XHJcbiAgICAgICAgICBjb25zdCBtYXJrZXRPcGVuID0gOSAqIDYwICsgMzA7IC8vIDk6MzAgQU1cclxuICAgICAgICAgIGNvbnN0IG1hcmtldENsb3NlID0gMTYgKiA2MDsgLy8gNDowMCBQTVxyXG4gICAgICAgICAgY29uc3QgaXNFeHRlbmRlZEhvdXJzID0gdGltZUluTWludXRlcyA8IG1hcmtldE9wZW4gfHwgdGltZUluTWludXRlcyA+PSBtYXJrZXRDbG9zZTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPHJlY3RcclxuICAgICAgICAgICAgICBrZXk9e2QudCArIFwiOnZvbFwifVxyXG4gICAgICAgICAgICAgIHg9e3h9XHJcbiAgICAgICAgICAgICAgeT17eX1cclxuICAgICAgICAgICAgICB3aWR0aD17Y2FuZGxlV2lkdGh9XHJcbiAgICAgICAgICAgICAgaGVpZ2h0PXtiYXJIfVxyXG4gICAgICAgICAgICAgIGZpbGw9e3Jpc2luZyA/IFwidmFyKC0tY29sb3Itc3VjY2VzcylcIiA6IFwidmFyKC0tY29sb3ItZGFuZ2VyKVwifVxyXG4gICAgICAgICAgICAgIG9wYWNpdHk9e2lzRXh0ZW5kZWRIb3VycyA/IDAuMiA6IDAuMzV9XHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0pfVxyXG4gICAgICAgIHtzaG93Vm9sTUEgJiYgdm9sTUEubGVuZ3RoICYmIChcclxuICAgICAgICAgIDxwb2x5bGluZVxyXG4gICAgICAgICAgICBwb2ludHM9e3ZvbE1BXHJcbiAgICAgICAgICAgICAgLm1hcCgodiwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IG51bGwpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHhGb3JJZHgoaSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByYXRpbyA9IHYgLyBtYXhWb2w7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXJIID0gcmF0aW8gKiAodm9sSCAtIDE2KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBwcmljZUggKyAodm9sSCAtIGJhckgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3h9LCR7eX1gO1xyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgLmZpbHRlcihwID0+IHAgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgLmpvaW4oXCIgXCIpfVxyXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXHJcbiAgICAgICAgICAgIHN0cm9rZT1cIiM1OGE2ZmZcIlxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aD17MX1cclxuICAgICAgICAgICAgdmVjdG9yRWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgKX1cclxuICAgICAgICB7aG92ZXJQb2ludCAmJlxyXG4gICAgICAgICAgKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeCA9IHhGb3JJZHgoaG92ZXIhKTtcclxuICAgICAgICAgICAgY29uc3QgeSA9IDggKyAocHJpY2VBcmVhIC0gKChob3ZlclBvaW50LmMgLSBtaW4pIC8gc3BhbikgKiBwcmljZUFyZWEpO1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgIDxnPlxyXG4gICAgICAgICAgICAgICAgPGxpbmVcclxuICAgICAgICAgICAgICAgICAgeDE9e3h9XHJcbiAgICAgICAgICAgICAgICAgIHgyPXt4fVxyXG4gICAgICAgICAgICAgICAgICB5MT17MH1cclxuICAgICAgICAgICAgICAgICAgeTI9e3ByaWNlSH1cclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlPXt0aGVtZSA9PT0gXCJsaWdodFwiID8gXCIjNjU2ZDc2XCIgOiBcIiM3ZDg1OTBcIn1cclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5PVwiNCAzXCJcclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPGxpbmVcclxuICAgICAgICAgICAgICAgICAgeDE9ezB9XHJcbiAgICAgICAgICAgICAgICAgIHgyPXt3fVxyXG4gICAgICAgICAgICAgICAgICB5MT17eX1cclxuICAgICAgICAgICAgICAgICAgeTI9e3l9XHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZT17dGhlbWUgPT09IFwibGlnaHRcIiA/IFwiIzY1NmQ3NlwiIDogXCIjN2Q4NTkwXCJ9XHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIjQgM1wiXHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDxjaXJjbGVcclxuICAgICAgICAgICAgICAgICAgY3g9e3h9XHJcbiAgICAgICAgICAgICAgICAgIGN5PXt5fVxyXG4gICAgICAgICAgICAgICAgICByPXs1fVxyXG4gICAgICAgICAgICAgICAgICBmaWxsPVwidmFyKC0tY29sb3ItYmcpXCJcclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlPXt1cCA/IFwidmFyKC0tY29sb3Itc3VjY2VzcylcIiA6IFwidmFyKC0tY29sb3ItZGFuZ2VyKVwifVxyXG4gICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD17Mn1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSkoKX1cclxuICAgICAgICB7ZHJhd0RhdGEubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgICAgKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbGFzdCA9IGRyYXdEYXRhW2RyYXdEYXRhLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gOCArIChwcmljZUFyZWEgLSAoKGxhc3QuYyAtIG1pbikgLyBzcGFuKSAqIHByaWNlQXJlYSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVXAgPSBsYXN0LmMgPj0gY2xvc2VzWzBdO1xyXG4gICAgICAgICAgICAvLyBCcmlnaHRlciwgaGlnaGVyIGNvbnRyYXN0IGNvbG9ycyBmb3IgbGFzdCBwcmljZSBsYWJlbFxyXG4gICAgICAgICAgICBjb25zdCBicmlnaHRHcmVlbiA9IFwiIzAwZmY0MVwiOyAvLyBCcmlnaHQgbmVvbiBncmVlblxyXG4gICAgICAgICAgICBjb25zdCBicmlnaHRSZWQgPSBcIiNmZjMzNjZcIjsgLy8gQnJpZ2h0IHJlZFxyXG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IGlzVXAgPyBicmlnaHRHcmVlbiA6IGJyaWdodFJlZDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgPGc+XHJcbiAgICAgICAgICAgICAgICA8bGluZVxyXG4gICAgICAgICAgICAgICAgICB4MT17cGFkTGVmdH1cclxuICAgICAgICAgICAgICAgICAgeDI9e3BhZExlZnQgKyBwcmljZVd9XHJcbiAgICAgICAgICAgICAgICAgIHkxPXt5fVxyXG4gICAgICAgICAgICAgICAgICB5Mj17eX1cclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlPXtjb2xvcn1cclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5PVwiMiA0XCJcclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPHJlY3RcclxuICAgICAgICAgICAgICAgICAgeD17cGFkTGVmdCArIHByaWNlVyArIDR9XHJcbiAgICAgICAgICAgICAgICAgIHk9e3kgLSBMYXlvdXRDb25maWcuTEFTVF9QUklDRV9MQUJFTF9IRUlHSFQgLyAyfVxyXG4gICAgICAgICAgICAgICAgICB3aWR0aD17TGF5b3V0Q29uZmlnLkxBU1RfUFJJQ0VfTEFCRUxfV0lEVEh9XHJcbiAgICAgICAgICAgICAgICAgIGhlaWdodD17TGF5b3V0Q29uZmlnLkxBU1RfUFJJQ0VfTEFCRUxfSEVJR0hUfVxyXG4gICAgICAgICAgICAgICAgICBmaWxsPXtpc1VwIFxyXG4gICAgICAgICAgICAgICAgICAgID8gKHRoZW1lID09PSBcImxpZ2h0XCIgPyBcIiNlNmZmZjBcIiA6IFwiIzAwMjIxMVwiKSBcclxuICAgICAgICAgICAgICAgICAgICA6ICh0aGVtZSA9PT0gXCJsaWdodFwiID8gXCIjZmZlNmVlXCIgOiBcIiMyZDAwMTFcIil9XHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZT17Y29sb3J9XHJcbiAgICAgICAgICAgICAgICAgIHJ4PXszfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDx0ZXh0XHJcbiAgICAgICAgICAgICAgICAgIHg9e3BhZExlZnQgKyBwcmljZVcgKyA0ICsgTGF5b3V0Q29uZmlnLkxBU1RfUFJJQ0VfTEFCRUxfV0lEVEggLyAyfVxyXG4gICAgICAgICAgICAgICAgICB5PXt5ICsgTGF5b3V0Q29uZmlnLkxBU1RfUFJJQ0VfTEFCRUxfRk9OVF9TSVpFIC8gM31cclxuICAgICAgICAgICAgICAgICAgdGV4dEFuY2hvcj1cIm1pZGRsZVwiXHJcbiAgICAgICAgICAgICAgICAgIGZpbGw9e2NvbG9yfVxyXG4gICAgICAgICAgICAgICAgICBmb250U2l6ZT17TGF5b3V0Q29uZmlnLkxBU1RfUFJJQ0VfTEFCRUxfRk9OVF9TSVpFfVxyXG4gICAgICAgICAgICAgICAgICBmb250V2VpZ2h0PXs2MDB9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgIHtsYXN0LmMudG9GaXhlZChkZWNpbWFscyl9XHJcbiAgICAgICAgICAgICAgICA8L3RleHQ+XHJcbiAgICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSkoKX1cclxuICAgICAgICBcclxuICAgICAgICB7LyogSW5kaWNhdG9yIGxhYmVscyB3aXRoIHNtYXJ0IG92ZXJsYXAgYXZvaWRhbmNlICovfVxyXG4gICAgICAgIHsoKCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgbGFiZWxzOiBBcnJheTx7IHk6IG51bWJlcjsgdmFsdWU6IG51bWJlcjsgY29sb3I6IHN0cmluZzsgYmdDb2xvcjogc3RyaW5nOyBzdHJva2U6IHN0cmluZyB9PiA9IFtdO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBNYWluIHByaWNlIHBvc2l0aW9uXHJcbiAgICAgICAgICBjb25zdCBsYXN0UHJpY2UgPSBkcmF3RGF0YVtkcmF3RGF0YS5sZW5ndGggLSAxXT8uYyB8fCAwO1xyXG4gICAgICAgICAgY29uc3QgcHJpY2VZID0gOCArIChwcmljZUFyZWEgLSAoKGxhc3RQcmljZSAtIG1pbikgLyBzcGFuKSAqIHByaWNlQXJlYSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEVNQTIwXHJcbiAgICAgICAgICBpZiAoc2hvd0VNQTIwICYmIGVtYTIwLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgbGFzdEVtYSA9IGVtYTIwW2VtYTIwLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBpZiAobGFzdEVtYSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIGxhYmVscy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHk6IDggKyAocHJpY2VBcmVhIC0gKChsYXN0RW1hIC0gbWluKSAvIHNwYW4pICogcHJpY2VBcmVhKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBsYXN0RW1hLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IFwiI2ZmOTUwMFwiLFxyXG4gICAgICAgICAgICAgICAgYmdDb2xvcjogdGhlbWUgPT09IFwibGlnaHRcIiA/IFwiI2ZmZjVlNlwiIDogXCIjMmQyNDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiI2ZmOTUwMFwiLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEJvbGxpbmdlciBCYW5kcyBVcHBlclxyXG4gICAgICAgICAgaWYgKHNob3dCb2xsaW5nZXJCYW5kcyAmJiBib2xsaW5nZXJCYW5kcy51cHBlci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RVcHBlciA9IGJvbGxpbmdlckJhbmRzLnVwcGVyW2JvbGxpbmdlckJhbmRzLnVwcGVyLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBpZiAobGFzdFVwcGVyICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgbGFiZWxzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgeTogOCArIChwcmljZUFyZWEgLSAoKGxhc3RVcHBlciAtIG1pbikgLyBzcGFuKSAqIHByaWNlQXJlYSksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGFzdFVwcGVyLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IFwicmdiYSgxMzUsIDIwNiwgMjM1LCAxKVwiLFxyXG4gICAgICAgICAgICAgICAgYmdDb2xvcjogdGhlbWUgPT09IFwibGlnaHRcIiA/IFwiI2U2ZjdmZlwiIDogXCIjMDAxYTJkXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwicmdiYSgxMzUsIDIwNiwgMjM1LCAwLjgpXCIsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQm9sbGluZ2VyIEJhbmRzIExvd2VyXHJcbiAgICAgICAgICBpZiAoc2hvd0JvbGxpbmdlckJhbmRzICYmIGJvbGxpbmdlckJhbmRzLmxvd2VyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgbGFzdExvd2VyID0gYm9sbGluZ2VyQmFuZHMubG93ZXJbYm9sbGluZ2VyQmFuZHMubG93ZXIubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGlmIChsYXN0TG93ZXIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICBsYWJlbHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB5OiA4ICsgKHByaWNlQXJlYSAtICgobGFzdExvd2VyIC0gbWluKSAvIHNwYW4pICogcHJpY2VBcmVhKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBsYXN0TG93ZXIsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJyZ2JhKDEzNSwgMjA2LCAyMzUsIDEpXCIsXHJcbiAgICAgICAgICAgICAgICBiZ0NvbG9yOiB0aGVtZSA9PT0gXCJsaWdodFwiID8gXCIjZTZmN2ZmXCIgOiBcIiMwMDFhMmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCJyZ2JhKDEzNSwgMjA2LCAyMzUsIDAuOClcIixcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBBZGp1c3QgcG9zaXRpb25zIHRvIGF2b2lkIG92ZXJsYXBzXHJcbiAgICAgICAgICBjb25zdCBtaW5HYXAgPSBMYXlvdXRDb25maWcuSU5ESUNBVE9SX0xBQkVMX0hFSUdIVCArIDI7XHJcbiAgICAgICAgICBjb25zdCBhZGp1c3RlZExhYmVscyA9IGxhYmVscy5tYXAoKGxhYmVsKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBhZGp1c3RlZFkgPSBsYWJlbC55O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQ2hlY2sgb3ZlcmxhcCB3aXRoIG1haW4gcHJpY2UgbGFiZWxcclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGFkanVzdGVkWSAtIHByaWNlWSkgPCBtaW5HYXApIHtcclxuICAgICAgICAgICAgICAvLyBNb3ZlIGFib3ZlIG9yIGJlbG93IGJhc2VkIG9uIHdoaWNoIHNpZGUgaGFzIG1vcmUgc3BhY2VcclxuICAgICAgICAgICAgICBpZiAoYWRqdXN0ZWRZIDwgcHJpY2VZKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMYWJlbCBpcyBhYm92ZSBwcmljZSwgbW92ZSBpdCBmdXJ0aGVyIHVwXHJcbiAgICAgICAgICAgICAgICBhZGp1c3RlZFkgPSBwcmljZVkgLSBtaW5HYXA7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIExhYmVsIGlzIGJlbG93IHByaWNlLCBtb3ZlIGl0IGZ1cnRoZXIgZG93blxyXG4gICAgICAgICAgICAgICAgYWRqdXN0ZWRZID0gcHJpY2VZICsgbWluR2FwO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIHsgLi4ubGFiZWwsIHk6IGFkanVzdGVkWSB9O1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIFNvcnQgYnkgWSBwb3NpdGlvbiBhbmQgYWRqdXN0IGZvciBvdmVybGFwcyBiZXR3ZWVuIGluZGljYXRvcnNcclxuICAgICAgICAgIGFkanVzdGVkTGFiZWxzLnNvcnQoKGEsIGIpID0+IGEueSAtIGIueSk7XHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFkanVzdGVkTGFiZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhZGp1c3RlZExhYmVsc1tpXS55IC0gYWRqdXN0ZWRMYWJlbHNbaSAtIDFdLnkgPCBtaW5HYXApIHtcclxuICAgICAgICAgICAgICBhZGp1c3RlZExhYmVsc1tpXS55ID0gYWRqdXN0ZWRMYWJlbHNbaSAtIDFdLnkgKyBtaW5HYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcmV0dXJuIGFkanVzdGVkTGFiZWxzLm1hcCgobGFiZWwsIGlkeCkgPT4gKFxyXG4gICAgICAgICAgICA8ZyBrZXk9e2BpbmRpY2F0b3ItbGFiZWwtJHtpZHh9YH0+XHJcbiAgICAgICAgICAgICAgPHJlY3RcclxuICAgICAgICAgICAgICAgIHg9e3BhZExlZnQgKyBwcmljZVcgKyA0fVxyXG4gICAgICAgICAgICAgICAgeT17bGFiZWwueSAtIExheW91dENvbmZpZy5JTkRJQ0FUT1JfTEFCRUxfSEVJR0hUIC8gMn1cclxuICAgICAgICAgICAgICAgIHdpZHRoPXtMYXlvdXRDb25maWcuSU5ESUNBVE9SX0xBQkVMX1dJRFRIfVxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0PXtMYXlvdXRDb25maWcuSU5ESUNBVE9SX0xBQkVMX0hFSUdIVH1cclxuICAgICAgICAgICAgICAgIGZpbGw9e2xhYmVsLmJnQ29sb3J9XHJcbiAgICAgICAgICAgICAgICBzdHJva2U9e2xhYmVsLnN0cm9rZX1cclxuICAgICAgICAgICAgICAgIHJ4PXsyfVxyXG4gICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgPHRleHRcclxuICAgICAgICAgICAgICAgIHg9e3BhZExlZnQgKyBwcmljZVcgKyA0ICsgTGF5b3V0Q29uZmlnLklORElDQVRPUl9MQUJFTF9XSURUSCAvIDJ9XHJcbiAgICAgICAgICAgICAgICB5PXtsYWJlbC55ICsgTGF5b3V0Q29uZmlnLklORElDQVRPUl9MQUJFTF9GT05UX1NJWkUgLyAzfVxyXG4gICAgICAgICAgICAgICAgdGV4dEFuY2hvcj1cIm1pZGRsZVwiXHJcbiAgICAgICAgICAgICAgICBmaWxsPXtsYWJlbC5jb2xvcn1cclxuICAgICAgICAgICAgICAgIGZvbnRTaXplPXtMYXlvdXRDb25maWcuSU5ESUNBVE9SX0xBQkVMX0ZPTlRfU0laRX1cclxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ9ezYwMH1cclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICB7bGFiZWwudmFsdWUudG9GaXhlZChkZWNpbWFscyl9XHJcbiAgICAgICAgICAgICAgPC90ZXh0PlxyXG4gICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICApKTtcclxuICAgICAgICB9KSgpfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHt0aW1lVGlja3MubWFwKCh0LCBpKSA9PiAoXHJcbiAgICAgICAgICA8dGV4dFxyXG4gICAgICAgICAgICBrZXk9e1wieGxhYmVsLVwiICsgaX1cclxuICAgICAgICAgICAgeD17dC54fVxyXG4gICAgICAgICAgICB5PXtoIC0gNn1cclxuICAgICAgICAgICAgdGV4dEFuY2hvcj1cIm1pZGRsZVwiXHJcbiAgICAgICAgICAgIGZvbnRTaXplPXtMYXlvdXRDb25maWcuQVhJU19YX0ZPTlRfU0laRX1cclxuICAgICAgICAgICAgZmlsbD17dGhlbWUgPT09IFwibGlnaHRcIiA/IFwiIzAwMDAwMFwiIDogXCIjZmZmZmZmXCJ9XHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIHt0LmxhYmVsfVxyXG4gICAgICAgICAgPC90ZXh0PlxyXG4gICAgICAgICkpfVxyXG4gICAgICA8L3N2Zz5cclxuICAgICAge2hvdmVyUG9pbnQgJiYgKCgpID0+IHtcclxuICAgICAgICBjb25zdCBob3ZlclggPSB4Rm9ySWR4KGhvdmVyISk7XHJcbiAgICAgICAgY29uc3QgaG92ZXJYUGVyY2VudCA9ICgoaG92ZXJYIC0gcGFkTGVmdCkgLyBwcmljZVcpICogMTAwO1xyXG4gICAgICAgIC8vIEZsaXAgdG9vbHRpcCB0byBsZWZ0IHNpZGUgaWYgaG92ZXJpbmcgbmVhciByaWdodCBlZGdlICg+IDc1JSlcclxuICAgICAgICBjb25zdCBmbGlwTGVmdCA9IGhvdmVyWFBlcmNlbnQgPiA3NTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgICAgbGVmdDogZmxpcExlZnQgPyB1bmRlZmluZWQgOiBgJHtob3ZlclhQZXJjZW50fSVgLFxyXG4gICAgICAgICAgICAgIHJpZ2h0OiBmbGlwTGVmdCA/IGAkezEwMCAtIGhvdmVyWFBlcmNlbnR9JWAgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgdG9wOiA4LFxyXG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6IHRoZW1lID09PSBcImxpZ2h0XCIgPyBcInJnYmEoMjU1LDI1NSwyNTUsMC45NSlcIiA6IFwicmdiYSgwLDAsMCwwLjc4KVwiLFxyXG4gICAgICAgICAgICAgIHBhZGRpbmc6IFwiNnB4IDhweFwiLFxyXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogNCxcclxuICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICBib3JkZXI6IHRoZW1lID09PSBcImxpZ2h0XCIgPyBcIjFweCBzb2xpZCAjZDBkN2RlXCIgOiBcIjFweCBzb2xpZCAjMzAzNjNkXCIsXHJcbiAgICAgICAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcclxuICAgICAgICAgICAgICBiYWNrZHJvcEZpbHRlcjogXCJibHVyKDJweClcIixcclxuICAgICAgICAgICAgICBjb2xvcjogdGhlbWUgPT09IFwibGlnaHRcIiA/IFwiIzI0MjkyZlwiIDogXCIjZTZlZGYzXCIsXHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBmbGlwTGVmdCA/IFwidHJhbnNsYXRlWCgxMDAlKVwiIDogXCJ0cmFuc2xhdGVYKC01MCUpXCIsXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZm9udFNpemU6IDExLCBvcGFjaXR5OiAwLjcgfX0+XHJcbiAgICAgICAgICAgICAge25ldyBEYXRlKGhvdmVyUG9pbnQudCkudG9Mb2NhbGVTdHJpbmcoKX1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZm9udFdlaWdodDogNjAwIH19Pntob3ZlclBvaW50LmMudG9GaXhlZCgyKX08L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pKCl9XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsIkxheW91dENvbmZpZyIsInVzZUF1dGgiLCJBZHZhbmNlZFByaWNlQ2hhcnQiLCJkYXRhIiwibW9kZSIsInJhbmdlIiwibG9nU2NhbGUiLCJzaG93Vm9sTUEiLCJzaG93Qm9sbGluZ2VyQmFuZHMiLCJzaG93RU1BMjAiLCJzeW1ib2wiLCJ0aGVtZSIsImhvdmVyIiwic2V0SG92ZXIiLCJ1c2VTdGF0ZSIsInNvdXJjZURhdGEiLCJUQVJHRVRfUEVSX1JBTkdFIiwidGFyZ2V0IiwiYnVja2V0U2l6ZSIsImxlbmd0aCIsIk1hdGgiLCJjZWlsIiwicmF3RW1hMjAiLCJlbWEiLCJtYXAiLCJkIiwiYyIsInJhd1ZvbE1BIiwic21hIiwidiIsInJhd0JvbGxpbmdlckJhbmRzIiwiY2FsY3VsYXRlQm9sbGluZ2VyQmFuZHMiLCJ1cHBlciIsImxvd2VyIiwibWlkZGxlIiwiYnVja2V0QWdncmVnYXRlIiwic3JjIiwic2l6ZSIsIm91dCIsImkiLCJzbGljZSIsIm8iLCJoIiwiSW5maW5pdHkiLCJsIiwicyIsInB1c2giLCJ0IiwiYnVja2V0SW5kaWNhdG9yIiwidmFsdWVzIiwiYmFzZURhdGEiLCJidWNrZXRlZEVtYTIwIiwiYnVja2V0ZWRWb2xNQSIsImJ1Y2tldGVkQm9sbGluZ2VyQmFuZHMiLCJidWZmZXJQZXJSYW5nZSIsImJ1ZmZlckNhbmRsZXMiLCJtaW4iLCJmbG9vciIsImRpc3BsYXlEYXRhIiwid2luZG93SWR4Iiwic2V0V2luZG93SWR4Iiwid1N0YXJ0Iiwid0VuZCIsImZ1bGxTdGFydCIsImZ1bGxFbmQiLCJlZmZlY3RpdmVTdGFydCIsIm1heCIsImVmZmVjdGl2ZUVuZCIsInNhZmVFbmQiLCJzYWZlU3RhcnQiLCJkcmF3RGF0YSIsImluZGljYXRvclN0YXJ0IiwiaW5kaWNhdG9yRW5kIiwiZW1hMjAiLCJ2b2xNQSIsImJvbGxpbmdlckJhbmRzIiwiY2xvc2VzIiwiaGlnaHMiLCJsb3dzIiwicXVhbnRpbGUiLCJhcnIiLCJxIiwic29ydGVkIiwic29ydCIsImEiLCJiIiwicG9zIiwiYmFzZSIsInJlc3QiLCJ1bmRlZmluZWQiLCJsYXN0QyIsInNwYW4iLCJTIiwiQ0hBUlRfU0NBTEUiLCJoVmlzdWFsQmFzZSIsIkdSQVBIX0hFSUdIVCIsInZvbHVtZVBvcnRpb24iLCJoVmlzdWFsIiwidm9sSCIsInByaWNlSCIsImF4aXNGb290ZXIiLCJBWElTX0ZPT1RFUl9IRUlHSFQiLCJ3IiwiR1JBUEhfV0lEVEgiLCJndXR0ZXJSaWdodCIsIkFYSVNfUklHSFRfR1VUVEVSIiwicGFkVG9wIiwicGFkQm90dG9tIiwicGFkTGVmdCIsInByaWNlQXJlYSIsInVwIiwicHJpY2VXIiwibnVtQ2FuZGxlcyIsInhGb3JJZHgiLCJpZHgiLCJkcmF3VGltZXMiLCJEYXRlIiwiZ2V0VGltZSIsImNhbmRsZVdpZHRoIiwibGluZVB0cyIsIngiLCJ2YWwiLCJsb2cxMCIsInkiLCJqb2luIiwiaG92ZXJQb2ludCIsIm9uTW92ZSIsImUiLCJyZWN0IiwiY3VycmVudFRhcmdldCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFgiLCJsZWZ0IiwieFJhdGlvIiwid2lkdGgiLCJyb3VuZCIsImRyYWdTdGF0ZSIsIm9uV2hlZWwiLCJwcmV2ZW50RGVmYXVsdCIsImRlbHRhIiwiZGVsdGFZIiwiZmFjdG9yIiwiY3VycmVudExlbiIsIm5ld0xlbiIsImZvY3VzSWR4IiwibmV3U3RhcnQiLCJuZXdFbmQiLCJvblBvaW50ZXJEb3duIiwic2V0UG9pbnRlckNhcHR1cmUiLCJwb2ludGVySWQiLCJjdXJyZW50Iiwic3RhcnRYIiwic3RhcnRSYW5nZSIsIm9uUG9pbnRlck1vdmUiLCJlSWR4IiwibGVuIiwicGl4ZWxQZXJDYW5kbGUiLCJkZWx0YVB4Iiwic2hpZnQiLCJvblBvaW50ZXJVcCIsIm5pY2VUaWNrcyIsImxvdyIsImhpZ2giLCJyYXdTcGFuIiwicm91Z2hTdGVwIiwicG93MTAiLCJwb3ciLCJtdWx0aXBsZXMiLCJmb3VuZCIsImZpbmQiLCJtIiwic3RlcCIsImZpcnN0IiwidGlja3MiLCJ0aW1lVGlja3MiLCJzZWVuIiwiU2V0IiwiZm9yRWFjaCIsImhoIiwiZ2V0SG91cnMiLCJtbSIsImdldE1pbnV0ZXMiLCJ0aW1lS2V5IiwiaGFzIiwiYWRkIiwibGFiZWwiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJob3VyIiwibWludXRlIiwiaG91cjEyIiwiayIsInRvRGF0ZVN0cmluZyIsInRvTG9jYWxlRGF0ZVN0cmluZyIsIndlZWtkYXkiLCJ0b1VwcGVyQ2FzZSIsImdldERheSIsImtleSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwibW9uZGF5Q291bnQiLCJzZWVuTW9udGgiLCJtayIsInRvTG9jYWxlU3RyaW5nIiwibW9udGgiLCJzZWVuWWVhciIsIlN0cmluZyIsIm1heFZvbCIsIm1hZ25pdHVkZSIsImFicyIsImRlY2ltYWxzIiwicGVyaW9kIiwiQXJyYXkiLCJmaWxsIiwic3VtIiwic3RkRGV2TXVsdGlwbGllciIsImF2ZyIsInJlZHVjZSIsInZhcmlhbmNlIiwic3RkRGV2Iiwic3FydCIsImRpdiIsInN0eWxlIiwicG9zaXRpb24iLCJpbnNldCIsImZvbnRTaXplIiwic3ZnIiwidmlld0JveCIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJoZWlnaHQiLCJjdXJzb3IiLCJ1c2VyU2VsZWN0IiwiZm9udEZhbWlseSIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZUxlYXZlIiwiZyIsImxpbmUiLCJ4MSIsIngyIiwieTEiLCJ5MiIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwidGV4dCIsIkFYSVNfWV9MQUJFTF9YX09GRlNFVCIsIkFYSVNfWV9GT05UX1NJWkUiLCJ0b0ZpeGVkIiwicG9seWdvbiIsInBvaW50cyIsInVwcGVyVmFsIiwiaXNGaW5pdGUiLCJsb3dlclZhbCIsInBvbHlsaW5lIiwiZmlsdGVyIiwicCIsInZlY3RvckVmZmVjdCIsImNlbnRlclgiLCJ2YWxPcGVuIiwidmFsQ2xvc2UiLCJ2YWxIaWdoIiwidmFsTG93Iiwib3BlblkiLCJjbG9zZVkiLCJoaWdoWSIsImxvd1kiLCJyaXNpbmciLCJwY3QiLCJpbnRlbnNpdHkiLCJiYXNlQ29sb3IiLCJ2b2xSYXRpbyIsImJhckgiLCJtaW5CYXJIZWlnaHQiLCJjYW5kbGVEYXRlIiwidGltZUluTWludXRlcyIsIm1hcmtldE9wZW4iLCJtYXJrZXRDbG9zZSIsImlzRXh0ZW5kZWRIb3VycyIsIm9wYWNpdHkiLCJyYXRpbyIsInN0cm9rZURhc2hhcnJheSIsImNpcmNsZSIsImN4IiwiY3kiLCJyIiwibGFzdCIsImlzVXAiLCJicmlnaHRHcmVlbiIsImJyaWdodFJlZCIsImNvbG9yIiwiTEFTVF9QUklDRV9MQUJFTF9IRUlHSFQiLCJMQVNUX1BSSUNFX0xBQkVMX1dJRFRIIiwicngiLCJMQVNUX1BSSUNFX0xBQkVMX0ZPTlRfU0laRSIsInRleHRBbmNob3IiLCJmb250V2VpZ2h0IiwibGFiZWxzIiwibGFzdFByaWNlIiwicHJpY2VZIiwibGFzdEVtYSIsInZhbHVlIiwiYmdDb2xvciIsImxhc3RVcHBlciIsImxhc3RMb3dlciIsIm1pbkdhcCIsIklORElDQVRPUl9MQUJFTF9IRUlHSFQiLCJhZGp1c3RlZExhYmVscyIsImFkanVzdGVkWSIsIklORElDQVRPUl9MQUJFTF9XSURUSCIsIklORElDQVRPUl9MQUJFTF9GT05UX1NJWkUiLCJBWElTX1hfRk9OVF9TSVpFIiwiaG92ZXJYIiwiaG92ZXJYUGVyY2VudCIsImZsaXBMZWZ0IiwicmlnaHQiLCJ0b3AiLCJiYWNrZ3JvdW5kIiwicGFkZGluZyIsImJvcmRlclJhZGl1cyIsInBvaW50ZXJFdmVudHMiLCJib3JkZXIiLCJ3aGl0ZVNwYWNlIiwiYmFja2Ryb3BGaWx0ZXIiLCJ0cmFuc2Zvcm0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/dashboard/AdvancedPriceChart.tsx\n"));

/***/ })

});