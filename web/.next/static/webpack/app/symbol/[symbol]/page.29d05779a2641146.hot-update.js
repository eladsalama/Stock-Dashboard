"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/symbol/[symbol]/page",{

/***/ "(app-pages-browser)/./src/components/dashboard/AdvancedPriceChart.tsx":
/*!*********************************************************!*\
  !*** ./src/components/dashboard/AdvancedPriceChart.tsx ***!
  \*********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ AdvancedPriceChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _layoutConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layoutConfig */ \"(app-pages-browser)/./src/components/dashboard/layoutConfig.ts\");\n/* harmony import */ var _auth_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../auth-context/AuthContext */ \"(app-pages-browser)/./src/components/auth-context/AuthContext.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction AdvancedPriceChart(param) {\n    let { data, mode, range, logScale, showVolMA, showBollingerBands = false, showEMA20 = false, symbol } = param;\n    _s();\n    const { theme } = (0,_auth_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [hover, setHover] = react__WEBPACK_IMPORTED_MODULE_1___default().useState(null);\n    // Note: symbol prop defined but not used - chart is data-driven from parent's data prop\n    // Parent (DashboardClient) handles all data fetching via api.history()\n    // Backend already fetches the correct range, so we use sourceData directly\n    const sourceData = data || [];\n    const TARGET_PER_RANGE = {\n        \"1d\": 18,\n        \"1w\": 40,\n        \"1m\": 70,\n        \"3m\": 90,\n        \"1y\": 140,\n        \"5y\": 220\n    };\n    const target = TARGET_PER_RANGE[range] || 120;\n    let bucketSize = sourceData.length > target ? Math.ceil(sourceData.length / target) : 1;\n    if (range === \"1d\") bucketSize = 1; // never bucket intraday so ticks align with real times\n    // Calculate indicators on RAW sourceData BEFORE bucketing for maximum accuracy\n    const rawEma20 = showEMA20 ? ema(sourceData.map((d)=>d.c), 20) : [];\n    const rawVolMA = showVolMA ? sma(sourceData.map((d)=>d.v), 20) : [];\n    const rawBollingerBands = showBollingerBands ? calculateBollingerBands(sourceData.map((d)=>d.c)) : {\n        upper: [],\n        lower: [],\n        middle: []\n    };\n    function bucketAggregate(src, size) {\n        if (size <= 1) return src;\n        const out = [];\n        for(let i = 0; i < src.length; i += size){\n            const slice = src.slice(i, i + size);\n            if (!slice.length) continue;\n            const o = slice[0].o;\n            const c = slice[slice.length - 1].c;\n            let h = -Infinity, l = Infinity, v = 0;\n            for (const s of slice){\n                if (s.h > h) h = s.h;\n                if (s.l < l) l = s.l;\n                v += s.v;\n            }\n            out.push({\n                t: slice[0].t,\n                o,\n                h,\n                l,\n                c,\n                v\n            });\n        }\n        return out;\n    }\n    // Bucket indicators alongside the data (take every Nth value to match bucketing)\n    function bucketIndicator(values, size) {\n        if (size <= 1) return values;\n        const out = [];\n        for(let i = 0; i < values.length; i += size){\n            out.push(values[i]); // Take the first value of each bucket\n        }\n        return out;\n    }\n    const baseData = bucketSize === 1 ? sourceData : bucketAggregate(sourceData, bucketSize);\n    const bucketedEma20 = bucketSize === 1 ? rawEma20 : bucketIndicator(rawEma20, bucketSize);\n    const bucketedVolMA = bucketSize === 1 ? rawVolMA : bucketIndicator(rawVolMA, bucketSize);\n    const bucketedBollingerBands = bucketSize === 1 ? rawBollingerBands : {\n        upper: bucketIndicator(rawBollingerBands.upper, bucketSize),\n        lower: bucketIndicator(rawBollingerBands.lower, bucketSize),\n        middle: bucketIndicator(rawBollingerBands.middle, bucketSize)\n    };\n    // Backend fetches extra candles for indicator calculation (20-50 depending on range)\n    // After bucketing, we hide proportionally fewer candles\n    const bufferPerRange = {\n        \"1d\": 50,\n        \"1w\": 50,\n        \"1m\": 50,\n        \"3m\": 50,\n        \"1y\": 50,\n        \"5y\": 50\n    };\n    const bufferCandles = Math.min(bufferPerRange[range], Math.floor(baseData.length * 0.2));\n    const displayData = baseData.slice(bufferCandles); // Hide first candles from user\n    const [windowIdx, setWindowIdx] = react__WEBPACK_IMPORTED_MODULE_1___default().useState(()=>[\n            0,\n            displayData.length - 1\n        ]);\n    // Reset window when displayData length changes (range change or new data)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setWindowIdx([\n            0,\n            displayData.length - 1\n        ]);\n    }, [\n        displayData.length\n    ]);\n    // Always show full range unless user zooms/pans (windowIdx acts as user override after first wheel/drag)\n    const [wStart, wEnd] = windowIdx;\n    const fullStart = 0;\n    const fullEnd = displayData.length - 1;\n    const effectiveStart = wStart === 0 && wEnd === displayData.length - 1 ? fullStart : Math.max(0, Math.min(wStart, fullEnd));\n    const effectiveEnd = wStart === 0 && wEnd === displayData.length - 1 ? fullEnd : Math.min(wEnd, fullEnd);\n    const safeEnd = Math.min(effectiveEnd, displayData.length - 1);\n    const safeStart = Math.max(0, Math.min(effectiveStart, safeEnd - 5));\n    const drawData = displayData.slice(safeStart, safeEnd + 1);\n    // Slice pre-calculated indicators to match drawData (offset by buffer + window)\n    const indicatorStart = bufferCandles + safeStart;\n    const indicatorEnd = bufferCandles + safeEnd + 1;\n    const ema20 = bucketedEma20.slice(indicatorStart, indicatorEnd);\n    const volMA = bucketedVolMA.slice(indicatorStart, indicatorEnd);\n    const bollingerBands = {\n        upper: bucketedBollingerBands.upper.slice(indicatorStart, indicatorEnd),\n        lower: bucketedBollingerBands.lower.slice(indicatorStart, indicatorEnd),\n        middle: bucketedBollingerBands.middle.slice(indicatorStart, indicatorEnd)\n    };\n    const closes = drawData.map((d)=>d.c), highs = drawData.map((d)=>d.h), lows = drawData.map((d)=>d.l);\n    function quantile(arr, q) {\n        if (!arr.length) return 0;\n        const sorted = [\n            ...arr\n        ].sort((a, b)=>a - b);\n        const pos = (sorted.length - 1) * q;\n        const base = Math.floor(pos);\n        const rest = pos - base;\n        return sorted[base + 1] !== undefined ? sorted[base] + rest * (sorted[base + 1] - sorted[base]) : sorted[base];\n    }\n    let min = quantile(lows, 0.005), max = quantile(highs, 0.995);\n    const lastC = drawData[drawData.length - 1];\n    if (lastC) {\n        if (lastC.l < min) min = lastC.l;\n        if (lastC.h > max) max = lastC.h;\n    }\n    const span = max - min || 1;\n    // Single scale variable\n    const S = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.CHART_SCALE; // affects vertical real estate\n    const hVisualBase = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.GRAPH_HEIGHT; // baseline visual height from config\n    const volumePortion = 0.23; // fraction reserved for volume area\n    const hVisual = hVisualBase * S;\n    const volH = hVisual * volumePortion;\n    const priceH = hVisual - volH;\n    const axisFooter = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_FOOTER_HEIGHT;\n    const h = hVisual + axisFooter;\n    const w = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.GRAPH_WIDTH;\n    const gutterRight = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_RIGHT_GUTTER;\n    const padTop = 8, padBottom = 6, padLeft = 4;\n    const priceArea = priceH - padTop - padBottom;\n    const up = closes[closes.length - 1] >= closes[0];\n    const priceW = w - gutterRight - padLeft;\n    // Index-based horizontal scale (removes time gaps for continuous display)\n    const numCandles = drawData.length;\n    function xForIdx(idx) {\n        return padLeft + idx / Math.max(1, numCandles - 1) * priceW;\n    }\n    // Store timestamps for labels\n    const drawTimes = drawData.map((d)=>new Date(d.t).getTime());\n    // Adaptive candle width from data density\n    let candleWidth;\n    if (numCandles <= 2) {\n        candleWidth = priceW / Math.max(1, numCandles) * 0.6;\n    } else {\n        candleWidth = priceW / numCandles * 0.8;\n    }\n    if (candleWidth < 3) candleWidth = 3;\n    if (candleWidth > 22) candleWidth = 22;\n    const linePts = drawData.map((d, idx)=>{\n        const x = xForIdx(idx);\n        const val = logScale ? (Math.log10(d.c) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (d.c - min) / span;\n        const y = padTop + (priceArea - val * priceArea);\n        return \"\".concat(x, \",\").concat(y);\n    }).join(\" \");\n    const hoverPoint = hover != null ? drawData[hover] : null;\n    function onMove(e) {\n        const rect = e.currentTarget.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        // Index-based hover: find nearest candle by x position\n        if (drawData.length === 0) return;\n        const xRatio = Math.max(0, Math.min(1, (x - padLeft) / (rect.width - gutterRight / w * rect.width)));\n        const idx = Math.round(xRatio * (numCandles - 1));\n        setHover(Math.max(0, Math.min(numCandles - 1, idx)));\n    }\n    const dragState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    function onWheel(e) {\n        e.preventDefault();\n        if (drawData.length < 10) return;\n        const delta = e.deltaY;\n        const factor = delta > 0 ? 1.1 : 0.9;\n        const currentLen = wEnd - wStart + 1;\n        const newLen = Math.max(20, Math.min(displayData.length, Math.round(currentLen * factor)));\n        const rect = e.currentTarget.getBoundingClientRect();\n        const xRatio = (e.clientX - rect.left - padLeft) / (rect.width - gutterRight);\n        const focusIdx = wStart + Math.round(currentLen * xRatio);\n        let newStart = focusIdx - Math.round(newLen * xRatio);\n        let newEnd = newStart + newLen - 1;\n        if (newStart < 0) {\n            newStart = 0;\n            newEnd = newLen - 1;\n        }\n        if (newEnd > displayData.length - 1) {\n            newEnd = displayData.length - 1;\n            newStart = newEnd - newLen + 1;\n        }\n        setWindowIdx([\n            newStart,\n            newEnd\n        ]);\n    }\n    function onPointerDown(e) {\n        e.currentTarget.setPointerCapture(e.pointerId);\n        dragState.current = {\n            startX: e.clientX,\n            startRange: windowIdx\n        };\n    }\n    function onPointerMove(e) {\n        if (!dragState.current) return;\n        const [s, eIdx] = dragState.current.startRange;\n        const len = eIdx - s + 1;\n        const pixelPerCandle = priceW / drawData.length;\n        const deltaPx = e.clientX - dragState.current.startX;\n        const shift = Math.round(-deltaPx / pixelPerCandle);\n        let newStart = s + shift;\n        let newEnd = newStart + len - 1;\n        if (newStart < 0) {\n            newStart = 0;\n            newEnd = len - 1;\n        }\n        if (newEnd > displayData.length - 1) {\n            newEnd = displayData.length - 1;\n            newStart = newEnd - len + 1;\n        }\n        setWindowIdx([\n            newStart,\n            newEnd\n        ]);\n    }\n    function onPointerUp() {\n        dragState.current = null;\n    }\n    function niceTicks(low, high) {\n        let target = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5;\n        const rawSpan = high - low || 1;\n        const roughStep = rawSpan / (target - 1);\n        const pow10 = Math.pow(10, Math.floor(Math.log10(roughStep)));\n        const multiples = [\n            1,\n            2,\n            2.5,\n            5,\n            10\n        ];\n        const found = multiples.find((m)=>m * pow10 >= roughStep) || multiples[multiples.length - 1];\n        const step = found * pow10;\n        const first = Math.ceil(low / step) * step;\n        const ticks = [];\n        for(let v = first; v <= high; v += step)ticks.push(v);\n        return ticks;\n    }\n    // Time ticks per explicit spec\n    const timeTicks = [];\n    if (drawData.length > 1) {\n        if (range === \"1d\") {\n            // Show label every hour for cleaner display\n            const seen = new Set();\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                const hh = d.getHours();\n                const mm = d.getMinutes();\n                // Show label every hour on the hour\n                if (mm === 0) {\n                    const timeKey = \"\".concat(hh, \":00\");\n                    if (!seen.has(timeKey)) {\n                        seen.add(timeKey);\n                        timeTicks.push({\n                            x: xForIdx(idx),\n                            label: d.toLocaleTimeString(\"en-US\", {\n                                hour: \"numeric\",\n                                minute: \"2-digit\",\n                                hour12: false\n                            })\n                        });\n                    }\n                }\n            });\n        } else if (range === \"1w\") {\n            const seen = new Set();\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                const k = d.toDateString();\n                if (!seen.has(k)) {\n                    seen.add(k);\n                    timeTicks.push({\n                        x: xForIdx(idx),\n                        label: d.toLocaleDateString(undefined, {\n                            weekday: \"short\"\n                        }).toUpperCase()\n                    });\n                }\n            });\n        } else if (range === \"1m\") {\n            const seen = new Set();\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                if (d.getDay() === 1) {\n                    const key = d.getFullYear() + \"-\" + d.getMonth() + \"-\" + d.getDate();\n                    if (!seen.has(key)) {\n                        seen.add(key);\n                        timeTicks.push({\n                            x: xForIdx(idx),\n                            label: d.getMonth() + 1 + \"/\" + d.getDate()\n                        });\n                    }\n                }\n            });\n        } else if (range === \"3m\") {\n            let mondayCount = 0;\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                if (d.getDay() === 1) {\n                    if (mondayCount % 3 === 0) timeTicks.push({\n                        x: xForIdx(idx),\n                        label: d.getMonth() + 1 + \"/\" + d.getDate()\n                    });\n                    mondayCount++;\n                }\n            });\n        } else if (range === \"1y\") {\n            const seenMonth = new Set();\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                const mk = d.getFullYear() + \"-\" + d.getMonth();\n                if (!seenMonth.has(mk) && d.getDate() <= 7) {\n                    seenMonth.add(mk);\n                    timeTicks.push({\n                        x: xForIdx(idx),\n                        label: d.toLocaleString(undefined, {\n                            month: \"short\"\n                        }).toUpperCase()\n                    });\n                }\n            });\n        } else if (range === \"5y\") {\n            const seenYear = new Set();\n            drawData.forEach((c, idx)=>{\n                const d = new Date(c.t);\n                if (!seenYear.has(d.getFullYear()) && d.getMonth() < 2) {\n                    seenYear.add(d.getFullYear());\n                    timeTicks.push({\n                        x: xForIdx(idx),\n                        label: String(d.getFullYear())\n                    });\n                }\n            });\n        }\n    }\n    const maxVol = Math.max(...drawData.map((d)=>d.v), 1);\n    const magnitude = Math.abs(max);\n    const decimals = magnitude >= 500 ? 0 : magnitude >= 100 ? 1 : 2;\n    function sma(src, period) {\n        if (src.length < period) return [];\n        const out = new Array(period - 1).fill(null); // Pad beginning with nulls\n        let sum = 0;\n        for(let i = 0; i < src.length; i++){\n            sum += src[i];\n            if (i >= period) sum -= src[i - period];\n            if (i >= period - 1) out.push(sum / period);\n        }\n        return out;\n    }\n    function ema(src, period) {\n        if (src.length < period) return [];\n        const k = 2 / (period + 1);\n        const out = new Array(period - 1).fill(null); // Pad beginning with nulls\n        // Start with SMA for first value\n        let sum = 0;\n        for(let i = 0; i < period; i++){\n            sum += src[i];\n        }\n        out.push(sum / period);\n        // Then use EMA formula\n        for(let i = period; i < src.length; i++){\n            out.push(src[i] * k + out[out.length - 1] * (1 - k));\n        }\n        return out;\n    }\n    function calculateBollingerBands(closes) {\n        let period = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20, stdDevMultiplier = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n        if (closes.length < period) return {\n            upper: [],\n            lower: [],\n            middle: []\n        };\n        const middle = new Array(period - 1).fill(null);\n        const upper = new Array(period - 1).fill(null);\n        const lower = new Array(period - 1).fill(null);\n        for(let i = period - 1; i < closes.length; i++){\n            const slice = closes.slice(i - period + 1, i + 1);\n            const avg = slice.reduce((sum, val)=>sum + val, 0) / period;\n            const variance = slice.reduce((sum, val)=>sum + Math.pow(val - avg, 2), 0) / period;\n            const stdDev = Math.sqrt(variance);\n            middle.push(avg);\n            upper.push(avg + stdDevMultiplier * stdDev);\n            lower.push(avg - stdDevMultiplier * stdDev);\n        }\n        return {\n            upper,\n            lower,\n            middle\n        };\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            position: \"absolute\",\n            inset: 0,\n            fontSize: 11\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                viewBox: \"0 0 \".concat(w, \" \").concat(h),\n                preserveAspectRatio: \"none\",\n                style: {\n                    width: \"100%\",\n                    height: \"100%\",\n                    cursor: \"crosshair\",\n                    userSelect: \"none\",\n                    fontFamily: \"system-ui, ui-monospace, Menlo, monospace\"\n                },\n                onMouseMove: onMove,\n                onMouseLeave: ()=>setHover(null),\n                onWheel: onWheel,\n                onPointerDown: onPointerDown,\n                onPointerMove: onPointerMove,\n                onPointerUp: onPointerUp,\n                children: [\n                    niceTicks(min, max, 5).map((t)=>{\n                        const y = 8 + (priceArea - (t - min) / span * priceArea);\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                    x1: padLeft,\n                                    x2: padLeft + priceW,\n                                    y1: y,\n                                    y2: y,\n                                    stroke: theme === \"light\" ? \"#d0d7de\" : \"#30363d\",\n                                    strokeWidth: 1\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 392,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                                    x: padLeft + priceW + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_Y_LABEL_X_OFFSET,\n                                    y: y + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_Y_FONT_SIZE / 3,\n                                    fill: theme === \"light\" ? \"#000000\" : \"#ffffff\",\n                                    fontSize: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_Y_FONT_SIZE,\n                                    children: t.toFixed(decimals)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 400,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, t.toFixed(6), true, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 391,\n                            columnNumber: 13\n                        }, this);\n                    }),\n                    timeTicks.map((t, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                            x1: t.x,\n                            x2: t.x,\n                            y1: 0,\n                            y2: hVisual,\n                            stroke: theme === \"light\" ? \"#d0d7de\" : \"#30363d\",\n                            strokeWidth: 1\n                        }, \"xtick-\" + i, false, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 414,\n                            columnNumber: 11\n                        }, this)),\n                    showBollingerBands && bollingerBands.upper.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polygon\", {\n                                points: (()=>{\n                                    const points = [];\n                                    // Upper band\n                                    for(let i = 0; i < bollingerBands.upper.length; i++){\n                                        const upperVal = bollingerBands.upper[i];\n                                        if (upperVal === null) continue;\n                                        const x = xForIdx(i);\n                                        const val = (upperVal - min) / span;\n                                        const y = padTop + (priceArea - val * priceArea);\n                                        if (isFinite(x) && isFinite(y)) {\n                                            points.push(\"\".concat(x, \",\").concat(y));\n                                        }\n                                    }\n                                    // Lower band (reversed)\n                                    for(let i = bollingerBands.lower.length - 1; i >= 0; i--){\n                                        const lowerVal = bollingerBands.lower[i];\n                                        if (lowerVal === null) continue;\n                                        const x = xForIdx(i);\n                                        const val = (lowerVal - min) / span;\n                                        const y = padTop + (priceArea - val * priceArea);\n                                        if (isFinite(x) && isFinite(y)) {\n                                            points.push(\"\".concat(x, \",\").concat(y));\n                                        }\n                                    }\n                                    return points.join(\" \");\n                                })(),\n                                fill: \"rgba(135, 206, 235, 0.15)\",\n                                stroke: \"none\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                lineNumber: 429,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polyline\", {\n                                points: bollingerBands.upper.map((v, i)=>{\n                                    if (v === null) return null;\n                                    const x = xForIdx(i);\n                                    const val = (v - min) / span;\n                                    const y = padTop + (priceArea - val * priceArea);\n                                    return \"\".concat(x, \",\").concat(y);\n                                }).filter((p)=>p !== null).join(\" \"),\n                                fill: \"none\",\n                                stroke: \"rgba(135, 206, 235, 0.8)\",\n                                strokeWidth: 1,\n                                vectorEffect: \"non-scaling-stroke\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                lineNumber: 461,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polyline\", {\n                                points: bollingerBands.lower.map((v, i)=>{\n                                    if (v === null) return null;\n                                    const x = xForIdx(i);\n                                    const val = (v - min) / span;\n                                    const y = padTop + (priceArea - val * priceArea);\n                                    return \"\".concat(x, \",\").concat(y);\n                                }).filter((p)=>p !== null).join(\" \"),\n                                fill: \"none\",\n                                stroke: \"rgba(135, 206, 235, 0.8)\",\n                                strokeWidth: 1,\n                                vectorEffect: \"non-scaling-stroke\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                lineNumber: 479,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true),\n                    mode === \"line\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polyline\", {\n                        points: linePts,\n                        fill: \"none\",\n                        stroke: up ? \"var(--color-success)\" : \"var(--color-danger)\",\n                        strokeWidth: 2,\n                        vectorEffect: \"non-scaling-stroke\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                        lineNumber: 498,\n                        columnNumber: 11\n                    }, this),\n                    mode === \"candles\" && drawData.map((d, idx)=>{\n                        const centerX = xForIdx(idx);\n                        const x = centerX - candleWidth / 2;\n                        const valOpen = logScale ? (Math.log10(d.o) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (d.o - min) / span;\n                        const valClose = logScale ? (Math.log10(d.c) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (d.c - min) / span;\n                        const valHigh = logScale ? (Math.log10(d.h) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (d.h - min) / span;\n                        const valLow = logScale ? (Math.log10(d.l) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (d.l - min) / span;\n                        const openY = 8 + (priceArea - valOpen * priceArea);\n                        const closeY = 8 + (priceArea - valClose * priceArea);\n                        const highY = 8 + (priceArea - valHigh * priceArea);\n                        const lowY = 8 + (priceArea - valLow * priceArea);\n                        const rising = d.c >= d.o;\n                        const pct = Math.min(0.05, Math.max(-0.05, (d.c - d.o) / d.o));\n                        const intensity = Math.abs(pct) / 0.05;\n                        const baseColor = rising ? \"var(--color-success)\" : \"var(--color-danger)\";\n                        const fill = rising ? \"rgba(35,134,54,\".concat(0.35 + 0.55 * intensity, \")\") : \"rgba(248,81,73,\".concat(0.35 + 0.55 * intensity, \")\");\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                    x1: x + candleWidth / 2,\n                                    x2: x + candleWidth / 2,\n                                    y1: highY,\n                                    y2: lowY,\n                                    stroke: baseColor,\n                                    strokeWidth: 1\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 535,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                                    x: x,\n                                    y: Math.min(openY, closeY),\n                                    width: candleWidth,\n                                    height: Math.max(2, Math.abs(closeY - openY)),\n                                    fill: fill,\n                                    stroke: baseColor,\n                                    strokeWidth: 0.5\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 543,\n                                    columnNumber: 17\n                                }, this)\n                            ]\n                        }, d.t, true, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 534,\n                            columnNumber: 15\n                        }, this);\n                    }),\n                    showEMA20 && ema20.length && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polyline\", {\n                        points: ema20.map((v, i)=>{\n                            if (v === null) return null;\n                            const x = xForIdx(i);\n                            const val = logScale ? (Math.log10(v) - Math.log10(min)) / (Math.log10(max) - Math.log10(min || 1)) : (v - min) / span;\n                            const y = 8 + (priceArea - val * priceArea);\n                            return \"\".concat(x, \",\").concat(y);\n                        }).filter((p)=>p !== null).join(\" \"),\n                        fill: \"none\",\n                        stroke: \"#ff9500\",\n                        strokeWidth: 1.4,\n                        vectorEffect: \"non-scaling-stroke\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                        lineNumber: 558,\n                        columnNumber: 11\n                    }, this),\n                    drawData.map((d, idx)=>{\n                        const centerX = xForIdx(idx);\n                        const x = centerX - candleWidth / 2;\n                        const volRatio = d.v / maxVol;\n                        let barH = volRatio * (volH - 16);\n                        // Minimum bar height for visibility (especially for low after-hours volume)\n                        const minBarHeight = 2;\n                        if (barH > 0 && barH < minBarHeight) barH = minBarHeight;\n                        const y = priceH + (volH - barH);\n                        const rising = d.c >= d.o;\n                        // Check if this is extended hours (before 9:30 or after 16:00 ET)\n                        const candleDate = new Date(d.t);\n                        const hour = candleDate.getHours();\n                        const minute = candleDate.getMinutes();\n                        const timeInMinutes = hour * 60 + minute;\n                        const marketOpen = 9 * 60 + 30; // 9:30 AM\n                        const marketClose = 16 * 60; // 4:00 PM\n                        const isExtendedHours = timeInMinutes < marketOpen || timeInMinutes >= marketClose;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                            x: x,\n                            y: y,\n                            width: candleWidth,\n                            height: barH,\n                            fill: rising ? \"var(--color-success)\" : \"var(--color-danger)\",\n                            opacity: isExtendedHours ? 0.2 : 0.35\n                        }, d.t + \":vol\", false, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 601,\n                            columnNumber: 13\n                        }, this);\n                    }),\n                    showVolMA && volMA.length && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polyline\", {\n                        points: volMA.map((v, i)=>{\n                            if (v === null) return null;\n                            const x = xForIdx(i);\n                            const ratio = v / maxVol;\n                            const barH = ratio * (volH - 16);\n                            const y = priceH + (volH - barH);\n                            return \"\".concat(x, \",\").concat(y);\n                        }).filter((p)=>p !== null).join(\" \"),\n                        fill: \"none\",\n                        stroke: \"#58a6ff\",\n                        strokeWidth: 1,\n                        vectorEffect: \"non-scaling-stroke\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                        lineNumber: 613,\n                        columnNumber: 11\n                    }, this),\n                    hoverPoint && (()=>{\n                        const x = xForIdx(hover);\n                        const y = 8 + (priceArea - (hoverPoint.c - min) / span * priceArea);\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                    x1: x,\n                                    x2: x,\n                                    y1: 0,\n                                    y2: priceH,\n                                    stroke: theme === \"light\" ? \"#656d76\" : \"#7d8590\",\n                                    strokeDasharray: \"4 3\",\n                                    strokeWidth: 1\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 637,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                    x1: 0,\n                                    x2: w,\n                                    y1: y,\n                                    y2: y,\n                                    stroke: theme === \"light\" ? \"#656d76\" : \"#7d8590\",\n                                    strokeDasharray: \"4 3\",\n                                    strokeWidth: 1\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 646,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    cx: x,\n                                    cy: y,\n                                    r: 5,\n                                    fill: \"var(--color-bg)\",\n                                    stroke: up ? \"var(--color-success)\" : \"var(--color-danger)\",\n                                    strokeWidth: 2\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 655,\n                                    columnNumber: 17\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 636,\n                            columnNumber: 15\n                        }, this);\n                    })(),\n                    drawData.length > 0 && (()=>{\n                        const last = drawData[drawData.length - 1];\n                        const y = 8 + (priceArea - (last.c - min) / span * priceArea);\n                        const isUp = last.c >= closes[0];\n                        // Brighter, higher contrast colors for last price label\n                        const brightGreen = \"#00ff41\"; // Bright neon green\n                        const brightRed = \"#ff3366\"; // Bright red\n                        const color = isUp ? brightGreen : brightRed;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"line\", {\n                                    x1: padLeft,\n                                    x2: padLeft + priceW,\n                                    y1: y,\n                                    y2: y,\n                                    stroke: color,\n                                    strokeDasharray: \"2 4\",\n                                    strokeWidth: 1\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 678,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                                    x: padLeft + priceW + 4,\n                                    y: y - _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_HEIGHT / 2,\n                                    width: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_WIDTH,\n                                    height: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_HEIGHT,\n                                    fill: isUp ? theme === \"light\" ? \"#e6fff0\" : \"#002211\" : theme === \"light\" ? \"#ffe6ee\" : \"#2d0011\",\n                                    stroke: color,\n                                    rx: 3\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 687,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                                    x: padLeft + priceW + 4 + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_WIDTH / 2,\n                                    y: y + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_FONT_SIZE / 3,\n                                    textAnchor: \"middle\",\n                                    fill: color,\n                                    fontSize: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.LAST_PRICE_LABEL_FONT_SIZE,\n                                    fontWeight: 600,\n                                    children: last.c.toFixed(decimals)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                    lineNumber: 698,\n                                    columnNumber: 17\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 677,\n                            columnNumber: 15\n                        }, this);\n                    })(),\n                    (()=>{\n                        var _drawData_;\n                        const labels = [];\n                        // Main price position\n                        const lastPrice = ((_drawData_ = drawData[drawData.length - 1]) === null || _drawData_ === void 0 ? void 0 : _drawData_.c) || 0;\n                        const priceY = 8 + (priceArea - (lastPrice - min) / span * priceArea);\n                        // EMA20\n                        if (showEMA20 && ema20.length > 0) {\n                            const lastEma = ema20[ema20.length - 1];\n                            if (lastEma !== null) {\n                                labels.push({\n                                    y: 8 + (priceArea - (lastEma - min) / span * priceArea),\n                                    value: lastEma,\n                                    color: \"#ff9500\",\n                                    bgColor: theme === \"light\" ? \"#fff5e6\" : \"#2d2400\",\n                                    stroke: \"#ff9500\"\n                                });\n                            }\n                        }\n                        // Bollinger Bands Upper\n                        if (showBollingerBands && bollingerBands.upper.length > 0) {\n                            const lastUpper = bollingerBands.upper[bollingerBands.upper.length - 1];\n                            if (lastUpper !== null) {\n                                labels.push({\n                                    y: 8 + (priceArea - (lastUpper - min) / span * priceArea),\n                                    value: lastUpper,\n                                    color: \"rgba(135, 206, 235, 1)\",\n                                    bgColor: theme === \"light\" ? \"#e6f7ff\" : \"#001a2d\",\n                                    stroke: \"rgba(135, 206, 235, 0.8)\"\n                                });\n                            }\n                        }\n                        // Bollinger Bands Lower\n                        if (showBollingerBands && bollingerBands.lower.length > 0) {\n                            const lastLower = bollingerBands.lower[bollingerBands.lower.length - 1];\n                            if (lastLower !== null) {\n                                labels.push({\n                                    y: 8 + (priceArea - (lastLower - min) / span * priceArea),\n                                    value: lastLower,\n                                    color: \"rgba(135, 206, 235, 1)\",\n                                    bgColor: theme === \"light\" ? \"#e6f7ff\" : \"#001a2d\",\n                                    stroke: \"rgba(135, 206, 235, 0.8)\"\n                                });\n                            }\n                        }\n                        // Adjust positions to avoid overlaps\n                        const minGap = _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_HEIGHT + 2;\n                        const adjustedLabels = labels.map((label)=>{\n                            let adjustedY = label.y;\n                            // Check overlap with main price label\n                            if (Math.abs(adjustedY - priceY) < minGap) {\n                                // Move above or below based on which side has more space\n                                if (adjustedY < priceY) {\n                                    // Label is above price, move it further up\n                                    adjustedY = priceY - minGap;\n                                } else {\n                                    // Label is below price, move it further down\n                                    adjustedY = priceY + minGap;\n                                }\n                            }\n                            return {\n                                ...label,\n                                y: adjustedY\n                            };\n                        });\n                        // Sort by Y position and adjust for overlaps between indicators\n                        adjustedLabels.sort((a, b)=>a.y - b.y);\n                        for(let i = 1; i < adjustedLabels.length; i++){\n                            if (adjustedLabels[i].y - adjustedLabels[i - 1].y < minGap) {\n                                adjustedLabels[i].y = adjustedLabels[i - 1].y + minGap;\n                            }\n                        }\n                        return adjustedLabels.map((label, idx)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                                        x: padLeft + priceW + 4,\n                                        y: label.y - _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_HEIGHT / 2,\n                                        width: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_WIDTH,\n                                        height: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_HEIGHT,\n                                        fill: label.bgColor,\n                                        stroke: label.stroke,\n                                        rx: 2\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                        lineNumber: 792,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                                        x: padLeft + priceW + 4 + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_WIDTH / 2,\n                                        y: label.y + _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_FONT_SIZE / 3,\n                                        textAnchor: \"middle\",\n                                        fill: label.color,\n                                        fontSize: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.INDICATOR_LABEL_FONT_SIZE,\n                                        fontWeight: 600,\n                                        children: label.value.toFixed(decimals)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                        lineNumber: 801,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, \"indicator-label-\".concat(idx), true, {\n                                fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                                lineNumber: 791,\n                                columnNumber: 13\n                            }, this));\n                    })(),\n                    timeTicks.map((t, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                            x: t.x,\n                            y: h - 6,\n                            textAnchor: \"middle\",\n                            fontSize: _layoutConfig__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.AXIS_X_FONT_SIZE,\n                            fill: theme === \"light\" ? \"#000000\" : \"#ffffff\",\n                            children: t.label\n                        }, \"xlabel-\" + i, false, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 816,\n                            columnNumber: 11\n                        }, this))\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                lineNumber: 371,\n                columnNumber: 7\n            }, this),\n            hoverPoint && (()=>{\n                const hoverX = xForIdx(hover);\n                const hoverXPercent = (hoverX - padLeft) / priceW * 100;\n                // Simple boundary check: if near edges, adjust positioning\n                // Near right edge (> 85%) - anchor to right of hover point\n                // Near left edge (< 15%) - anchor to left of hover point\n                // Otherwise center on hover point\n                let leftPos;\n                let rightPos;\n                let transform;\n                if (hoverXPercent > 85) {\n                    // Near right edge - tooltip opens to the left\n                    leftPos = \"\".concat(hoverXPercent, \"%\");\n                    transform = \"translateX(-100%)\";\n                } else if (hoverXPercent < 15) {\n                    // Near left edge - tooltip opens to the right\n                    leftPos = \"\".concat(hoverXPercent, \"%\");\n                    transform = \"translateX(0)\";\n                } else {\n                    // Center on hover point (default)\n                    leftPos = \"\".concat(hoverXPercent, \"%\");\n                    transform = \"translateX(-50%)\";\n                }\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        position: \"absolute\",\n                        left: leftPos,\n                        right: rightPos,\n                        top: 8,\n                        background: theme === \"light\" ? \"rgba(255,255,255,0.95)\" : \"rgba(0,0,0,0.78)\",\n                        padding: \"6px 8px\",\n                        borderRadius: 4,\n                        pointerEvents: \"none\",\n                        border: theme === \"light\" ? \"1px solid #d0d7de\" : \"1px solid #30363d\",\n                        whiteSpace: \"nowrap\",\n                        backdropFilter: \"blur(2px)\",\n                        color: theme === \"light\" ? \"#24292f\" : \"#e6edf3\",\n                        transform\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontSize: 11,\n                                opacity: 0.7\n                            },\n                            children: new Date(hoverPoint.t).toLocaleString()\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 873,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: 600\n                            },\n                            children: hoverPoint.c.toFixed(2)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                            lineNumber: 876,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n                    lineNumber: 856,\n                    columnNumber: 11\n                }, this);\n            })()\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\salam\\\\Visual Studio Code\\\\Stock Dashboard\\\\web\\\\src\\\\components\\\\dashboard\\\\AdvancedPriceChart.tsx\",\n        lineNumber: 370,\n        columnNumber: 5\n    }, this);\n}\n_s(AdvancedPriceChart, \"lHy/StbT2zLTwfx1ruRUmtw45WE=\", false, function() {\n    return [\n        _auth_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth\n    ];\n});\n_c = AdvancedPriceChart;\nvar _c;\n$RefreshReg$(_c, \"AdvancedPriceChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Rhc2hib2FyZC9BZHZhbmNlZFByaWNlQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQ2lEO0FBRUg7QUFDUTtBQXFCdkMsU0FBU0ssbUJBQW1CLEtBU25DO1FBVG1DLEVBQ3pDQyxJQUFJLEVBQ0pDLElBQUksRUFDSkMsS0FBSyxFQUNMQyxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMscUJBQXFCLEtBQUssRUFDMUJDLFlBQVksS0FBSyxFQUNqQkMsTUFBTSxFQUNBLEdBVG1DOztJQVV6QyxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHVixrRUFBT0E7SUFDekIsTUFBTSxDQUFDVyxPQUFPQyxTQUFTLEdBQUdoQixxREFBYyxDQUFnQjtJQUV4RCx3RkFBd0Y7SUFDeEYsdUVBQXVFO0lBQ3ZFLDJFQUEyRTtJQUUzRSxNQUFNa0IsYUFBdUJaLFFBQVEsRUFBRTtJQUV2QyxNQUFNYSxtQkFBNkM7UUFDakQsTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO1FBQ04sTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO0lBQ1I7SUFDQSxNQUFNQyxTQUFTRCxnQkFBZ0IsQ0FBQ1gsTUFBTSxJQUFJO0lBQzFDLElBQUlhLGFBQWFILFdBQVdJLE1BQU0sR0FBR0YsU0FBU0csS0FBS0MsSUFBSSxDQUFDTixXQUFXSSxNQUFNLEdBQUdGLFVBQVU7SUFDdEYsSUFBSVosVUFBVSxNQUFNYSxhQUFhLEdBQUcsdURBQXVEO0lBRTNGLCtFQUErRTtJQUMvRSxNQUFNSSxXQUFXYixZQUFZYyxJQUFJUixXQUFXUyxHQUFHLENBQUMsQ0FBQ0MsSUFBY0EsRUFBRUMsQ0FBQyxHQUFHLE1BQU0sRUFBRTtJQUM3RSxNQUFNQyxXQUFXcEIsWUFBWXFCLElBQUliLFdBQVdTLEdBQUcsQ0FBQyxDQUFDQyxJQUFjQSxFQUFFSSxDQUFDLEdBQUcsTUFBTSxFQUFFO0lBQzdFLE1BQU1DLG9CQUFvQnRCLHFCQUN0QnVCLHdCQUF3QmhCLFdBQVdTLEdBQUcsQ0FBQyxDQUFDQyxJQUFjQSxFQUFFQyxDQUFDLEtBQ3pEO1FBQUVNLE9BQU8sRUFBRTtRQUFFQyxPQUFPLEVBQUU7UUFBRUMsUUFBUSxFQUFFO0lBQUM7SUFFdkMsU0FBU0MsZ0JBQWdCQyxHQUFhLEVBQUVDLElBQVk7UUFDbEQsSUFBSUEsUUFBUSxHQUFHLE9BQU9EO1FBQ3RCLE1BQU1FLE1BQWdCLEVBQUU7UUFDeEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILElBQUlqQixNQUFNLEVBQUVvQixLQUFLRixLQUFNO1lBQ3pDLE1BQU1HLFFBQVFKLElBQUlJLEtBQUssQ0FBQ0QsR0FBR0EsSUFBSUY7WUFDL0IsSUFBSSxDQUFDRyxNQUFNckIsTUFBTSxFQUFFO1lBQ25CLE1BQU1zQixJQUFJRCxLQUFLLENBQUMsRUFBRSxDQUFDQyxDQUFDO1lBQ3BCLE1BQU1mLElBQUljLEtBQUssQ0FBQ0EsTUFBTXJCLE1BQU0sR0FBRyxFQUFFLENBQUNPLENBQUM7WUFDbkMsSUFBSWdCLElBQUksQ0FBQ0MsVUFDUEMsSUFBSUQsVUFDSmQsSUFBSTtZQUNOLEtBQUssTUFBTWdCLEtBQUtMLE1BQU87Z0JBQ3JCLElBQUlLLEVBQUVILENBQUMsR0FBR0EsR0FBR0EsSUFBSUcsRUFBRUgsQ0FBQztnQkFDcEIsSUFBSUcsRUFBRUQsQ0FBQyxHQUFHQSxHQUFHQSxJQUFJQyxFQUFFRCxDQUFDO2dCQUNwQmYsS0FBS2dCLEVBQUVoQixDQUFDO1lBQ1Y7WUFDQVMsSUFBSVEsSUFBSSxDQUFDO2dCQUFFQyxHQUFHUCxLQUFLLENBQUMsRUFBRSxDQUFDTyxDQUFDO2dCQUFFTjtnQkFBR0M7Z0JBQUdFO2dCQUFHbEI7Z0JBQUdHO1lBQUU7UUFDMUM7UUFDQSxPQUFPUztJQUNUO0lBRUEsaUZBQWlGO0lBQ2pGLFNBQVNVLGdCQUFnQkMsTUFBeUIsRUFBRVosSUFBWTtRQUM5RCxJQUFJQSxRQUFRLEdBQUcsT0FBT1k7UUFDdEIsTUFBTVgsTUFBeUIsRUFBRTtRQUNqQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVUsT0FBTzlCLE1BQU0sRUFBRW9CLEtBQUtGLEtBQU07WUFDNUNDLElBQUlRLElBQUksQ0FBQ0csTUFBTSxDQUFDVixFQUFFLEdBQUcsc0NBQXNDO1FBQzdEO1FBQ0EsT0FBT0Q7SUFDVDtJQUVBLE1BQU1ZLFdBQVdoQyxlQUFlLElBQUlILGFBQWFvQixnQkFBZ0JwQixZQUFZRztJQUM3RSxNQUFNaUMsZ0JBQWdCakMsZUFBZSxJQUFJSSxXQUFXMEIsZ0JBQWdCMUIsVUFBVUo7SUFDOUUsTUFBTWtDLGdCQUFnQmxDLGVBQWUsSUFBSVMsV0FBV3FCLGdCQUFnQnJCLFVBQVVUO0lBQzlFLE1BQU1tQyx5QkFBeUJuQyxlQUFlLElBQUlZLG9CQUFvQjtRQUNwRUUsT0FBT2dCLGdCQUFnQmxCLGtCQUFrQkUsS0FBSyxFQUFFZDtRQUNoRGUsT0FBT2UsZ0JBQWdCbEIsa0JBQWtCRyxLQUFLLEVBQUVmO1FBQ2hEZ0IsUUFBUWMsZ0JBQWdCbEIsa0JBQWtCSSxNQUFNLEVBQUVoQjtJQUNwRDtJQUVBLHFGQUFxRjtJQUNyRix3REFBd0Q7SUFDeEQsTUFBTW9DLGlCQUEyQztRQUMvQyxNQUFNO1FBQ04sTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO1FBQ04sTUFBTTtRQUNOLE1BQU07SUFDUjtJQUNBLE1BQU1DLGdCQUFnQm5DLEtBQUtvQyxHQUFHLENBQUNGLGNBQWMsQ0FBQ2pELE1BQU0sRUFBRWUsS0FBS3FDLEtBQUssQ0FBQ1AsU0FBUy9CLE1BQU0sR0FBRztJQUNuRixNQUFNdUMsY0FBY1IsU0FBU1YsS0FBSyxDQUFDZSxnQkFBZ0IsK0JBQStCO0lBRWxGLE1BQU0sQ0FBQ0ksV0FBV0MsYUFBYSxHQUFHL0QscURBQWMsQ0FBbUIsSUFBTTtZQUFDO1lBQUc2RCxZQUFZdkMsTUFBTSxHQUFHO1NBQUU7SUFDcEcsMEVBQTBFO0lBQzFFckIsZ0RBQVNBLENBQUM7UUFDUjhELGFBQWE7WUFBQztZQUFHRixZQUFZdkMsTUFBTSxHQUFHO1NBQUU7SUFDMUMsR0FBRztRQUFDdUMsWUFBWXZDLE1BQU07S0FBQztJQUV2Qix5R0FBeUc7SUFDekcsTUFBTSxDQUFDMEMsUUFBUUMsS0FBSyxHQUFHSDtJQUN2QixNQUFNSSxZQUFZO0lBQ2xCLE1BQU1DLFVBQVVOLFlBQVl2QyxNQUFNLEdBQUc7SUFDckMsTUFBTThDLGlCQUNKSixXQUFXLEtBQUtDLFNBQVNKLFlBQVl2QyxNQUFNLEdBQUcsSUFBSTRDLFlBQVkzQyxLQUFLOEMsR0FBRyxDQUFDLEdBQUc5QyxLQUFLb0MsR0FBRyxDQUFDSyxRQUFRRztJQUM3RixNQUFNRyxlQUFlTixXQUFXLEtBQUtDLFNBQVNKLFlBQVl2QyxNQUFNLEdBQUcsSUFBSTZDLFVBQVU1QyxLQUFLb0MsR0FBRyxDQUFDTSxNQUFNRTtJQUNoRyxNQUFNSSxVQUFVaEQsS0FBS29DLEdBQUcsQ0FBQ1csY0FBY1QsWUFBWXZDLE1BQU0sR0FBRztJQUM1RCxNQUFNa0QsWUFBWWpELEtBQUs4QyxHQUFHLENBQUMsR0FBRzlDLEtBQUtvQyxHQUFHLENBQUNTLGdCQUFnQkcsVUFBVTtJQUNqRSxNQUFNRSxXQUFXWixZQUFZbEIsS0FBSyxDQUFDNkIsV0FBV0QsVUFBVTtJQUV4RCxnRkFBZ0Y7SUFDaEYsTUFBTUcsaUJBQWlCaEIsZ0JBQWdCYztJQUN2QyxNQUFNRyxlQUFlakIsZ0JBQWdCYSxVQUFVO0lBQy9DLE1BQU1LLFFBQVF0QixjQUFjWCxLQUFLLENBQUMrQixnQkFBZ0JDO0lBQ2xELE1BQU1FLFFBQVF0QixjQUFjWixLQUFLLENBQUMrQixnQkFBZ0JDO0lBQ2xELE1BQU1HLGlCQUFpQjtRQUNyQjNDLE9BQU9xQix1QkFBdUJyQixLQUFLLENBQUNRLEtBQUssQ0FBQytCLGdCQUFnQkM7UUFDMUR2QyxPQUFPb0IsdUJBQXVCcEIsS0FBSyxDQUFDTyxLQUFLLENBQUMrQixnQkFBZ0JDO1FBQzFEdEMsUUFBUW1CLHVCQUF1Qm5CLE1BQU0sQ0FBQ00sS0FBSyxDQUFDK0IsZ0JBQWdCQztJQUM5RDtJQUVBLE1BQU1JLFNBQVNOLFNBQVM5QyxHQUFHLENBQUMsQ0FBQ0MsSUFBY0EsRUFBRUMsQ0FBQyxHQUM1Q21ELFFBQVFQLFNBQVM5QyxHQUFHLENBQUMsQ0FBQ0MsSUFBY0EsRUFBRWlCLENBQUMsR0FDdkNvQyxPQUFPUixTQUFTOUMsR0FBRyxDQUFDLENBQUNDLElBQWNBLEVBQUVtQixDQUFDO0lBQ3hDLFNBQVNtQyxTQUFTQyxHQUFhLEVBQUVDLENBQVM7UUFDeEMsSUFBSSxDQUFDRCxJQUFJN0QsTUFBTSxFQUFFLE9BQU87UUFDeEIsTUFBTStELFNBQVM7ZUFBSUY7U0FBSSxDQUFDRyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsSUFBSUM7UUFDM0MsTUFBTUMsTUFBTSxDQUFDSixPQUFPL0QsTUFBTSxHQUFHLEtBQUs4RDtRQUNsQyxNQUFNTSxPQUFPbkUsS0FBS3FDLEtBQUssQ0FBQzZCO1FBQ3hCLE1BQU1FLE9BQU9GLE1BQU1DO1FBQ25CLE9BQU9MLE1BQU0sQ0FBQ0ssT0FBTyxFQUFFLEtBQUtFLFlBQ3hCUCxNQUFNLENBQUNLLEtBQUssR0FBR0MsT0FBUU4sQ0FBQUEsTUFBTSxDQUFDSyxPQUFPLEVBQUUsR0FBR0wsTUFBTSxDQUFDSyxLQUFLLElBQ3RETCxNQUFNLENBQUNLLEtBQUs7SUFDbEI7SUFDQSxJQUFJL0IsTUFBTXVCLFNBQVNELE1BQU0sUUFDdkJaLE1BQU1hLFNBQVNGLE9BQU87SUFDeEIsTUFBTWEsUUFBUXBCLFFBQVEsQ0FBQ0EsU0FBU25ELE1BQU0sR0FBRyxFQUFFO0lBQzNDLElBQUl1RSxPQUFPO1FBQ1QsSUFBSUEsTUFBTTlDLENBQUMsR0FBR1ksS0FBS0EsTUFBTWtDLE1BQU05QyxDQUFDO1FBQ2hDLElBQUk4QyxNQUFNaEQsQ0FBQyxHQUFHd0IsS0FBS0EsTUFBTXdCLE1BQU1oRCxDQUFDO0lBQ2xDO0lBQ0EsTUFBTWlELE9BQU96QixNQUFNVixPQUFPO0lBQzFCLHdCQUF3QjtJQUN4QixNQUFNb0MsSUFBSTVGLHVEQUFZQSxDQUFDNkYsV0FBVyxFQUFFLCtCQUErQjtJQUNuRSxNQUFNQyxjQUFjOUYsdURBQVlBLENBQUMrRixZQUFZLEVBQUUscUNBQXFDO0lBQ3BGLE1BQU1DLGdCQUFnQixNQUFNLG9DQUFvQztJQUNoRSxNQUFNQyxVQUFVSCxjQUFjRjtJQUM5QixNQUFNTSxPQUFPRCxVQUFVRDtJQUN2QixNQUFNRyxTQUFTRixVQUFVQztJQUN6QixNQUFNRSxhQUFhcEcsdURBQVlBLENBQUNxRyxrQkFBa0I7SUFDbEQsTUFBTTNELElBQUl1RCxVQUFVRztJQUNwQixNQUFNRSxJQUFJdEcsdURBQVlBLENBQUN1RyxXQUFXO0lBQ2xDLE1BQU1DLGNBQWN4Ryx1REFBWUEsQ0FBQ3lHLGlCQUFpQjtJQUNsRCxNQUFNQyxTQUFTLEdBQ2JDLFlBQVksR0FDWkMsVUFBVTtJQUNaLE1BQU1DLFlBQVlWLFNBQVNPLFNBQVNDO0lBQ3BDLE1BQU1HLEtBQUtsQyxNQUFNLENBQUNBLE9BQU96RCxNQUFNLEdBQUcsRUFBRSxJQUFJeUQsTUFBTSxDQUFDLEVBQUU7SUFDakQsTUFBTW1DLFNBQVNULElBQUlFLGNBQWNJO0lBRWpDLDBFQUEwRTtJQUMxRSxNQUFNSSxhQUFhMUMsU0FBU25ELE1BQU07SUFDbEMsU0FBUzhGLFFBQVFDLEdBQVc7UUFBSSxPQUFPTixVQUFVLE1BQU94RixLQUFLOEMsR0FBRyxDQUFDLEdBQUc4QyxhQUFhLEtBQU1EO0lBQVE7SUFFL0YsOEJBQThCO0lBQzlCLE1BQU1JLFlBQVk3QyxTQUFTOUMsR0FBRyxDQUFDQyxDQUFBQSxJQUFLLElBQUkyRixLQUFLM0YsRUFBRXNCLENBQUMsRUFBRXNFLE9BQU87SUFFekQsMENBQTBDO0lBQzFDLElBQUlDO0lBQ0osSUFBSU4sY0FBYyxHQUFHO1FBQ25CTSxjQUFjLFNBQVVsRyxLQUFLOEMsR0FBRyxDQUFDLEdBQUc4QyxjQUFlO0lBQ3JELE9BQU87UUFDTE0sY0FBYyxTQUFVTixhQUFjO0lBQ3hDO0lBQ0EsSUFBSU0sY0FBYyxHQUFHQSxjQUFjO0lBQUcsSUFBSUEsY0FBYyxJQUFJQSxjQUFjO0lBQzFFLE1BQU1DLFVBQVVqRCxTQUFTOUMsR0FBRyxDQUFDLENBQUNDLEdBQUd5RjtRQUMvQixNQUFNTSxJQUFJUCxRQUFRQztRQUNsQixNQUFNTyxNQUFNbkgsV0FBVyxDQUFDYyxLQUFLc0csS0FBSyxDQUFDakcsRUFBRUMsQ0FBQyxJQUFJTixLQUFLc0csS0FBSyxDQUFDbEUsSUFBRyxJQUFNcEMsQ0FBQUEsS0FBS3NHLEtBQUssQ0FBQ3hELE9BQU85QyxLQUFLc0csS0FBSyxDQUFDbEUsT0FBTyxFQUFDLElBQUssQ0FBQy9CLEVBQUVDLENBQUMsR0FBRzhCLEdBQUUsSUFBS21DO1FBQ3RILE1BQU1nQyxJQUFJakIsU0FBVUcsQ0FBQUEsWUFBWVksTUFBTVosU0FBUTtRQUM5QyxPQUFPLEdBQVFjLE9BQUxILEdBQUUsS0FBSyxPQUFGRztJQUNqQixHQUFHQyxJQUFJLENBQUM7SUFDUixNQUFNQyxhQUFhakgsU0FBUyxPQUFPMEQsUUFBUSxDQUFDMUQsTUFBTSxHQUFHO0lBQ3JELFNBQVNrSCxPQUFPQyxDQUFrQztRQUNoRCxNQUFNQyxPQUFPRCxFQUFFRSxhQUFhLENBQUNDLHFCQUFxQjtRQUNsRCxNQUFNVixJQUFJTyxFQUFFSSxPQUFPLEdBQUdILEtBQUtJLElBQUk7UUFFL0IsdURBQXVEO1FBQ3ZELElBQUk5RCxTQUFTbkQsTUFBTSxLQUFLLEdBQUc7UUFFM0IsTUFBTWtILFNBQVNqSCxLQUFLOEMsR0FBRyxDQUFDLEdBQUc5QyxLQUFLb0MsR0FBRyxDQUFDLEdBQUcsQ0FBQ2dFLElBQUlaLE9BQU0sSUFBTW9CLENBQUFBLEtBQUtNLEtBQUssR0FBRyxjQUFlaEMsSUFBSzBCLEtBQUtNLEtBQUs7UUFDbkcsTUFBTXBCLE1BQU05RixLQUFLbUgsS0FBSyxDQUFDRixTQUFVckIsQ0FBQUEsYUFBYTtRQUU5Q25HLFNBQVNPLEtBQUs4QyxHQUFHLENBQUMsR0FBRzlDLEtBQUtvQyxHQUFHLENBQUN3RCxhQUFhLEdBQUdFO0lBQ2hEO0lBQ0EsTUFBTXNCLFlBQVl6SSw2Q0FBTUEsQ0FBMEQ7SUFDbEYsU0FBUzBJLFFBQVFWLENBQWtDO1FBQ2pEQSxFQUFFVyxjQUFjO1FBQ2hCLElBQUlwRSxTQUFTbkQsTUFBTSxHQUFHLElBQUk7UUFDMUIsTUFBTXdILFFBQVFaLEVBQUVhLE1BQU07UUFDdEIsTUFBTUMsU0FBU0YsUUFBUSxJQUFJLE1BQU07UUFDakMsTUFBTUcsYUFBYWhGLE9BQU9ELFNBQVM7UUFDbkMsTUFBTWtGLFNBQVMzSCxLQUFLOEMsR0FBRyxDQUFDLElBQUk5QyxLQUFLb0MsR0FBRyxDQUFDRSxZQUFZdkMsTUFBTSxFQUFFQyxLQUFLbUgsS0FBSyxDQUFDTyxhQUFhRDtRQUNqRixNQUFNYixPQUFPLEVBQUdDLGFBQWEsQ0FBbUJDLHFCQUFxQjtRQUNyRSxNQUFNRyxTQUFTLENBQUNOLEVBQUVJLE9BQU8sR0FBR0gsS0FBS0ksSUFBSSxHQUFHeEIsT0FBTSxJQUFNb0IsQ0FBQUEsS0FBS00sS0FBSyxHQUFHOUIsV0FBVTtRQUMzRSxNQUFNd0MsV0FBV25GLFNBQVN6QyxLQUFLbUgsS0FBSyxDQUFDTyxhQUFhVDtRQUNsRCxJQUFJWSxXQUFXRCxXQUFXNUgsS0FBS21ILEtBQUssQ0FBQ1EsU0FBU1Y7UUFDOUMsSUFBSWEsU0FBU0QsV0FBV0YsU0FBUztRQUNqQyxJQUFJRSxXQUFXLEdBQUc7WUFDaEJBLFdBQVc7WUFDWEMsU0FBU0gsU0FBUztRQUNwQjtRQUNBLElBQUlHLFNBQVN4RixZQUFZdkMsTUFBTSxHQUFHLEdBQUc7WUFDbkMrSCxTQUFTeEYsWUFBWXZDLE1BQU0sR0FBRztZQUM5QjhILFdBQVdDLFNBQVNILFNBQVM7UUFDL0I7UUFDQW5GLGFBQWE7WUFBQ3FGO1lBQVVDO1NBQU87SUFDakM7SUFDQSxTQUFTQyxjQUFjcEIsQ0FBb0M7UUFDekRBLEVBQUVFLGFBQWEsQ0FBQ21CLGlCQUFpQixDQUFDckIsRUFBRXNCLFNBQVM7UUFDN0NiLFVBQVVjLE9BQU8sR0FBRztZQUFFQyxRQUFReEIsRUFBRUksT0FBTztZQUFFcUIsWUFBWTdGO1FBQVU7SUFDakU7SUFDQSxTQUFTOEYsY0FBYzFCLENBQW9DO1FBQ3pELElBQUksQ0FBQ1MsVUFBVWMsT0FBTyxFQUFFO1FBQ3hCLE1BQU0sQ0FBQ3pHLEdBQUc2RyxLQUFLLEdBQUdsQixVQUFVYyxPQUFPLENBQUNFLFVBQVU7UUFDOUMsTUFBTUcsTUFBTUQsT0FBTzdHLElBQUk7UUFDdkIsTUFBTStHLGlCQUFpQjdDLFNBQVN6QyxTQUFTbkQsTUFBTTtRQUMvQyxNQUFNMEksVUFBVTlCLEVBQUVJLE9BQU8sR0FBR0ssVUFBVWMsT0FBTyxDQUFDQyxNQUFNO1FBQ3BELE1BQU1PLFFBQVExSSxLQUFLbUgsS0FBSyxDQUFDLENBQUNzQixVQUFVRDtRQUNwQyxJQUFJWCxXQUFXcEcsSUFBSWlIO1FBQ25CLElBQUlaLFNBQVNELFdBQVdVLE1BQU07UUFDOUIsSUFBSVYsV0FBVyxHQUFHO1lBQ2hCQSxXQUFXO1lBQ1hDLFNBQVNTLE1BQU07UUFDakI7UUFDQSxJQUFJVCxTQUFTeEYsWUFBWXZDLE1BQU0sR0FBRyxHQUFHO1lBQ25DK0gsU0FBU3hGLFlBQVl2QyxNQUFNLEdBQUc7WUFDOUI4SCxXQUFXQyxTQUFTUyxNQUFNO1FBQzVCO1FBQ0EvRixhQUFhO1lBQUNxRjtZQUFVQztTQUFPO0lBQ2pDO0lBQ0EsU0FBU2E7UUFDUHZCLFVBQVVjLE9BQU8sR0FBRztJQUN0QjtJQUNBLFNBQVNVLFVBQVVDLEdBQVcsRUFBRUMsSUFBWTtZQUFFakosU0FBQUEsaUVBQVM7UUFDckQsTUFBTWtKLFVBQVVELE9BQU9ELE9BQU87UUFDOUIsTUFBTUcsWUFBWUQsVUFBV2xKLENBQUFBLFNBQVM7UUFDdEMsTUFBTW9KLFFBQVFqSixLQUFLa0osR0FBRyxDQUFDLElBQUlsSixLQUFLcUMsS0FBSyxDQUFDckMsS0FBS3NHLEtBQUssQ0FBQzBDO1FBQ2pELE1BQU1HLFlBQVk7WUFBQztZQUFHO1lBQUc7WUFBSztZQUFHO1NBQUc7UUFDcEMsTUFBTUMsUUFBUUQsVUFBVUUsSUFBSSxDQUFDLENBQUNDLElBQU1BLElBQUlMLFNBQVNELGNBQWNHLFNBQVMsQ0FBQ0EsVUFBVXBKLE1BQU0sR0FBRyxFQUFFO1FBQzlGLE1BQU13SixPQUFPSCxRQUFRSDtRQUNyQixNQUFNTyxRQUFReEosS0FBS0MsSUFBSSxDQUFDNEksTUFBTVUsUUFBUUE7UUFDdEMsTUFBTUUsUUFBa0IsRUFBRTtRQUMxQixJQUFLLElBQUloSixJQUFJK0ksT0FBTy9JLEtBQUtxSSxNQUFNckksS0FBSzhJLEtBQU1FLE1BQU0vSCxJQUFJLENBQUNqQjtRQUNyRCxPQUFPZ0o7SUFDVDtJQUNBLCtCQUErQjtJQUMvQixNQUFNQyxZQUFpRCxFQUFFO0lBQ3pELElBQUl4RyxTQUFTbkQsTUFBTSxHQUFHLEdBQUc7UUFDdkIsSUFBSWQsVUFBVSxNQUFNO1lBQ2xCLDRDQUE0QztZQUM1QyxNQUFNMEssT0FBTyxJQUFJQztZQUNqQjFHLFNBQVMyRyxPQUFPLENBQUMsQ0FBQ3ZKLEdBQUd3RjtnQkFDbkIsTUFBTXpGLElBQUksSUFBSTJGLEtBQUsxRixFQUFFcUIsQ0FBQztnQkFDdEIsTUFBTW1JLEtBQUt6SixFQUFFMEosUUFBUTtnQkFDckIsTUFBTUMsS0FBSzNKLEVBQUU0SixVQUFVO2dCQUN2QixvQ0FBb0M7Z0JBQ3BDLElBQUlELE9BQU8sR0FBRztvQkFDWixNQUFNRSxVQUFVLEdBQU0sT0FBSEosSUFBRztvQkFDdEIsSUFBSSxDQUFDSCxLQUFLUSxHQUFHLENBQUNELFVBQVU7d0JBQ3RCUCxLQUFLUyxHQUFHLENBQUNGO3dCQUNUUixVQUFVaEksSUFBSSxDQUFDOzRCQUNiMEUsR0FBR1AsUUFBUUM7NEJBQ1h1RSxPQUFPaEssRUFBRWlLLGtCQUFrQixDQUFDLFNBQVM7Z0NBQUVDLE1BQU07Z0NBQVdDLFFBQVE7Z0NBQVdDLFFBQVE7NEJBQU07d0JBQzNGO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRixPQUFPLElBQUl4TCxVQUFVLE1BQU07WUFDekIsTUFBTTBLLE9BQU8sSUFBSUM7WUFBZTFHLFNBQVMyRyxPQUFPLENBQUMsQ0FBQ3ZKLEdBQUd3RjtnQkFBVSxNQUFNekYsSUFBSSxJQUFJMkYsS0FBSzFGLEVBQUVxQixDQUFDO2dCQUFHLE1BQU0rSSxJQUFJckssRUFBRXNLLFlBQVk7Z0JBQUksSUFBSSxDQUFDaEIsS0FBS1EsR0FBRyxDQUFDTyxJQUFJO29CQUFFZixLQUFLUyxHQUFHLENBQUNNO29CQUFJaEIsVUFBVWhJLElBQUksQ0FBQzt3QkFBRTBFLEdBQUdQLFFBQVFDO3dCQUFNdUUsT0FBT2hLLEVBQUV1SyxrQkFBa0IsQ0FBQ3ZHLFdBQVU7NEJBQUV3RyxTQUFRO3dCQUFPLEdBQUdDLFdBQVc7b0JBQUc7Z0JBQUk7WUFBRTtRQUN2USxPQUFPLElBQUk3TCxVQUFVLE1BQU07WUFDekIsTUFBTTBLLE9BQU8sSUFBSUM7WUFBZTFHLFNBQVMyRyxPQUFPLENBQUMsQ0FBQ3ZKLEdBQUd3RjtnQkFBVSxNQUFNekYsSUFBSSxJQUFJMkYsS0FBSzFGLEVBQUVxQixDQUFDO2dCQUFHLElBQUl0QixFQUFFMEssTUFBTSxPQUFPLEdBQUc7b0JBQUUsTUFBTUMsTUFBTTNLLEVBQUU0SyxXQUFXLEtBQUcsTUFBSTVLLEVBQUU2SyxRQUFRLEtBQUcsTUFBSTdLLEVBQUU4SyxPQUFPO29CQUFJLElBQUksQ0FBQ3hCLEtBQUtRLEdBQUcsQ0FBQ2EsTUFBTTt3QkFBRXJCLEtBQUtTLEdBQUcsQ0FBQ1k7d0JBQU10QixVQUFVaEksSUFBSSxDQUFDOzRCQUFFMEUsR0FBR1AsUUFBUUM7NEJBQU11RSxPQUFPLEVBQUdhLFFBQVEsS0FBRyxJQUFHLE1BQUk3SyxFQUFFOEssT0FBTzt3QkFBRztvQkFBSTtnQkFBRTtZQUFFO1FBQ3ZTLE9BQU8sSUFBSWxNLFVBQVUsTUFBTTtZQUN6QixJQUFJbU0sY0FBYztZQUFHbEksU0FBUzJHLE9BQU8sQ0FBQyxDQUFDdkosR0FBR3dGO2dCQUFVLE1BQU16RixJQUFJLElBQUkyRixLQUFLMUYsRUFBRXFCLENBQUM7Z0JBQUcsSUFBSXRCLEVBQUUwSyxNQUFNLE9BQU8sR0FBRztvQkFBRSxJQUFJSyxjQUFjLE1BQU0sR0FBRzFCLFVBQVVoSSxJQUFJLENBQUM7d0JBQUUwRSxHQUFHUCxRQUFRQzt3QkFBTXVFLE9BQU8sRUFBR2EsUUFBUSxLQUFHLElBQUcsTUFBSTdLLEVBQUU4SyxPQUFPO29CQUFHO29CQUFJQztnQkFBZTtZQUFFO1FBQ2pPLE9BQU8sSUFBSW5NLFVBQVUsTUFBTTtZQUN6QixNQUFNb00sWUFBWSxJQUFJekI7WUFBZTFHLFNBQVMyRyxPQUFPLENBQUMsQ0FBQ3ZKLEdBQUd3RjtnQkFBVSxNQUFNekYsSUFBSSxJQUFJMkYsS0FBSzFGLEVBQUVxQixDQUFDO2dCQUFHLE1BQU0ySixLQUFLakwsRUFBRTRLLFdBQVcsS0FBRyxNQUFJNUssRUFBRTZLLFFBQVE7Z0JBQUksSUFBSSxDQUFDRyxVQUFVbEIsR0FBRyxDQUFDbUIsT0FBT2pMLEVBQUU4SyxPQUFPLE1BQU0sR0FBRztvQkFBRUUsVUFBVWpCLEdBQUcsQ0FBQ2tCO29CQUFLNUIsVUFBVWhJLElBQUksQ0FBQzt3QkFBRTBFLEdBQUdQLFFBQVFDO3dCQUFNdUUsT0FBT2hLLEVBQUVrTCxjQUFjLENBQUNsSCxXQUFVOzRCQUFFbUgsT0FBTTt3QkFBTyxHQUFHVixXQUFXO29CQUFHO2dCQUFJO1lBQUU7UUFDdlQsT0FBTyxJQUFJN0wsVUFBVSxNQUFNO1lBQ3pCLE1BQU13TSxXQUFXLElBQUk3QjtZQUFlMUcsU0FBUzJHLE9BQU8sQ0FBQyxDQUFDdkosR0FBR3dGO2dCQUFVLE1BQU16RixJQUFJLElBQUkyRixLQUFLMUYsRUFBRXFCLENBQUM7Z0JBQUcsSUFBSSxDQUFDOEosU0FBU3RCLEdBQUcsQ0FBQzlKLEVBQUU0SyxXQUFXLE9BQU81SyxFQUFFNkssUUFBUSxLQUFLLEdBQUc7b0JBQUVPLFNBQVNyQixHQUFHLENBQUMvSixFQUFFNEssV0FBVztvQkFBS3ZCLFVBQVVoSSxJQUFJLENBQUM7d0JBQUUwRSxHQUFHUCxRQUFRQzt3QkFBTXVFLE9BQU9xQixPQUFPckwsRUFBRTRLLFdBQVc7b0JBQUk7Z0JBQUk7WUFBRTtRQUM5UDtJQUNGO0lBQ0EsTUFBTVUsU0FBUzNMLEtBQUs4QyxHQUFHLElBQUlJLFNBQVM5QyxHQUFHLENBQUMsQ0FBQ0MsSUFBY0EsRUFBRUksQ0FBQyxHQUFHO0lBQzdELE1BQU1tTCxZQUFZNUwsS0FBSzZMLEdBQUcsQ0FBQy9JO0lBQzNCLE1BQU1nSixXQUFXRixhQUFhLE1BQU0sSUFBSUEsYUFBYSxNQUFNLElBQUk7SUFDL0QsU0FBU3BMLElBQUlRLEdBQWEsRUFBRStLLE1BQWM7UUFDeEMsSUFBSS9LLElBQUlqQixNQUFNLEdBQUdnTSxRQUFRLE9BQU8sRUFBRTtRQUNsQyxNQUFNN0ssTUFBeUIsSUFBSThLLE1BQU1ELFNBQVMsR0FBR0UsSUFBSSxDQUFDLE9BQU8sMkJBQTJCO1FBQzVGLElBQUlDLE1BQU07UUFDVixJQUFLLElBQUkvSyxJQUFJLEdBQUdBLElBQUlILElBQUlqQixNQUFNLEVBQUVvQixJQUFLO1lBQ25DK0ssT0FBT2xMLEdBQUcsQ0FBQ0csRUFBRTtZQUNiLElBQUlBLEtBQUs0SyxRQUFRRyxPQUFPbEwsR0FBRyxDQUFDRyxJQUFJNEssT0FBTztZQUN2QyxJQUFJNUssS0FBSzRLLFNBQVMsR0FBRzdLLElBQUlRLElBQUksQ0FBQ3dLLE1BQU1IO1FBQ3RDO1FBQ0EsT0FBTzdLO0lBQ1Q7SUFFQSxTQUFTZixJQUFJYSxHQUFhLEVBQUUrSyxNQUFjO1FBQ3hDLElBQUkvSyxJQUFJakIsTUFBTSxHQUFHZ00sUUFBUSxPQUFPLEVBQUU7UUFDbEMsTUFBTXJCLElBQUksSUFBS3FCLENBQUFBLFNBQVM7UUFDeEIsTUFBTTdLLE1BQXlCLElBQUk4SyxNQUFNRCxTQUFTLEdBQUdFLElBQUksQ0FBQyxPQUFPLDJCQUEyQjtRQUU1RixpQ0FBaUM7UUFDakMsSUFBSUMsTUFBTTtRQUNWLElBQUssSUFBSS9LLElBQUksR0FBR0EsSUFBSTRLLFFBQVE1SyxJQUFLO1lBQy9CK0ssT0FBT2xMLEdBQUcsQ0FBQ0csRUFBRTtRQUNmO1FBQ0FELElBQUlRLElBQUksQ0FBQ3dLLE1BQU1IO1FBRWYsdUJBQXVCO1FBQ3ZCLElBQUssSUFBSTVLLElBQUk0SyxRQUFRNUssSUFBSUgsSUFBSWpCLE1BQU0sRUFBRW9CLElBQUs7WUFDeENELElBQUlRLElBQUksQ0FBQ1YsR0FBRyxDQUFDRyxFQUFFLEdBQUd1SixJQUFJLEdBQUksQ0FBQ3hKLElBQUluQixNQUFNLEdBQUcsRUFBRSxHQUFlLEtBQUkySyxDQUFBQTtRQUMvRDtRQUVBLE9BQU94SjtJQUNUO0lBRUEsU0FBU1Asd0JBQXdCNkMsTUFBZ0I7WUFBRXVJLFNBQUFBLGlFQUFpQixJQUFJSSxtQkFBQUEsaUVBQTJCO1FBQ2pHLElBQUkzSSxPQUFPekQsTUFBTSxHQUFHZ00sUUFBUSxPQUFPO1lBQUVuTCxPQUFPLEVBQUU7WUFBRUMsT0FBTyxFQUFFO1lBQUVDLFFBQVEsRUFBRTtRQUFDO1FBRXRFLE1BQU1BLFNBQTRCLElBQUlrTCxNQUFNRCxTQUFTLEdBQUdFLElBQUksQ0FBQztRQUM3RCxNQUFNckwsUUFBMkIsSUFBSW9MLE1BQU1ELFNBQVMsR0FBR0UsSUFBSSxDQUFDO1FBQzVELE1BQU1wTCxRQUEyQixJQUFJbUwsTUFBTUQsU0FBUyxHQUFHRSxJQUFJLENBQUM7UUFFNUQsSUFBSyxJQUFJOUssSUFBSTRLLFNBQVMsR0FBRzVLLElBQUlxQyxPQUFPekQsTUFBTSxFQUFFb0IsSUFBSztZQUMvQyxNQUFNQyxRQUFRb0MsT0FBT3BDLEtBQUssQ0FBQ0QsSUFBSTRLLFNBQVMsR0FBRzVLLElBQUk7WUFDL0MsTUFBTWlMLE1BQU1oTCxNQUFNaUwsTUFBTSxDQUFDLENBQUNILEtBQUs3RixNQUFRNkYsTUFBTTdGLEtBQUssS0FBSzBGO1lBQ3ZELE1BQU1PLFdBQVdsTCxNQUFNaUwsTUFBTSxDQUFDLENBQUNILEtBQUs3RixNQUFRNkYsTUFBTWxNLEtBQUtrSixHQUFHLENBQUM3QyxNQUFNK0YsS0FBSyxJQUFJLEtBQUtMO1lBQy9FLE1BQU1RLFNBQVN2TSxLQUFLd00sSUFBSSxDQUFDRjtZQUV6QnhMLE9BQU9ZLElBQUksQ0FBQzBLO1lBQ1p4TCxNQUFNYyxJQUFJLENBQUMwSyxNQUFNRCxtQkFBbUJJO1lBQ3BDMUwsTUFBTWEsSUFBSSxDQUFDMEssTUFBTUQsbUJBQW1CSTtRQUN0QztRQUVBLE9BQU87WUFBRTNMO1lBQU9DO1lBQU9DO1FBQU87SUFDaEM7SUFFQSxxQkFDRSw4REFBQzJMO1FBQUlDLE9BQU87WUFBRUMsVUFBVTtZQUFZQyxPQUFPO1lBQUdDLFVBQVU7UUFBRzs7MEJBQ3pELDhEQUFDQztnQkFDQ0MsU0FBUyxPQUFZekwsT0FBTDRELEdBQUUsS0FBSyxPQUFGNUQ7Z0JBQ3JCMEwscUJBQW9CO2dCQUNwQk4sT0FBTztvQkFDTHhGLE9BQU87b0JBQ1ArRixRQUFRO29CQUNSQyxRQUFRO29CQUNSQyxZQUFZO29CQUNaQyxZQUFZO2dCQUNkO2dCQUNBQyxhQUFhM0c7Z0JBQ2I0RyxjQUFjLElBQU03TixTQUFTO2dCQUM3QjRILFNBQVNBO2dCQUNUVSxlQUFlQTtnQkFDZk0sZUFBZUE7Z0JBQ2ZNLGFBQWFBOztvQkFFWkMsVUFBVXhHLEtBQUtVLEtBQUssR0FBRzFDLEdBQUcsQ0FBQyxDQUFDdUI7d0JBQzNCLE1BQU00RSxJQUFJLElBQUtkLENBQUFBLFlBQVksQ0FBRTlELElBQUlTLEdBQUUsSUFBS21DLE9BQVFrQixTQUFRO3dCQUN4RCxxQkFDRSw4REFBQzhIOzs4Q0FDQyw4REFBQ0M7b0NBQ0NDLElBQUlqSTtvQ0FDSmtJLElBQUlsSSxVQUFVRztvQ0FDZGdJLElBQUlwSDtvQ0FDSnFILElBQUlySDtvQ0FDSnNILFFBQVF0TyxVQUFVLFVBQVUsWUFBWTtvQ0FDeEN1TyxhQUFhOzs7Ozs7OENBRWYsOERBQUNDO29DQUNDM0gsR0FBR1osVUFBVUcsU0FBUy9HLHVEQUFZQSxDQUFDb1AscUJBQXFCO29DQUN4RHpILEdBQUdBLElBQUkzSCx1REFBWUEsQ0FBQ3FQLGdCQUFnQixHQUFHO29DQUN2Q2hDLE1BQU0xTSxVQUFVLFVBQVUsWUFBWTtvQ0FDdENzTixVQUFVak8sdURBQVlBLENBQUNxUCxnQkFBZ0I7OENBRXRDdE0sRUFBRXVNLE9BQU8sQ0FBQ3BDOzs7Ozs7OzJCQWZQbkssRUFBRXVNLE9BQU8sQ0FBQzs7Ozs7b0JBbUJ0QjtvQkFHQ3hFLFVBQVV0SixHQUFHLENBQUMsQ0FBQ3VCLEdBQUdSLGtCQUNqQiw4REFBQ3FNOzRCQUVDQyxJQUFJOUwsRUFBRXlFLENBQUM7NEJBQ1BzSCxJQUFJL0wsRUFBRXlFLENBQUM7NEJBQ1B1SCxJQUFJOzRCQUNKQyxJQUFJL0k7NEJBQ0pnSixRQUFRdE8sVUFBVSxVQUFVLFlBQVk7NEJBQ3hDdU8sYUFBYTsyQkFOUixXQUFXM007Ozs7O29CQVduQi9CLHNCQUFzQm1FLGVBQWUzQyxLQUFLLENBQUNiLE1BQU0sR0FBRyxtQkFDbkQ7OzBDQUVFLDhEQUFDb087Z0NBQ0NDLFFBQVEsQ0FBQztvQ0FDUCxNQUFNQSxTQUFtQixFQUFFO29DQUMzQixhQUFhO29DQUNiLElBQUssSUFBSWpOLElBQUksR0FBR0EsSUFBSW9DLGVBQWUzQyxLQUFLLENBQUNiLE1BQU0sRUFBRW9CLElBQUs7d0NBQ3BELE1BQU1rTixXQUFXOUssZUFBZTNDLEtBQUssQ0FBQ08sRUFBRTt3Q0FDeEMsSUFBSWtOLGFBQWEsTUFBTTt3Q0FDdkIsTUFBTWpJLElBQUlQLFFBQVExRTt3Q0FDbEIsTUFBTWtGLE1BQU0sQ0FBQ2dJLFdBQVdqTSxHQUFFLElBQUttQzt3Q0FDL0IsTUFBTWdDLElBQUlqQixTQUFVRyxDQUFBQSxZQUFZWSxNQUFNWixTQUFRO3dDQUM5QyxJQUFJNkksU0FBU2xJLE1BQU1rSSxTQUFTL0gsSUFBSTs0Q0FDOUI2SCxPQUFPMU0sSUFBSSxDQUFDLEdBQVE2RSxPQUFMSCxHQUFFLEtBQUssT0FBRkc7d0NBQ3RCO29DQUNGO29DQUNBLHdCQUF3QjtvQ0FDeEIsSUFBSyxJQUFJcEYsSUFBSW9DLGVBQWUxQyxLQUFLLENBQUNkLE1BQU0sR0FBRyxHQUFHb0IsS0FBSyxHQUFHQSxJQUFLO3dDQUN6RCxNQUFNb04sV0FBV2hMLGVBQWUxQyxLQUFLLENBQUNNLEVBQUU7d0NBQ3hDLElBQUlvTixhQUFhLE1BQU07d0NBQ3ZCLE1BQU1uSSxJQUFJUCxRQUFRMUU7d0NBQ2xCLE1BQU1rRixNQUFNLENBQUNrSSxXQUFXbk0sR0FBRSxJQUFLbUM7d0NBQy9CLE1BQU1nQyxJQUFJakIsU0FBVUcsQ0FBQUEsWUFBWVksTUFBTVosU0FBUTt3Q0FDOUMsSUFBSTZJLFNBQVNsSSxNQUFNa0ksU0FBUy9ILElBQUk7NENBQzlCNkgsT0FBTzFNLElBQUksQ0FBQyxHQUFRNkUsT0FBTEgsR0FBRSxLQUFLLE9BQUZHO3dDQUN0QjtvQ0FDRjtvQ0FDQSxPQUFPNkgsT0FBTzVILElBQUksQ0FBQztnQ0FDckI7Z0NBQ0F5RixNQUFLO2dDQUNMNEIsUUFBTzs7Ozs7OzBDQUlULDhEQUFDVztnQ0FDQ0osUUFBUTdLLGVBQWUzQyxLQUFLLENBQ3pCUixHQUFHLENBQUMsQ0FBQ0ssR0FBR1U7b0NBQ1AsSUFBSVYsTUFBTSxNQUFNLE9BQU87b0NBQ3ZCLE1BQU0yRixJQUFJUCxRQUFRMUU7b0NBQ2xCLE1BQU1rRixNQUFNLENBQUM1RixJQUFJMkIsR0FBRSxJQUFLbUM7b0NBQ3hCLE1BQU1nQyxJQUFJakIsU0FBVUcsQ0FBQUEsWUFBWVksTUFBTVosU0FBUTtvQ0FDOUMsT0FBTyxHQUFRYyxPQUFMSCxHQUFFLEtBQUssT0FBRkc7Z0NBQ2pCLEdBQ0NrSSxNQUFNLENBQUNDLENBQUFBLElBQUtBLE1BQU0sTUFDbEJsSSxJQUFJLENBQUM7Z0NBQ1J5RixNQUFLO2dDQUNMNEIsUUFBTztnQ0FDUEMsYUFBYTtnQ0FDYmEsY0FBYTs7Ozs7OzBDQUlmLDhEQUFDSDtnQ0FDQ0osUUFBUTdLLGVBQWUxQyxLQUFLLENBQ3pCVCxHQUFHLENBQUMsQ0FBQ0ssR0FBR1U7b0NBQ1AsSUFBSVYsTUFBTSxNQUFNLE9BQU87b0NBQ3ZCLE1BQU0yRixJQUFJUCxRQUFRMUU7b0NBQ2xCLE1BQU1rRixNQUFNLENBQUM1RixJQUFJMkIsR0FBRSxJQUFLbUM7b0NBQ3hCLE1BQU1nQyxJQUFJakIsU0FBVUcsQ0FBQUEsWUFBWVksTUFBTVosU0FBUTtvQ0FDOUMsT0FBTyxHQUFRYyxPQUFMSCxHQUFFLEtBQUssT0FBRkc7Z0NBQ2pCLEdBQ0NrSSxNQUFNLENBQUNDLENBQUFBLElBQUtBLE1BQU0sTUFDbEJsSSxJQUFJLENBQUM7Z0NBQ1J5RixNQUFLO2dDQUNMNEIsUUFBTztnQ0FDUEMsYUFBYTtnQ0FDYmEsY0FBYTs7Ozs7Ozs7b0JBSWxCM1AsU0FBUyx3QkFDUiw4REFBQ3dQO3dCQUNDSixRQUFRakk7d0JBQ1I4RixNQUFLO3dCQUNMNEIsUUFBUW5JLEtBQUsseUJBQXlCO3dCQUN0Q29JLGFBQWE7d0JBQ2JhLGNBQWE7Ozs7OztvQkFHaEIzUCxTQUFTLGFBQ1JrRSxTQUFTOUMsR0FBRyxDQUFDLENBQUNDLEdBQVd5Rjt3QkFDdkIsTUFBTThJLFVBQVUvSSxRQUFRQzt3QkFDeEIsTUFBTU0sSUFBSXdJLFVBQVUxSSxjQUFjO3dCQUNsQyxNQUFNMkksVUFBVTNQLFdBQ1osQ0FBQ2MsS0FBS3NHLEtBQUssQ0FBQ2pHLEVBQUVnQixDQUFDLElBQUlyQixLQUFLc0csS0FBSyxDQUFDbEUsSUFBRyxJQUFNcEMsQ0FBQUEsS0FBS3NHLEtBQUssQ0FBQ3hELE9BQU85QyxLQUFLc0csS0FBSyxDQUFDbEUsT0FBTyxFQUFDLElBQzVFLENBQUMvQixFQUFFZ0IsQ0FBQyxHQUFHZSxHQUFFLElBQUttQzt3QkFDbEIsTUFBTXVLLFdBQVc1UCxXQUNiLENBQUNjLEtBQUtzRyxLQUFLLENBQUNqRyxFQUFFQyxDQUFDLElBQUlOLEtBQUtzRyxLQUFLLENBQUNsRSxJQUFHLElBQU1wQyxDQUFBQSxLQUFLc0csS0FBSyxDQUFDeEQsT0FBTzlDLEtBQUtzRyxLQUFLLENBQUNsRSxPQUFPLEVBQUMsSUFDNUUsQ0FBQy9CLEVBQUVDLENBQUMsR0FBRzhCLEdBQUUsSUFBS21DO3dCQUNsQixNQUFNd0ssVUFBVTdQLFdBQ1osQ0FBQ2MsS0FBS3NHLEtBQUssQ0FBQ2pHLEVBQUVpQixDQUFDLElBQUl0QixLQUFLc0csS0FBSyxDQUFDbEUsSUFBRyxJQUFNcEMsQ0FBQUEsS0FBS3NHLEtBQUssQ0FBQ3hELE9BQU85QyxLQUFLc0csS0FBSyxDQUFDbEUsT0FBTyxFQUFDLElBQzVFLENBQUMvQixFQUFFaUIsQ0FBQyxHQUFHYyxHQUFFLElBQUttQzt3QkFDbEIsTUFBTXlLLFNBQVM5UCxXQUNYLENBQUNjLEtBQUtzRyxLQUFLLENBQUNqRyxFQUFFbUIsQ0FBQyxJQUFJeEIsS0FBS3NHLEtBQUssQ0FBQ2xFLElBQUcsSUFBTXBDLENBQUFBLEtBQUtzRyxLQUFLLENBQUN4RCxPQUFPOUMsS0FBS3NHLEtBQUssQ0FBQ2xFLE9BQU8sRUFBQyxJQUM1RSxDQUFDL0IsRUFBRW1CLENBQUMsR0FBR1ksR0FBRSxJQUFLbUM7d0JBQ2xCLE1BQU0wSyxRQUFRLElBQUt4SixDQUFBQSxZQUFZb0osVUFBVXBKLFNBQVE7d0JBQ2pELE1BQU15SixTQUFTLElBQUt6SixDQUFBQSxZQUFZcUosV0FBV3JKLFNBQVE7d0JBQ25ELE1BQU0wSixRQUFRLElBQUsxSixDQUFBQSxZQUFZc0osVUFBVXRKLFNBQVE7d0JBQ2pELE1BQU0ySixPQUFPLElBQUszSixDQUFBQSxZQUFZdUosU0FBU3ZKLFNBQVE7d0JBQy9DLE1BQU00SixTQUFTaFAsRUFBRUMsQ0FBQyxJQUFJRCxFQUFFZ0IsQ0FBQzt3QkFDekIsTUFBTWlPLE1BQU10UCxLQUFLb0MsR0FBRyxDQUFDLE1BQU1wQyxLQUFLOEMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDekMsRUFBRUMsQ0FBQyxHQUFHRCxFQUFFZ0IsQ0FBQyxJQUFJaEIsRUFBRWdCLENBQUM7d0JBQzVELE1BQU1rTyxZQUFZdlAsS0FBSzZMLEdBQUcsQ0FBQ3lELE9BQU87d0JBQ2xDLE1BQU1FLFlBQVlILFNBQVMseUJBQXlCO3dCQUNwRCxNQUFNcEQsT0FBT29ELFNBQ1Qsa0JBQTBDLE9BQXhCLE9BQU8sT0FBT0UsV0FBVSxPQUMxQyxrQkFBMEMsT0FBeEIsT0FBTyxPQUFPQSxXQUFVO3dCQUM5QyxxQkFDRSw4REFBQ2hDOzs4Q0FDQyw4REFBQ0M7b0NBQ0NDLElBQUlySCxJQUFJRixjQUFjO29DQUN0QndILElBQUl0SCxJQUFJRixjQUFjO29DQUN0QnlILElBQUl3QjtvQ0FDSnZCLElBQUl3QjtvQ0FDSnZCLFFBQVEyQjtvQ0FDUjFCLGFBQWE7Ozs7Ozs4Q0FFZiw4REFBQ2xIO29DQUNDUixHQUFHQTtvQ0FDSEcsR0FBR3ZHLEtBQUtvQyxHQUFHLENBQUM2TSxPQUFPQztvQ0FDbkJoSSxPQUFPaEI7b0NBQ1ArRyxRQUFRak4sS0FBSzhDLEdBQUcsQ0FBQyxHQUFHOUMsS0FBSzZMLEdBQUcsQ0FBQ3FELFNBQVNEO29DQUN0Q2hELE1BQU1BO29DQUNONEIsUUFBUTJCO29DQUNSMUIsYUFBYTs7Ozs7OzsyQkFoQlR6TixFQUFFc0IsQ0FBQzs7Ozs7b0JBb0JmO29CQUdEdEMsYUFBYWdFLE1BQU10RCxNQUFNLGtCQUN4Qiw4REFBQ3lPO3dCQUNDSixRQUFRL0ssTUFDTGpELEdBQUcsQ0FBQyxDQUFDSyxHQUFHVTs0QkFDUCxJQUFJVixNQUFNLE1BQU0sT0FBTzs0QkFDdkIsTUFBTTJGLElBQUlQLFFBQVExRTs0QkFDbEIsTUFBTWtGLE1BQU1uSCxXQUNSLENBQUNjLEtBQUtzRyxLQUFLLENBQUM3RixLQUFLVCxLQUFLc0csS0FBSyxDQUFDbEUsSUFBRyxJQUFNcEMsQ0FBQUEsS0FBS3NHLEtBQUssQ0FBQ3hELE9BQU85QyxLQUFLc0csS0FBSyxDQUFDbEUsT0FBTyxFQUFDLElBQzFFLENBQUMzQixJQUFJMkIsR0FBRSxJQUFLbUM7NEJBQ2hCLE1BQU1nQyxJQUFJLElBQUtkLENBQUFBLFlBQVlZLE1BQU1aLFNBQVE7NEJBQ3pDLE9BQU8sR0FBUWMsT0FBTEgsR0FBRSxLQUFLLE9BQUZHO3dCQUNqQixHQUNDa0ksTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxNQUFNLE1BQ2xCbEksSUFBSSxDQUFDO3dCQUNSeUYsTUFBSzt3QkFDTDRCLFFBQU87d0JBQ1BDLGFBQWE7d0JBQ2JhLGNBQWE7Ozs7OztvQkFJaEJ6TCxTQUFTOUMsR0FBRyxDQUFDLENBQUNDLEdBQUd5Rjt3QkFDaEIsTUFBTThJLFVBQVUvSSxRQUFRQzt3QkFDeEIsTUFBTU0sSUFBSXdJLFVBQVUxSSxjQUFjO3dCQUNsQyxNQUFNdUosV0FBV3BQLEVBQUVJLENBQUMsR0FBR2tMO3dCQUN2QixJQUFJK0QsT0FBT0QsV0FBWTNLLENBQUFBLE9BQU8sRUFBQzt3QkFFL0IsNEVBQTRFO3dCQUM1RSxNQUFNNkssZUFBZTt3QkFDckIsSUFBSUQsT0FBTyxLQUFLQSxPQUFPQyxjQUFjRCxPQUFPQzt3QkFFNUMsTUFBTXBKLElBQUl4QixTQUFVRCxDQUFBQSxPQUFPNEssSUFBRzt3QkFDOUIsTUFBTUwsU0FBU2hQLEVBQUVDLENBQUMsSUFBSUQsRUFBRWdCLENBQUM7d0JBRXpCLGtFQUFrRTt3QkFDbEUsTUFBTXVPLGFBQWEsSUFBSTVKLEtBQUszRixFQUFFc0IsQ0FBQzt3QkFDL0IsTUFBTTRJLE9BQU9xRixXQUFXN0YsUUFBUTt3QkFDaEMsTUFBTVMsU0FBU29GLFdBQVczRixVQUFVO3dCQUNwQyxNQUFNNEYsZ0JBQWdCdEYsT0FBTyxLQUFLQzt3QkFDbEMsTUFBTXNGLGFBQWEsSUFBSSxLQUFLLElBQUksVUFBVTt3QkFDMUMsTUFBTUMsY0FBYyxLQUFLLElBQUksVUFBVTt3QkFDdkMsTUFBTUMsa0JBQWtCSCxnQkFBZ0JDLGNBQWNELGlCQUFpQkU7d0JBRXZFLHFCQUNFLDhEQUFDbko7NEJBRUNSLEdBQUdBOzRCQUNIRyxHQUFHQTs0QkFDSFcsT0FBT2hCOzRCQUNQK0csUUFBUXlDOzRCQUNSekQsTUFBTW9ELFNBQVMseUJBQXlCOzRCQUN4Q1ksU0FBU0Qsa0JBQWtCLE1BQU07MkJBTjVCM1AsRUFBRXNCLENBQUMsR0FBRzs7Ozs7b0JBU2pCO29CQUNDeEMsYUFBYW1FLE1BQU12RCxNQUFNLGtCQUN4Qiw4REFBQ3lPO3dCQUNDSixRQUFROUssTUFDTGxELEdBQUcsQ0FBQyxDQUFDSyxHQUFHVTs0QkFDUCxJQUFJVixNQUFNLE1BQU0sT0FBTzs0QkFDdkIsTUFBTTJGLElBQUlQLFFBQVExRTs0QkFDbEIsTUFBTStPLFFBQVF6UCxJQUFJa0w7NEJBQ2xCLE1BQU0rRCxPQUFPUSxRQUFTcEwsQ0FBQUEsT0FBTyxFQUFDOzRCQUM5QixNQUFNeUIsSUFBSXhCLFNBQVVELENBQUFBLE9BQU80SyxJQUFHOzRCQUM5QixPQUFPLEdBQVFuSixPQUFMSCxHQUFFLEtBQUssT0FBRkc7d0JBQ2pCLEdBQ0NrSSxNQUFNLENBQUNDLENBQUFBLElBQUtBLE1BQU0sTUFDbEJsSSxJQUFJLENBQUM7d0JBQ1J5RixNQUFLO3dCQUNMNEIsUUFBTzt3QkFDUEMsYUFBYTt3QkFDYmEsY0FBYTs7Ozs7O29CQUdoQmxJLGNBQ0MsQ0FBQzt3QkFDQyxNQUFNTCxJQUFJUCxRQUFRckc7d0JBQ2xCLE1BQU0rRyxJQUFJLElBQUtkLENBQUFBLFlBQVksQ0FBRWdCLFdBQVduRyxDQUFDLEdBQUc4QixHQUFFLElBQUttQyxPQUFRa0IsU0FBUTt3QkFDbkUscUJBQ0UsOERBQUM4SDs7OENBQ0MsOERBQUNDO29DQUNDQyxJQUFJckg7b0NBQ0pzSCxJQUFJdEg7b0NBQ0p1SCxJQUFJO29DQUNKQyxJQUFJN0k7b0NBQ0o4SSxRQUFRdE8sVUFBVSxVQUFVLFlBQVk7b0NBQ3hDNFEsaUJBQWdCO29DQUNoQnJDLGFBQWE7Ozs7Ozs4Q0FFZiw4REFBQ047b0NBQ0NDLElBQUk7b0NBQ0pDLElBQUl4STtvQ0FDSnlJLElBQUlwSDtvQ0FDSnFILElBQUlySDtvQ0FDSnNILFFBQVF0TyxVQUFVLFVBQVUsWUFBWTtvQ0FDeEM0USxpQkFBZ0I7b0NBQ2hCckMsYUFBYTs7Ozs7OzhDQUVmLDhEQUFDc0M7b0NBQ0NDLElBQUlqSztvQ0FDSmtLLElBQUkvSjtvQ0FDSmdLLEdBQUc7b0NBQ0h0RSxNQUFLO29DQUNMNEIsUUFBUW5JLEtBQUsseUJBQXlCO29DQUN0Q29JLGFBQWE7Ozs7Ozs7Ozs7OztvQkFJckI7b0JBQ0Q1SyxTQUFTbkQsTUFBTSxHQUFHLEtBQ2pCLENBQUM7d0JBQ0MsTUFBTXlRLE9BQU90TixRQUFRLENBQUNBLFNBQVNuRCxNQUFNLEdBQUcsRUFBRTt3QkFDMUMsTUFBTXdHLElBQUksSUFBS2QsQ0FBQUEsWUFBWSxDQUFFK0ssS0FBS2xRLENBQUMsR0FBRzhCLEdBQUUsSUFBS21DLE9BQVFrQixTQUFRO3dCQUM3RCxNQUFNZ0wsT0FBT0QsS0FBS2xRLENBQUMsSUFBSWtELE1BQU0sQ0FBQyxFQUFFO3dCQUNoQyx3REFBd0Q7d0JBQ3hELE1BQU1rTixjQUFjLFdBQVcsb0JBQW9CO3dCQUNuRCxNQUFNQyxZQUFZLFdBQVcsYUFBYTt3QkFDMUMsTUFBTUMsUUFBUUgsT0FBT0MsY0FBY0M7d0JBRW5DLHFCQUNFLDhEQUFDcEQ7OzhDQUNDLDhEQUFDQztvQ0FDQ0MsSUFBSWpJO29DQUNKa0ksSUFBSWxJLFVBQVVHO29DQUNkZ0ksSUFBSXBIO29DQUNKcUgsSUFBSXJIO29DQUNKc0gsUUFBUStDO29DQUNSVCxpQkFBZ0I7b0NBQ2hCckMsYUFBYTs7Ozs7OzhDQUVmLDhEQUFDbEg7b0NBQ0NSLEdBQUdaLFVBQVVHLFNBQVM7b0NBQ3RCWSxHQUFHQSxJQUFJM0gsdURBQVlBLENBQUNpUyx1QkFBdUIsR0FBRztvQ0FDOUMzSixPQUFPdEksdURBQVlBLENBQUNrUyxzQkFBc0I7b0NBQzFDN0QsUUFBUXJPLHVEQUFZQSxDQUFDaVMsdUJBQXVCO29DQUM1QzVFLE1BQU13RSxPQUNEbFIsVUFBVSxVQUFVLFlBQVksWUFDaENBLFVBQVUsVUFBVSxZQUFZO29DQUNyQ3NPLFFBQVErQztvQ0FDUkcsSUFBSTs7Ozs7OzhDQUVOLDhEQUFDaEQ7b0NBQ0MzSCxHQUFHWixVQUFVRyxTQUFTLElBQUkvRyx1REFBWUEsQ0FBQ2tTLHNCQUFzQixHQUFHO29DQUNoRXZLLEdBQUdBLElBQUkzSCx1REFBWUEsQ0FBQ29TLDBCQUEwQixHQUFHO29DQUNqREMsWUFBVztvQ0FDWGhGLE1BQU0yRTtvQ0FDTi9ELFVBQVVqTyx1REFBWUEsQ0FBQ29TLDBCQUEwQjtvQ0FDakRFLFlBQVk7OENBRVhWLEtBQUtsUSxDQUFDLENBQUM0TixPQUFPLENBQUNwQzs7Ozs7Ozs7Ozs7O29CQUl4QjtvQkFHQTs0QkFJa0I1STt3QkFIbEIsTUFBTWlPLFNBQThGLEVBQUU7d0JBRXRHLHNCQUFzQjt3QkFDdEIsTUFBTUMsWUFBWWxPLEVBQUFBLGFBQUFBLFFBQVEsQ0FBQ0EsU0FBU25ELE1BQU0sR0FBRyxFQUFFLGNBQTdCbUQsaUNBQUFBLFdBQStCNUMsQ0FBQyxLQUFJO3dCQUN0RCxNQUFNK1EsU0FBUyxJQUFLNUwsQ0FBQUEsWUFBWSxDQUFFMkwsWUFBWWhQLEdBQUUsSUFBS21DLE9BQVFrQixTQUFRO3dCQUVyRSxRQUFRO3dCQUNSLElBQUlwRyxhQUFhZ0UsTUFBTXRELE1BQU0sR0FBRyxHQUFHOzRCQUNqQyxNQUFNdVIsVUFBVWpPLEtBQUssQ0FBQ0EsTUFBTXRELE1BQU0sR0FBRyxFQUFFOzRCQUN2QyxJQUFJdVIsWUFBWSxNQUFNO2dDQUNwQkgsT0FBT3pQLElBQUksQ0FBQztvQ0FDVjZFLEdBQUcsSUFBS2QsQ0FBQUEsWUFBWSxDQUFFNkwsVUFBVWxQLEdBQUUsSUFBS21DLE9BQVFrQixTQUFRO29DQUN2RDhMLE9BQU9EO29DQUNQVixPQUFPO29DQUNQWSxTQUFTalMsVUFBVSxVQUFVLFlBQVk7b0NBQ3pDc08sUUFBUTtnQ0FDVjs0QkFDRjt3QkFDRjt3QkFFQSx3QkFBd0I7d0JBQ3hCLElBQUl6TyxzQkFBc0JtRSxlQUFlM0MsS0FBSyxDQUFDYixNQUFNLEdBQUcsR0FBRzs0QkFDekQsTUFBTTBSLFlBQVlsTyxlQUFlM0MsS0FBSyxDQUFDMkMsZUFBZTNDLEtBQUssQ0FBQ2IsTUFBTSxHQUFHLEVBQUU7NEJBQ3ZFLElBQUkwUixjQUFjLE1BQU07Z0NBQ3RCTixPQUFPelAsSUFBSSxDQUFDO29DQUNWNkUsR0FBRyxJQUFLZCxDQUFBQSxZQUFZLENBQUVnTSxZQUFZclAsR0FBRSxJQUFLbUMsT0FBUWtCLFNBQVE7b0NBQ3pEOEwsT0FBT0U7b0NBQ1BiLE9BQU87b0NBQ1BZLFNBQVNqUyxVQUFVLFVBQVUsWUFBWTtvQ0FDekNzTyxRQUFRO2dDQUNWOzRCQUNGO3dCQUNGO3dCQUVBLHdCQUF3Qjt3QkFDeEIsSUFBSXpPLHNCQUFzQm1FLGVBQWUxQyxLQUFLLENBQUNkLE1BQU0sR0FBRyxHQUFHOzRCQUN6RCxNQUFNMlIsWUFBWW5PLGVBQWUxQyxLQUFLLENBQUMwQyxlQUFlMUMsS0FBSyxDQUFDZCxNQUFNLEdBQUcsRUFBRTs0QkFDdkUsSUFBSTJSLGNBQWMsTUFBTTtnQ0FDdEJQLE9BQU96UCxJQUFJLENBQUM7b0NBQ1Y2RSxHQUFHLElBQUtkLENBQUFBLFlBQVksQ0FBRWlNLFlBQVl0UCxHQUFFLElBQUttQyxPQUFRa0IsU0FBUTtvQ0FDekQ4TCxPQUFPRztvQ0FDUGQsT0FBTztvQ0FDUFksU0FBU2pTLFVBQVUsVUFBVSxZQUFZO29DQUN6Q3NPLFFBQVE7Z0NBQ1Y7NEJBQ0Y7d0JBQ0Y7d0JBRUEscUNBQXFDO3dCQUNyQyxNQUFNOEQsU0FBUy9TLHVEQUFZQSxDQUFDZ1Qsc0JBQXNCLEdBQUc7d0JBQ3JELE1BQU1DLGlCQUFpQlYsT0FBTy9RLEdBQUcsQ0FBQyxDQUFDaUs7NEJBQ2pDLElBQUl5SCxZQUFZekgsTUFBTTlELENBQUM7NEJBRXZCLHNDQUFzQzs0QkFDdEMsSUFBSXZHLEtBQUs2TCxHQUFHLENBQUNpRyxZQUFZVCxVQUFVTSxRQUFRO2dDQUN6Qyx5REFBeUQ7Z0NBQ3pELElBQUlHLFlBQVlULFFBQVE7b0NBQ3RCLDJDQUEyQztvQ0FDM0NTLFlBQVlULFNBQVNNO2dDQUN2QixPQUFPO29DQUNMLDZDQUE2QztvQ0FDN0NHLFlBQVlULFNBQVNNO2dDQUN2Qjs0QkFDRjs0QkFFQSxPQUFPO2dDQUFFLEdBQUd0SCxLQUFLO2dDQUFFOUQsR0FBR3VMOzRCQUFVO3dCQUNsQzt3QkFFQSxnRUFBZ0U7d0JBQ2hFRCxlQUFlOU4sSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUV1QyxDQUFDLEdBQUd0QyxFQUFFc0MsQ0FBQzt3QkFDdkMsSUFBSyxJQUFJcEYsSUFBSSxHQUFHQSxJQUFJMFEsZUFBZTlSLE1BQU0sRUFBRW9CLElBQUs7NEJBQzlDLElBQUkwUSxjQUFjLENBQUMxUSxFQUFFLENBQUNvRixDQUFDLEdBQUdzTCxjQUFjLENBQUMxUSxJQUFJLEVBQUUsQ0FBQ29GLENBQUMsR0FBR29MLFFBQVE7Z0NBQzFERSxjQUFjLENBQUMxUSxFQUFFLENBQUNvRixDQUFDLEdBQUdzTCxjQUFjLENBQUMxUSxJQUFJLEVBQUUsQ0FBQ29GLENBQUMsR0FBR29MOzRCQUNsRDt3QkFDRjt3QkFFQSxPQUFPRSxlQUFlelIsR0FBRyxDQUFDLENBQUNpSyxPQUFPdkUsb0JBQ2hDLDhEQUFDeUg7O2tEQUNDLDhEQUFDM0c7d0NBQ0NSLEdBQUdaLFVBQVVHLFNBQVM7d0NBQ3RCWSxHQUFHOEQsTUFBTTlELENBQUMsR0FBRzNILHVEQUFZQSxDQUFDZ1Qsc0JBQXNCLEdBQUc7d0NBQ25EMUssT0FBT3RJLHVEQUFZQSxDQUFDbVQscUJBQXFCO3dDQUN6QzlFLFFBQVFyTyx1REFBWUEsQ0FBQ2dULHNCQUFzQjt3Q0FDM0MzRixNQUFNNUIsTUFBTW1ILE9BQU87d0NBQ25CM0QsUUFBUXhELE1BQU13RCxNQUFNO3dDQUNwQmtELElBQUk7Ozs7OztrREFFTiw4REFBQ2hEO3dDQUNDM0gsR0FBR1osVUFBVUcsU0FBUyxJQUFJL0csdURBQVlBLENBQUNtVCxxQkFBcUIsR0FBRzt3Q0FDL0R4TCxHQUFHOEQsTUFBTTlELENBQUMsR0FBRzNILHVEQUFZQSxDQUFDb1QseUJBQXlCLEdBQUc7d0NBQ3REZixZQUFXO3dDQUNYaEYsTUFBTTVCLE1BQU11RyxLQUFLO3dDQUNqQi9ELFVBQVVqTyx1REFBWUEsQ0FBQ29ULHlCQUF5Qjt3Q0FDaERkLFlBQVk7a0RBRVg3RyxNQUFNa0gsS0FBSyxDQUFDckQsT0FBTyxDQUFDcEM7Ozs7Ozs7K0JBbEJqQixtQkFBdUIsT0FBSmhHOzs7OztvQkFzQi9CO29CQUVDNEQsVUFBVXRKLEdBQUcsQ0FBQyxDQUFDdUIsR0FBR1Isa0JBQ2pCLDhEQUFDNE07NEJBRUMzSCxHQUFHekUsRUFBRXlFLENBQUM7NEJBQ05HLEdBQUdqRixJQUFJOzRCQUNQMlAsWUFBVzs0QkFDWHBFLFVBQVVqTyx1REFBWUEsQ0FBQ3FULGdCQUFnQjs0QkFDdkNoRyxNQUFNMU0sVUFBVSxVQUFVLFlBQVk7c0NBRXJDb0MsRUFBRTBJLEtBQUs7MkJBUEgsWUFBWWxKOzs7Ozs7Ozs7OztZQVd0QnNGLGNBQWMsQ0FBQztnQkFDZCxNQUFNeUwsU0FBU3JNLFFBQVFyRztnQkFDdkIsTUFBTTJTLGdCQUFnQixDQUFFRCxTQUFTMU0sT0FBTSxJQUFLRyxTQUFVO2dCQUV0RCwyREFBMkQ7Z0JBQzNELDJEQUEyRDtnQkFDM0QseURBQXlEO2dCQUN6RCxrQ0FBa0M7Z0JBRWxDLElBQUl5TTtnQkFDSixJQUFJQztnQkFDSixJQUFJQztnQkFFSixJQUFJSCxnQkFBZ0IsSUFBSTtvQkFDdEIsOENBQThDO29CQUM5Q0MsVUFBVSxHQUFpQixPQUFkRCxlQUFjO29CQUMzQkcsWUFBWTtnQkFDZCxPQUFPLElBQUlILGdCQUFnQixJQUFJO29CQUM3Qiw4Q0FBOEM7b0JBQzlDQyxVQUFVLEdBQWlCLE9BQWRELGVBQWM7b0JBQzNCRyxZQUFZO2dCQUNkLE9BQU87b0JBQ0wsa0NBQWtDO29CQUNsQ0YsVUFBVSxHQUFpQixPQUFkRCxlQUFjO29CQUMzQkcsWUFBWTtnQkFDZDtnQkFFQSxxQkFDRSw4REFBQzdGO29CQUNDQyxPQUFPO3dCQUNMQyxVQUFVO3dCQUNWM0YsTUFBTW9MO3dCQUNORyxPQUFPRjt3QkFDUEcsS0FBSzt3QkFDTEMsWUFBWWxULFVBQVUsVUFBVSwyQkFBMkI7d0JBQzNEbVQsU0FBUzt3QkFDVEMsY0FBYzt3QkFDZEMsZUFBZTt3QkFDZkMsUUFBUXRULFVBQVUsVUFBVSxzQkFBc0I7d0JBQ2xEdVQsWUFBWTt3QkFDWkMsZ0JBQWdCO3dCQUNoQm5DLE9BQU9yUixVQUFVLFVBQVUsWUFBWTt3QkFDdkMrUztvQkFDRjs7c0NBRUEsOERBQUM3Rjs0QkFBSUMsT0FBTztnQ0FBRUcsVUFBVTtnQ0FBSW9ELFNBQVM7NEJBQUk7c0NBQ3RDLElBQUlqSyxLQUFLUyxXQUFXOUUsQ0FBQyxFQUFFNEosY0FBYzs7Ozs7O3NDQUV4Qyw4REFBQ2tCOzRCQUFJQyxPQUFPO2dDQUFFd0UsWUFBWTs0QkFBSTtzQ0FBSXpLLFdBQVduRyxDQUFDLENBQUM0TixPQUFPLENBQUM7Ozs7Ozs7Ozs7OztZQUc3RDs7Ozs7OztBQUdOO0dBeDFCd0JwUDs7UUFVSkQsOERBQU9BOzs7S0FWSEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvZGFzaGJvYXJkL0FkdmFuY2VkUHJpY2VDaGFydC50c3g/Y2U3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IFJhbmdlS2V5IH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XHJcbmltcG9ydCB7IExheW91dENvbmZpZyB9IGZyb20gXCIuL2xheW91dENvbmZpZ1wiO1xyXG5pbXBvcnQgeyB1c2VBdXRoIH0gZnJvbSBcIi4uL2F1dGgtY29udGV4dC9BdXRoQ29udGV4dFwiO1xyXG5cclxuaW50ZXJmYWNlIENhbmRsZSB7XHJcbiAgdDogc3RyaW5nO1xyXG4gIG86IG51bWJlcjtcclxuICBoOiBudW1iZXI7XHJcbiAgbDogbnVtYmVyO1xyXG4gIGM6IG51bWJlcjtcclxuICB2OiBudW1iZXI7XHJcbn1cclxuaW50ZXJmYWNlIFByb3BzIHtcclxuICBkYXRhOiBDYW5kbGVbXTtcclxuICBtb2RlOiBcImxpbmVcIiB8IFwiY2FuZGxlc1wiO1xyXG4gIHJhbmdlOiBSYW5nZUtleTtcclxuICBsb2dTY2FsZTogYm9vbGVhbjtcclxuICBzaG93Vm9sTUE6IGJvb2xlYW47XHJcbiAgc2hvd0JvbGxpbmdlckJhbmRzPzogYm9vbGVhbjtcclxuICBzaG93RU1BMjA/OiBib29sZWFuO1xyXG4gIHN5bWJvbD86IHN0cmluZzsgLy8gb3B0aW9uYWwgc3ltYm9sIHRvIHNlbGYtZmV0Y2ggZnJvbSBZYWhvbyBpZiBkYXRhIG5vdCBwcm92aWRlZFxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBZHZhbmNlZFByaWNlQ2hhcnQoe1xyXG4gIGRhdGEsXHJcbiAgbW9kZSxcclxuICByYW5nZSxcclxuICBsb2dTY2FsZSxcclxuICBzaG93Vm9sTUEsXHJcbiAgc2hvd0JvbGxpbmdlckJhbmRzID0gZmFsc2UsXHJcbiAgc2hvd0VNQTIwID0gZmFsc2UsXHJcbiAgc3ltYm9sLFxyXG59OiBQcm9wcykge1xyXG4gIGNvbnN0IHsgdGhlbWUgfSA9IHVzZUF1dGgoKTtcclxuICBjb25zdCBbaG92ZXIsIHNldEhvdmVyXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG5cclxuICAvLyBOb3RlOiBzeW1ib2wgcHJvcCBkZWZpbmVkIGJ1dCBub3QgdXNlZCAtIGNoYXJ0IGlzIGRhdGEtZHJpdmVuIGZyb20gcGFyZW50J3MgZGF0YSBwcm9wXHJcbiAgLy8gUGFyZW50IChEYXNoYm9hcmRDbGllbnQpIGhhbmRsZXMgYWxsIGRhdGEgZmV0Y2hpbmcgdmlhIGFwaS5oaXN0b3J5KClcclxuICAvLyBCYWNrZW5kIGFscmVhZHkgZmV0Y2hlcyB0aGUgY29ycmVjdCByYW5nZSwgc28gd2UgdXNlIHNvdXJjZURhdGEgZGlyZWN0bHlcclxuXHJcbiAgY29uc3Qgc291cmNlRGF0YTogQ2FuZGxlW10gPSBkYXRhIHx8IFtdO1xyXG4gIFxyXG4gIGNvbnN0IFRBUkdFVF9QRVJfUkFOR0U6IFJlY29yZDxSYW5nZUtleSwgbnVtYmVyPiA9IHtcclxuICAgIFwiMWRcIjogMTgsXHJcbiAgICBcIjF3XCI6IDQwLFxyXG4gICAgXCIxbVwiOiA3MCxcclxuICAgIFwiM21cIjogOTAsXHJcbiAgICBcIjF5XCI6IDE0MCxcclxuICAgIFwiNXlcIjogMjIwLFxyXG4gIH07XHJcbiAgY29uc3QgdGFyZ2V0ID0gVEFSR0VUX1BFUl9SQU5HRVtyYW5nZV0gfHwgMTIwO1xyXG4gIGxldCBidWNrZXRTaXplID0gc291cmNlRGF0YS5sZW5ndGggPiB0YXJnZXQgPyBNYXRoLmNlaWwoc291cmNlRGF0YS5sZW5ndGggLyB0YXJnZXQpIDogMTtcclxuICBpZiAocmFuZ2UgPT09ICcxZCcpIGJ1Y2tldFNpemUgPSAxOyAvLyBuZXZlciBidWNrZXQgaW50cmFkYXkgc28gdGlja3MgYWxpZ24gd2l0aCByZWFsIHRpbWVzXHJcbiAgXHJcbiAgLy8gQ2FsY3VsYXRlIGluZGljYXRvcnMgb24gUkFXIHNvdXJjZURhdGEgQkVGT1JFIGJ1Y2tldGluZyBmb3IgbWF4aW11bSBhY2N1cmFjeVxyXG4gIGNvbnN0IHJhd0VtYTIwID0gc2hvd0VNQTIwID8gZW1hKHNvdXJjZURhdGEubWFwKChkOiBDYW5kbGUpID0+IGQuYyksIDIwKSA6IFtdO1xyXG4gIGNvbnN0IHJhd1ZvbE1BID0gc2hvd1ZvbE1BID8gc21hKHNvdXJjZURhdGEubWFwKChkOiBDYW5kbGUpID0+IGQudiksIDIwKSA6IFtdO1xyXG4gIGNvbnN0IHJhd0JvbGxpbmdlckJhbmRzID0gc2hvd0JvbGxpbmdlckJhbmRzIFxyXG4gICAgPyBjYWxjdWxhdGVCb2xsaW5nZXJCYW5kcyhzb3VyY2VEYXRhLm1hcCgoZDogQ2FuZGxlKSA9PiBkLmMpKSBcclxuICAgIDogeyB1cHBlcjogW10sIGxvd2VyOiBbXSwgbWlkZGxlOiBbXSB9O1xyXG4gIFxyXG4gIGZ1bmN0aW9uIGJ1Y2tldEFnZ3JlZ2F0ZShzcmM6IENhbmRsZVtdLCBzaXplOiBudW1iZXIpIHtcclxuICAgIGlmIChzaXplIDw9IDEpIHJldHVybiBzcmM7XHJcbiAgICBjb25zdCBvdXQ6IENhbmRsZVtdID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNyYy5sZW5ndGg7IGkgKz0gc2l6ZSkge1xyXG4gICAgICBjb25zdCBzbGljZSA9IHNyYy5zbGljZShpLCBpICsgc2l6ZSk7XHJcbiAgICAgIGlmICghc2xpY2UubGVuZ3RoKSBjb250aW51ZTtcclxuICAgICAgY29uc3QgbyA9IHNsaWNlWzBdLm87XHJcbiAgICAgIGNvbnN0IGMgPSBzbGljZVtzbGljZS5sZW5ndGggLSAxXS5jO1xyXG4gICAgICBsZXQgaCA9IC1JbmZpbml0eSxcclxuICAgICAgICBsID0gSW5maW5pdHksXHJcbiAgICAgICAgdiA9IDA7XHJcbiAgICAgIGZvciAoY29uc3QgcyBvZiBzbGljZSkge1xyXG4gICAgICAgIGlmIChzLmggPiBoKSBoID0gcy5oO1xyXG4gICAgICAgIGlmIChzLmwgPCBsKSBsID0gcy5sO1xyXG4gICAgICAgIHYgKz0gcy52O1xyXG4gICAgICB9XHJcbiAgICAgIG91dC5wdXNoKHsgdDogc2xpY2VbMF0udCwgbywgaCwgbCwgYywgdiB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXQ7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEJ1Y2tldCBpbmRpY2F0b3JzIGFsb25nc2lkZSB0aGUgZGF0YSAodGFrZSBldmVyeSBOdGggdmFsdWUgdG8gbWF0Y2ggYnVja2V0aW5nKVxyXG4gIGZ1bmN0aW9uIGJ1Y2tldEluZGljYXRvcih2YWx1ZXM6IChudW1iZXIgfCBudWxsKVtdLCBzaXplOiBudW1iZXIpOiAobnVtYmVyIHwgbnVsbClbXSB7XHJcbiAgICBpZiAoc2l6ZSA8PSAxKSByZXR1cm4gdmFsdWVzO1xyXG4gICAgY29uc3Qgb3V0OiAobnVtYmVyIHwgbnVsbClbXSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IHNpemUpIHtcclxuICAgICAgb3V0LnB1c2godmFsdWVzW2ldKTsgLy8gVGFrZSB0aGUgZmlyc3QgdmFsdWUgb2YgZWFjaCBidWNrZXRcclxuICAgIH1cclxuICAgIHJldHVybiBvdXQ7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IGJhc2VEYXRhID0gYnVja2V0U2l6ZSA9PT0gMSA/IHNvdXJjZURhdGEgOiBidWNrZXRBZ2dyZWdhdGUoc291cmNlRGF0YSwgYnVja2V0U2l6ZSk7XHJcbiAgY29uc3QgYnVja2V0ZWRFbWEyMCA9IGJ1Y2tldFNpemUgPT09IDEgPyByYXdFbWEyMCA6IGJ1Y2tldEluZGljYXRvcihyYXdFbWEyMCwgYnVja2V0U2l6ZSk7XHJcbiAgY29uc3QgYnVja2V0ZWRWb2xNQSA9IGJ1Y2tldFNpemUgPT09IDEgPyByYXdWb2xNQSA6IGJ1Y2tldEluZGljYXRvcihyYXdWb2xNQSwgYnVja2V0U2l6ZSk7XHJcbiAgY29uc3QgYnVja2V0ZWRCb2xsaW5nZXJCYW5kcyA9IGJ1Y2tldFNpemUgPT09IDEgPyByYXdCb2xsaW5nZXJCYW5kcyA6IHtcclxuICAgIHVwcGVyOiBidWNrZXRJbmRpY2F0b3IocmF3Qm9sbGluZ2VyQmFuZHMudXBwZXIsIGJ1Y2tldFNpemUpLFxyXG4gICAgbG93ZXI6IGJ1Y2tldEluZGljYXRvcihyYXdCb2xsaW5nZXJCYW5kcy5sb3dlciwgYnVja2V0U2l6ZSksXHJcbiAgICBtaWRkbGU6IGJ1Y2tldEluZGljYXRvcihyYXdCb2xsaW5nZXJCYW5kcy5taWRkbGUsIGJ1Y2tldFNpemUpLFxyXG4gIH07XHJcbiAgXHJcbiAgLy8gQmFja2VuZCBmZXRjaGVzIGV4dHJhIGNhbmRsZXMgZm9yIGluZGljYXRvciBjYWxjdWxhdGlvbiAoMjAtNTAgZGVwZW5kaW5nIG9uIHJhbmdlKVxyXG4gIC8vIEFmdGVyIGJ1Y2tldGluZywgd2UgaGlkZSBwcm9wb3J0aW9uYWxseSBmZXdlciBjYW5kbGVzXHJcbiAgY29uc3QgYnVmZmVyUGVyUmFuZ2U6IFJlY29yZDxSYW5nZUtleSwgbnVtYmVyPiA9IHtcclxuICAgIFwiMWRcIjogNTAsICAgLy8gV29ya3MgcGVyZmVjdGx5XHJcbiAgICBcIjF3XCI6IDUwLCAgIC8vIE5vdyBtdWNoIHNtYWxsZXIgc2luY2UgaW5kaWNhdG9ycyBwcmUtY2FsY3VsYXRlZFxyXG4gICAgXCIxbVwiOiA1MCwgICAvLyBOb3cgbXVjaCBzbWFsbGVyIHNpbmNlIGluZGljYXRvcnMgcHJlLWNhbGN1bGF0ZWRcclxuICAgIFwiM21cIjogNTAsICAgLy8gUGVyZmVjdCBhbHJlYWR5XHJcbiAgICBcIjF5XCI6IDUwLCAgIC8vIFdvcmtzIHBlcmZlY3RseVxyXG4gICAgXCI1eVwiOiA1MCwgICAvLyBXb3JrcyBwZXJmZWN0bHlcclxuICB9O1xyXG4gIGNvbnN0IGJ1ZmZlckNhbmRsZXMgPSBNYXRoLm1pbihidWZmZXJQZXJSYW5nZVtyYW5nZV0sIE1hdGguZmxvb3IoYmFzZURhdGEubGVuZ3RoICogMC4yKSk7XHJcbiAgY29uc3QgZGlzcGxheURhdGEgPSBiYXNlRGF0YS5zbGljZShidWZmZXJDYW5kbGVzKTsgLy8gSGlkZSBmaXJzdCBjYW5kbGVzIGZyb20gdXNlclxyXG4gIFxyXG4gIGNvbnN0IFt3aW5kb3dJZHgsIHNldFdpbmRvd0lkeF0gPSBSZWFjdC51c2VTdGF0ZTxbbnVtYmVyLCBudW1iZXJdPigoKSA9PiBbMCwgZGlzcGxheURhdGEubGVuZ3RoIC0gMV0pO1xyXG4gIC8vIFJlc2V0IHdpbmRvdyB3aGVuIGRpc3BsYXlEYXRhIGxlbmd0aCBjaGFuZ2VzIChyYW5nZSBjaGFuZ2Ugb3IgbmV3IGRhdGEpXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHNldFdpbmRvd0lkeChbMCwgZGlzcGxheURhdGEubGVuZ3RoIC0gMV0pO1xyXG4gIH0sIFtkaXNwbGF5RGF0YS5sZW5ndGhdKTtcclxuICBcclxuICAvLyBBbHdheXMgc2hvdyBmdWxsIHJhbmdlIHVubGVzcyB1c2VyIHpvb21zL3BhbnMgKHdpbmRvd0lkeCBhY3RzIGFzIHVzZXIgb3ZlcnJpZGUgYWZ0ZXIgZmlyc3Qgd2hlZWwvZHJhZylcclxuICBjb25zdCBbd1N0YXJ0LCB3RW5kXSA9IHdpbmRvd0lkeDtcclxuICBjb25zdCBmdWxsU3RhcnQgPSAwO1xyXG4gIGNvbnN0IGZ1bGxFbmQgPSBkaXNwbGF5RGF0YS5sZW5ndGggLSAxO1xyXG4gIGNvbnN0IGVmZmVjdGl2ZVN0YXJ0ID1cclxuICAgIHdTdGFydCA9PT0gMCAmJiB3RW5kID09PSBkaXNwbGF5RGF0YS5sZW5ndGggLSAxID8gZnVsbFN0YXJ0IDogTWF0aC5tYXgoMCwgTWF0aC5taW4od1N0YXJ0LCBmdWxsRW5kKSk7XHJcbiAgY29uc3QgZWZmZWN0aXZlRW5kID0gd1N0YXJ0ID09PSAwICYmIHdFbmQgPT09IGRpc3BsYXlEYXRhLmxlbmd0aCAtIDEgPyBmdWxsRW5kIDogTWF0aC5taW4od0VuZCwgZnVsbEVuZCk7XHJcbiAgY29uc3Qgc2FmZUVuZCA9IE1hdGgubWluKGVmZmVjdGl2ZUVuZCwgZGlzcGxheURhdGEubGVuZ3RoIC0gMSk7XHJcbiAgY29uc3Qgc2FmZVN0YXJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZWZmZWN0aXZlU3RhcnQsIHNhZmVFbmQgLSA1KSk7XHJcbiAgY29uc3QgZHJhd0RhdGEgPSBkaXNwbGF5RGF0YS5zbGljZShzYWZlU3RhcnQsIHNhZmVFbmQgKyAxKTtcclxuICBcclxuICAvLyBTbGljZSBwcmUtY2FsY3VsYXRlZCBpbmRpY2F0b3JzIHRvIG1hdGNoIGRyYXdEYXRhIChvZmZzZXQgYnkgYnVmZmVyICsgd2luZG93KVxyXG4gIGNvbnN0IGluZGljYXRvclN0YXJ0ID0gYnVmZmVyQ2FuZGxlcyArIHNhZmVTdGFydDtcclxuICBjb25zdCBpbmRpY2F0b3JFbmQgPSBidWZmZXJDYW5kbGVzICsgc2FmZUVuZCArIDE7XHJcbiAgY29uc3QgZW1hMjAgPSBidWNrZXRlZEVtYTIwLnNsaWNlKGluZGljYXRvclN0YXJ0LCBpbmRpY2F0b3JFbmQpO1xyXG4gIGNvbnN0IHZvbE1BID0gYnVja2V0ZWRWb2xNQS5zbGljZShpbmRpY2F0b3JTdGFydCwgaW5kaWNhdG9yRW5kKTtcclxuICBjb25zdCBib2xsaW5nZXJCYW5kcyA9IHtcclxuICAgIHVwcGVyOiBidWNrZXRlZEJvbGxpbmdlckJhbmRzLnVwcGVyLnNsaWNlKGluZGljYXRvclN0YXJ0LCBpbmRpY2F0b3JFbmQpLFxyXG4gICAgbG93ZXI6IGJ1Y2tldGVkQm9sbGluZ2VyQmFuZHMubG93ZXIuc2xpY2UoaW5kaWNhdG9yU3RhcnQsIGluZGljYXRvckVuZCksXHJcbiAgICBtaWRkbGU6IGJ1Y2tldGVkQm9sbGluZ2VyQmFuZHMubWlkZGxlLnNsaWNlKGluZGljYXRvclN0YXJ0LCBpbmRpY2F0b3JFbmQpLFxyXG4gIH07XHJcbiAgXHJcbiAgY29uc3QgY2xvc2VzID0gZHJhd0RhdGEubWFwKChkOiBDYW5kbGUpID0+IGQuYyksXHJcbiAgICBoaWdocyA9IGRyYXdEYXRhLm1hcCgoZDogQ2FuZGxlKSA9PiBkLmgpLFxyXG4gICAgbG93cyA9IGRyYXdEYXRhLm1hcCgoZDogQ2FuZGxlKSA9PiBkLmwpO1xyXG4gIGZ1bmN0aW9uIHF1YW50aWxlKGFycjogbnVtYmVyW10sIHE6IG51bWJlcikge1xyXG4gICAgaWYgKCFhcnIubGVuZ3RoKSByZXR1cm4gMDtcclxuICAgIGNvbnN0IHNvcnRlZCA9IFsuLi5hcnJdLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuICAgIGNvbnN0IHBvcyA9IChzb3J0ZWQubGVuZ3RoIC0gMSkgKiBxO1xyXG4gICAgY29uc3QgYmFzZSA9IE1hdGguZmxvb3IocG9zKTtcclxuICAgIGNvbnN0IHJlc3QgPSBwb3MgLSBiYXNlO1xyXG4gICAgcmV0dXJuIHNvcnRlZFtiYXNlICsgMV0gIT09IHVuZGVmaW5lZFxyXG4gICAgICA/IHNvcnRlZFtiYXNlXSArIHJlc3QgKiAoc29ydGVkW2Jhc2UgKyAxXSAtIHNvcnRlZFtiYXNlXSlcclxuICAgICAgOiBzb3J0ZWRbYmFzZV07XHJcbiAgfVxyXG4gIGxldCBtaW4gPSBxdWFudGlsZShsb3dzLCAwLjAwNSksXHJcbiAgICBtYXggPSBxdWFudGlsZShoaWdocywgMC45OTUpO1xyXG4gIGNvbnN0IGxhc3RDID0gZHJhd0RhdGFbZHJhd0RhdGEubGVuZ3RoIC0gMV07XHJcbiAgaWYgKGxhc3RDKSB7XHJcbiAgICBpZiAobGFzdEMubCA8IG1pbikgbWluID0gbGFzdEMubDtcclxuICAgIGlmIChsYXN0Qy5oID4gbWF4KSBtYXggPSBsYXN0Qy5oO1xyXG4gIH1cclxuICBjb25zdCBzcGFuID0gbWF4IC0gbWluIHx8IDE7XHJcbiAgLy8gU2luZ2xlIHNjYWxlIHZhcmlhYmxlXHJcbiAgY29uc3QgUyA9IExheW91dENvbmZpZy5DSEFSVF9TQ0FMRTsgLy8gYWZmZWN0cyB2ZXJ0aWNhbCByZWFsIGVzdGF0ZVxyXG4gIGNvbnN0IGhWaXN1YWxCYXNlID0gTGF5b3V0Q29uZmlnLkdSQVBIX0hFSUdIVDsgLy8gYmFzZWxpbmUgdmlzdWFsIGhlaWdodCBmcm9tIGNvbmZpZ1xyXG4gIGNvbnN0IHZvbHVtZVBvcnRpb24gPSAwLjIzOyAvLyBmcmFjdGlvbiByZXNlcnZlZCBmb3Igdm9sdW1lIGFyZWFcclxuICBjb25zdCBoVmlzdWFsID0gaFZpc3VhbEJhc2UgKiBTO1xyXG4gIGNvbnN0IHZvbEggPSBoVmlzdWFsICogdm9sdW1lUG9ydGlvbjtcclxuICBjb25zdCBwcmljZUggPSBoVmlzdWFsIC0gdm9sSDtcclxuICBjb25zdCBheGlzRm9vdGVyID0gTGF5b3V0Q29uZmlnLkFYSVNfRk9PVEVSX0hFSUdIVDtcclxuICBjb25zdCBoID0gaFZpc3VhbCArIGF4aXNGb290ZXI7XHJcbiAgY29uc3QgdyA9IExheW91dENvbmZpZy5HUkFQSF9XSURUSDtcclxuICBjb25zdCBndXR0ZXJSaWdodCA9IExheW91dENvbmZpZy5BWElTX1JJR0hUX0dVVFRFUjtcclxuICBjb25zdCBwYWRUb3AgPSA4LFxyXG4gICAgcGFkQm90dG9tID0gNixcclxuICAgIHBhZExlZnQgPSA0O1xyXG4gIGNvbnN0IHByaWNlQXJlYSA9IHByaWNlSCAtIHBhZFRvcCAtIHBhZEJvdHRvbTtcclxuICBjb25zdCB1cCA9IGNsb3Nlc1tjbG9zZXMubGVuZ3RoIC0gMV0gPj0gY2xvc2VzWzBdO1xyXG4gIGNvbnN0IHByaWNlVyA9IHcgLSBndXR0ZXJSaWdodCAtIHBhZExlZnQ7XHJcbiAgXHJcbiAgLy8gSW5kZXgtYmFzZWQgaG9yaXpvbnRhbCBzY2FsZSAocmVtb3ZlcyB0aW1lIGdhcHMgZm9yIGNvbnRpbnVvdXMgZGlzcGxheSlcclxuICBjb25zdCBudW1DYW5kbGVzID0gZHJhd0RhdGEubGVuZ3RoO1xyXG4gIGZ1bmN0aW9uIHhGb3JJZHgoaWR4OiBudW1iZXIpIHsgcmV0dXJuIHBhZExlZnQgKyAoaWR4IC8gTWF0aC5tYXgoMSwgbnVtQ2FuZGxlcyAtIDEpKSAqIHByaWNlVzsgfVxyXG4gIFxyXG4gIC8vIFN0b3JlIHRpbWVzdGFtcHMgZm9yIGxhYmVsc1xyXG4gIGNvbnN0IGRyYXdUaW1lcyA9IGRyYXdEYXRhLm1hcChkID0+IG5ldyBEYXRlKGQudCkuZ2V0VGltZSgpKTtcclxuICBcclxuICAvLyBBZGFwdGl2ZSBjYW5kbGUgd2lkdGggZnJvbSBkYXRhIGRlbnNpdHlcclxuICBsZXQgY2FuZGxlV2lkdGg6IG51bWJlcjtcclxuICBpZiAobnVtQ2FuZGxlcyA8PSAyKSB7XHJcbiAgICBjYW5kbGVXaWR0aCA9IChwcmljZVcgLyBNYXRoLm1heCgxLCBudW1DYW5kbGVzKSkgKiAwLjY7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNhbmRsZVdpZHRoID0gKHByaWNlVyAvIG51bUNhbmRsZXMpICogMC44O1xyXG4gIH1cclxuICBpZiAoY2FuZGxlV2lkdGggPCAzKSBjYW5kbGVXaWR0aCA9IDM7IGlmIChjYW5kbGVXaWR0aCA+IDIyKSBjYW5kbGVXaWR0aCA9IDIyO1xyXG4gIGNvbnN0IGxpbmVQdHMgPSBkcmF3RGF0YS5tYXAoKGQsIGlkeCkgPT4ge1xyXG4gICAgY29uc3QgeCA9IHhGb3JJZHgoaWR4KTtcclxuICAgIGNvbnN0IHZhbCA9IGxvZ1NjYWxlID8gKE1hdGgubG9nMTAoZC5jKSAtIE1hdGgubG9nMTAobWluKSkgLyAoTWF0aC5sb2cxMChtYXgpIC0gTWF0aC5sb2cxMChtaW4gfHwgMSkpIDogKGQuYyAtIG1pbikgLyBzcGFuO1xyXG4gICAgY29uc3QgeSA9IHBhZFRvcCArIChwcmljZUFyZWEgLSB2YWwgKiBwcmljZUFyZWEpO1xyXG4gICAgcmV0dXJuIGAke3h9LCR7eX1gO1xyXG4gIH0pLmpvaW4oXCIgXCIpO1xyXG4gIGNvbnN0IGhvdmVyUG9pbnQgPSBob3ZlciAhPSBudWxsID8gZHJhd0RhdGFbaG92ZXJdIDogbnVsbDtcclxuICBmdW5jdGlvbiBvbk1vdmUoZTogUmVhY3QuTW91c2VFdmVudDxTVkdTVkdFbGVtZW50Pikge1xyXG4gICAgY29uc3QgcmVjdCA9IGUuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSByZWN0LmxlZnQ7XHJcbiAgICBcclxuICAgIC8vIEluZGV4LWJhc2VkIGhvdmVyOiBmaW5kIG5lYXJlc3QgY2FuZGxlIGJ5IHggcG9zaXRpb25cclxuICAgIGlmIChkcmF3RGF0YS5sZW5ndGggPT09IDApIHJldHVybjtcclxuICAgIFxyXG4gICAgY29uc3QgeFJhdGlvID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHggLSBwYWRMZWZ0KSAvIChyZWN0LndpZHRoIC0gKGd1dHRlclJpZ2h0IC8gdykgKiByZWN0LndpZHRoKSkpO1xyXG4gICAgY29uc3QgaWR4ID0gTWF0aC5yb3VuZCh4UmF0aW8gKiAobnVtQ2FuZGxlcyAtIDEpKTtcclxuICAgIFxyXG4gICAgc2V0SG92ZXIoTWF0aC5tYXgoMCwgTWF0aC5taW4obnVtQ2FuZGxlcyAtIDEsIGlkeCkpKTtcclxuICB9XHJcbiAgY29uc3QgZHJhZ1N0YXRlID0gdXNlUmVmPHsgc3RhcnRYOiBudW1iZXI7IHN0YXJ0UmFuZ2U6IFtudW1iZXIsIG51bWJlcl0gfSB8IG51bGw+KG51bGwpO1xyXG4gIGZ1bmN0aW9uIG9uV2hlZWwoZTogUmVhY3QuV2hlZWxFdmVudDxTVkdTVkdFbGVtZW50Pikge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgaWYgKGRyYXdEYXRhLmxlbmd0aCA8IDEwKSByZXR1cm47XHJcbiAgICBjb25zdCBkZWx0YSA9IGUuZGVsdGFZO1xyXG4gICAgY29uc3QgZmFjdG9yID0gZGVsdGEgPiAwID8gMS4xIDogMC45O1xyXG4gICAgY29uc3QgY3VycmVudExlbiA9IHdFbmQgLSB3U3RhcnQgKyAxO1xyXG4gICAgY29uc3QgbmV3TGVuID0gTWF0aC5tYXgoMjAsIE1hdGgubWluKGRpc3BsYXlEYXRhLmxlbmd0aCwgTWF0aC5yb3VuZChjdXJyZW50TGVuICogZmFjdG9yKSkpO1xyXG4gICAgY29uc3QgcmVjdCA9IChlLmN1cnJlbnRUYXJnZXQgYXMgU1ZHU1ZHRWxlbWVudCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBjb25zdCB4UmF0aW8gPSAoZS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gcGFkTGVmdCkgLyAocmVjdC53aWR0aCAtIGd1dHRlclJpZ2h0KTtcclxuICAgIGNvbnN0IGZvY3VzSWR4ID0gd1N0YXJ0ICsgTWF0aC5yb3VuZChjdXJyZW50TGVuICogeFJhdGlvKTtcclxuICAgIGxldCBuZXdTdGFydCA9IGZvY3VzSWR4IC0gTWF0aC5yb3VuZChuZXdMZW4gKiB4UmF0aW8pO1xyXG4gICAgbGV0IG5ld0VuZCA9IG5ld1N0YXJ0ICsgbmV3TGVuIC0gMTtcclxuICAgIGlmIChuZXdTdGFydCA8IDApIHtcclxuICAgICAgbmV3U3RhcnQgPSAwO1xyXG4gICAgICBuZXdFbmQgPSBuZXdMZW4gLSAxO1xyXG4gICAgfVxyXG4gICAgaWYgKG5ld0VuZCA+IGRpc3BsYXlEYXRhLmxlbmd0aCAtIDEpIHtcclxuICAgICAgbmV3RW5kID0gZGlzcGxheURhdGEubGVuZ3RoIC0gMTtcclxuICAgICAgbmV3U3RhcnQgPSBuZXdFbmQgLSBuZXdMZW4gKyAxO1xyXG4gICAgfVxyXG4gICAgc2V0V2luZG93SWR4KFtuZXdTdGFydCwgbmV3RW5kXSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZTogUmVhY3QuUG9pbnRlckV2ZW50PFNWR1NWR0VsZW1lbnQ+KSB7XHJcbiAgICBlLmN1cnJlbnRUYXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpO1xyXG4gICAgZHJhZ1N0YXRlLmN1cnJlbnQgPSB7IHN0YXJ0WDogZS5jbGllbnRYLCBzdGFydFJhbmdlOiB3aW5kb3dJZHggfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gb25Qb2ludGVyTW92ZShlOiBSZWFjdC5Qb2ludGVyRXZlbnQ8U1ZHU1ZHRWxlbWVudD4pIHtcclxuICAgIGlmICghZHJhZ1N0YXRlLmN1cnJlbnQpIHJldHVybjtcclxuICAgIGNvbnN0IFtzLCBlSWR4XSA9IGRyYWdTdGF0ZS5jdXJyZW50LnN0YXJ0UmFuZ2U7XHJcbiAgICBjb25zdCBsZW4gPSBlSWR4IC0gcyArIDE7XHJcbiAgICBjb25zdCBwaXhlbFBlckNhbmRsZSA9IHByaWNlVyAvIGRyYXdEYXRhLmxlbmd0aDtcclxuICAgIGNvbnN0IGRlbHRhUHggPSBlLmNsaWVudFggLSBkcmFnU3RhdGUuY3VycmVudC5zdGFydFg7XHJcbiAgICBjb25zdCBzaGlmdCA9IE1hdGgucm91bmQoLWRlbHRhUHggLyBwaXhlbFBlckNhbmRsZSk7XHJcbiAgICBsZXQgbmV3U3RhcnQgPSBzICsgc2hpZnQ7XHJcbiAgICBsZXQgbmV3RW5kID0gbmV3U3RhcnQgKyBsZW4gLSAxO1xyXG4gICAgaWYgKG5ld1N0YXJ0IDwgMCkge1xyXG4gICAgICBuZXdTdGFydCA9IDA7XHJcbiAgICAgIG5ld0VuZCA9IGxlbiAtIDE7XHJcbiAgICB9XHJcbiAgICBpZiAobmV3RW5kID4gZGlzcGxheURhdGEubGVuZ3RoIC0gMSkge1xyXG4gICAgICBuZXdFbmQgPSBkaXNwbGF5RGF0YS5sZW5ndGggLSAxO1xyXG4gICAgICBuZXdTdGFydCA9IG5ld0VuZCAtIGxlbiArIDE7XHJcbiAgICB9XHJcbiAgICBzZXRXaW5kb3dJZHgoW25ld1N0YXJ0LCBuZXdFbmRdKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gb25Qb2ludGVyVXAoKSB7XHJcbiAgICBkcmFnU3RhdGUuY3VycmVudCA9IG51bGw7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIG5pY2VUaWNrcyhsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB0YXJnZXQgPSA1KSB7XHJcbiAgICBjb25zdCByYXdTcGFuID0gaGlnaCAtIGxvdyB8fCAxO1xyXG4gICAgY29uc3Qgcm91Z2hTdGVwID0gcmF3U3BhbiAvICh0YXJnZXQgLSAxKTtcclxuICAgIGNvbnN0IHBvdzEwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2cxMChyb3VnaFN0ZXApKSk7XHJcbiAgICBjb25zdCBtdWx0aXBsZXMgPSBbMSwgMiwgMi41LCA1LCAxMF07XHJcbiAgICBjb25zdCBmb3VuZCA9IG11bHRpcGxlcy5maW5kKChtKSA9PiBtICogcG93MTAgPj0gcm91Z2hTdGVwKSB8fCBtdWx0aXBsZXNbbXVsdGlwbGVzLmxlbmd0aCAtIDFdO1xyXG4gICAgY29uc3Qgc3RlcCA9IGZvdW5kICogcG93MTA7XHJcbiAgICBjb25zdCBmaXJzdCA9IE1hdGguY2VpbChsb3cgLyBzdGVwKSAqIHN0ZXA7XHJcbiAgICBjb25zdCB0aWNrczogbnVtYmVyW10gPSBbXTtcclxuICAgIGZvciAobGV0IHYgPSBmaXJzdDsgdiA8PSBoaWdoOyB2ICs9IHN0ZXApIHRpY2tzLnB1c2godik7XHJcbiAgICByZXR1cm4gdGlja3M7XHJcbiAgfVxyXG4gIC8vIFRpbWUgdGlja3MgcGVyIGV4cGxpY2l0IHNwZWNcclxuICBjb25zdCB0aW1lVGlja3M6IEFycmF5PHsgeDogbnVtYmVyOyBsYWJlbDogc3RyaW5nIH0+ID0gW107XHJcbiAgaWYgKGRyYXdEYXRhLmxlbmd0aCA+IDEpIHtcclxuICAgIGlmIChyYW5nZSA9PT0gJzFkJykge1xyXG4gICAgICAvLyBTaG93IGxhYmVsIGV2ZXJ5IGhvdXIgZm9yIGNsZWFuZXIgZGlzcGxheVxyXG4gICAgICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcbiAgICAgIGRyYXdEYXRhLmZvckVhY2goKGMsIGlkeCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShjLnQpO1xyXG4gICAgICAgIGNvbnN0IGhoID0gZC5nZXRIb3VycygpO1xyXG4gICAgICAgIGNvbnN0IG1tID0gZC5nZXRNaW51dGVzKCk7XHJcbiAgICAgICAgLy8gU2hvdyBsYWJlbCBldmVyeSBob3VyIG9uIHRoZSBob3VyXHJcbiAgICAgICAgaWYgKG1tID09PSAwKSB7XHJcbiAgICAgICAgICBjb25zdCB0aW1lS2V5ID0gYCR7aGh9OjAwYDtcclxuICAgICAgICAgIGlmICghc2Vlbi5oYXModGltZUtleSkpIHtcclxuICAgICAgICAgICAgc2Vlbi5hZGQodGltZUtleSk7XHJcbiAgICAgICAgICAgIHRpbWVUaWNrcy5wdXNoKHsgXHJcbiAgICAgICAgICAgICAgeDogeEZvcklkeChpZHgpLCBcclxuICAgICAgICAgICAgICBsYWJlbDogZC50b0xvY2FsZVRpbWVTdHJpbmcoJ2VuLVVTJywgeyBob3VyOiAnbnVtZXJpYycsIG1pbnV0ZTogJzItZGlnaXQnLCBob3VyMTI6IGZhbHNlIH0pIFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmIChyYW5nZSA9PT0gJzF3Jykge1xyXG4gICAgICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCk7IGRyYXdEYXRhLmZvckVhY2goKGMsIGlkeCkgPT4geyBjb25zdCBkID0gbmV3IERhdGUoYy50KTsgY29uc3QgayA9IGQudG9EYXRlU3RyaW5nKCk7IGlmICghc2Vlbi5oYXMoaykpIHsgc2Vlbi5hZGQoayk7IHRpbWVUaWNrcy5wdXNoKHsgeDogeEZvcklkeChpZHgpLCBsYWJlbDogZC50b0xvY2FsZURhdGVTdHJpbmcodW5kZWZpbmVkLHsgd2Vla2RheTonc2hvcnQnfSkudG9VcHBlckNhc2UoKSB9KTsgfSB9KTtcclxuICAgIH0gZWxzZSBpZiAocmFuZ2UgPT09ICcxbScpIHtcclxuICAgICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpOyBkcmF3RGF0YS5mb3JFYWNoKChjLCBpZHgpID0+IHsgY29uc3QgZCA9IG5ldyBEYXRlKGMudCk7IGlmIChkLmdldERheSgpID09PSAxKSB7IGNvbnN0IGtleSA9IGQuZ2V0RnVsbFllYXIoKStcIi1cIitkLmdldE1vbnRoKCkrXCItXCIrZC5nZXREYXRlKCk7IGlmICghc2Vlbi5oYXMoa2V5KSkgeyBzZWVuLmFkZChrZXkpOyB0aW1lVGlja3MucHVzaCh7IHg6IHhGb3JJZHgoaWR4KSwgbGFiZWw6IChkLmdldE1vbnRoKCkrMSkrXCIvXCIrZC5nZXREYXRlKCkgfSk7IH0gfSB9KTtcclxuICAgIH0gZWxzZSBpZiAocmFuZ2UgPT09ICczbScpIHtcclxuICAgICAgbGV0IG1vbmRheUNvdW50ID0gMDsgZHJhd0RhdGEuZm9yRWFjaCgoYywgaWR4KSA9PiB7IGNvbnN0IGQgPSBuZXcgRGF0ZShjLnQpOyBpZiAoZC5nZXREYXkoKSA9PT0gMSkgeyBpZiAobW9uZGF5Q291bnQgJSAzID09PSAwKSB0aW1lVGlja3MucHVzaCh7IHg6IHhGb3JJZHgoaWR4KSwgbGFiZWw6IChkLmdldE1vbnRoKCkrMSkrXCIvXCIrZC5nZXREYXRlKCkgfSk7IG1vbmRheUNvdW50Kys7IH0gfSk7XHJcbiAgICB9IGVsc2UgaWYgKHJhbmdlID09PSAnMXknKSB7XHJcbiAgICAgIGNvbnN0IHNlZW5Nb250aCA9IG5ldyBTZXQ8c3RyaW5nPigpOyBkcmF3RGF0YS5mb3JFYWNoKChjLCBpZHgpID0+IHsgY29uc3QgZCA9IG5ldyBEYXRlKGMudCk7IGNvbnN0IG1rID0gZC5nZXRGdWxsWWVhcigpK1wiLVwiK2QuZ2V0TW9udGgoKTsgaWYgKCFzZWVuTW9udGguaGFzKG1rKSAmJiBkLmdldERhdGUoKSA8PSA3KSB7IHNlZW5Nb250aC5hZGQobWspOyB0aW1lVGlja3MucHVzaCh7IHg6IHhGb3JJZHgoaWR4KSwgbGFiZWw6IGQudG9Mb2NhbGVTdHJpbmcodW5kZWZpbmVkLHsgbW9udGg6J3Nob3J0J30pLnRvVXBwZXJDYXNlKCkgfSk7IH0gfSk7XHJcbiAgICB9IGVsc2UgaWYgKHJhbmdlID09PSAnNXknKSB7XHJcbiAgICAgIGNvbnN0IHNlZW5ZZWFyID0gbmV3IFNldDxudW1iZXI+KCk7IGRyYXdEYXRhLmZvckVhY2goKGMsIGlkeCkgPT4geyBjb25zdCBkID0gbmV3IERhdGUoYy50KTsgaWYgKCFzZWVuWWVhci5oYXMoZC5nZXRGdWxsWWVhcigpKSAmJiBkLmdldE1vbnRoKCkgPCAyKSB7IHNlZW5ZZWFyLmFkZChkLmdldEZ1bGxZZWFyKCkpOyB0aW1lVGlja3MucHVzaCh7IHg6IHhGb3JJZHgoaWR4KSwgbGFiZWw6IFN0cmluZyhkLmdldEZ1bGxZZWFyKCkpIH0pOyB9IH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBjb25zdCBtYXhWb2wgPSBNYXRoLm1heCguLi5kcmF3RGF0YS5tYXAoKGQ6IENhbmRsZSkgPT4gZC52KSwgMSk7XHJcbiAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5hYnMobWF4KTtcclxuICBjb25zdCBkZWNpbWFscyA9IG1hZ25pdHVkZSA+PSA1MDAgPyAwIDogbWFnbml0dWRlID49IDEwMCA/IDEgOiAyO1xyXG4gIGZ1bmN0aW9uIHNtYShzcmM6IG51bWJlcltdLCBwZXJpb2Q6IG51bWJlcikge1xyXG4gICAgaWYgKHNyYy5sZW5ndGggPCBwZXJpb2QpIHJldHVybiBbXTtcclxuICAgIGNvbnN0IG91dDogKG51bWJlciB8IG51bGwpW10gPSBuZXcgQXJyYXkocGVyaW9kIC0gMSkuZmlsbChudWxsKTsgLy8gUGFkIGJlZ2lubmluZyB3aXRoIG51bGxzXHJcbiAgICBsZXQgc3VtID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHN1bSArPSBzcmNbaV07XHJcbiAgICAgIGlmIChpID49IHBlcmlvZCkgc3VtIC09IHNyY1tpIC0gcGVyaW9kXTtcclxuICAgICAgaWYgKGkgPj0gcGVyaW9kIC0gMSkgb3V0LnB1c2goc3VtIC8gcGVyaW9kKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlbWEoc3JjOiBudW1iZXJbXSwgcGVyaW9kOiBudW1iZXIpOiAobnVtYmVyIHwgbnVsbClbXSB7XHJcbiAgICBpZiAoc3JjLmxlbmd0aCA8IHBlcmlvZCkgcmV0dXJuIFtdO1xyXG4gICAgY29uc3QgayA9IDIgLyAocGVyaW9kICsgMSk7XHJcbiAgICBjb25zdCBvdXQ6IChudW1iZXIgfCBudWxsKVtdID0gbmV3IEFycmF5KHBlcmlvZCAtIDEpLmZpbGwobnVsbCk7IC8vIFBhZCBiZWdpbm5pbmcgd2l0aCBudWxsc1xyXG4gICAgXHJcbiAgICAvLyBTdGFydCB3aXRoIFNNQSBmb3IgZmlyc3QgdmFsdWVcclxuICAgIGxldCBzdW0gPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZXJpb2Q7IGkrKykge1xyXG4gICAgICBzdW0gKz0gc3JjW2ldO1xyXG4gICAgfVxyXG4gICAgb3V0LnB1c2goc3VtIC8gcGVyaW9kKTtcclxuICAgIFxyXG4gICAgLy8gVGhlbiB1c2UgRU1BIGZvcm11bGFcclxuICAgIGZvciAobGV0IGkgPSBwZXJpb2Q7IGkgPCBzcmMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgb3V0LnB1c2goc3JjW2ldICogayArIChvdXRbb3V0Lmxlbmd0aCAtIDFdIGFzIG51bWJlcikgKiAoMSAtIGspKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIG91dDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUJvbGxpbmdlckJhbmRzKGNsb3NlczogbnVtYmVyW10sIHBlcmlvZDogbnVtYmVyID0gMjAsIHN0ZERldk11bHRpcGxpZXI6IG51bWJlciA9IDIpIHtcclxuICAgIGlmIChjbG9zZXMubGVuZ3RoIDwgcGVyaW9kKSByZXR1cm4geyB1cHBlcjogW10sIGxvd2VyOiBbXSwgbWlkZGxlOiBbXSB9O1xyXG4gICAgXHJcbiAgICBjb25zdCBtaWRkbGU6IChudW1iZXIgfCBudWxsKVtdID0gbmV3IEFycmF5KHBlcmlvZCAtIDEpLmZpbGwobnVsbCk7XHJcbiAgICBjb25zdCB1cHBlcjogKG51bWJlciB8IG51bGwpW10gPSBuZXcgQXJyYXkocGVyaW9kIC0gMSkuZmlsbChudWxsKTtcclxuICAgIGNvbnN0IGxvd2VyOiAobnVtYmVyIHwgbnVsbClbXSA9IG5ldyBBcnJheShwZXJpb2QgLSAxKS5maWxsKG51bGwpO1xyXG4gICAgXHJcbiAgICBmb3IgKGxldCBpID0gcGVyaW9kIC0gMTsgaSA8IGNsb3Nlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBzbGljZSA9IGNsb3Nlcy5zbGljZShpIC0gcGVyaW9kICsgMSwgaSArIDEpO1xyXG4gICAgICBjb25zdCBhdmcgPSBzbGljZS5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8gcGVyaW9kO1xyXG4gICAgICBjb25zdCB2YXJpYW5jZSA9IHNsaWNlLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIE1hdGgucG93KHZhbCAtIGF2ZywgMiksIDApIC8gcGVyaW9kO1xyXG4gICAgICBjb25zdCBzdGREZXYgPSBNYXRoLnNxcnQodmFyaWFuY2UpO1xyXG4gICAgICBcclxuICAgICAgbWlkZGxlLnB1c2goYXZnKTtcclxuICAgICAgdXBwZXIucHVzaChhdmcgKyBzdGREZXZNdWx0aXBsaWVyICogc3RkRGV2KTtcclxuICAgICAgbG93ZXIucHVzaChhdmcgLSBzdGREZXZNdWx0aXBsaWVyICogc3RkRGV2KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHsgdXBwZXIsIGxvd2VyLCBtaWRkbGUgfTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgc3R5bGU9e3sgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgaW5zZXQ6IDAsIGZvbnRTaXplOiAxMSB9fT5cclxuICAgICAgPHN2Z1xyXG4gICAgICAgIHZpZXdCb3g9e2AwIDAgJHt3fSAke2h9YH1cclxuICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiXHJcbiAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcclxuICAgICAgICAgIGhlaWdodDogXCIxMDAlXCIsXHJcbiAgICAgICAgICBjdXJzb3I6IFwiY3Jvc3NoYWlyXCIsXHJcbiAgICAgICAgICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcclxuICAgICAgICAgIGZvbnRGYW1pbHk6IFwic3lzdGVtLXVpLCB1aS1tb25vc3BhY2UsIE1lbmxvLCBtb25vc3BhY2VcIixcclxuICAgICAgICB9fVxyXG4gICAgICAgIG9uTW91c2VNb3ZlPXtvbk1vdmV9XHJcbiAgICAgICAgb25Nb3VzZUxlYXZlPXsoKSA9PiBzZXRIb3ZlcihudWxsKX1cclxuICAgICAgICBvbldoZWVsPXtvbldoZWVsfVxyXG4gICAgICAgIG9uUG9pbnRlckRvd249e29uUG9pbnRlckRvd259XHJcbiAgICAgICAgb25Qb2ludGVyTW92ZT17b25Qb2ludGVyTW92ZX1cclxuICAgICAgICBvblBvaW50ZXJVcD17b25Qb2ludGVyVXB9XHJcbiAgICAgID5cclxuICAgICAgICB7bmljZVRpY2tzKG1pbiwgbWF4LCA1KS5tYXAoKHQpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHkgPSA4ICsgKHByaWNlQXJlYSAtICgodCAtIG1pbikgLyBzcGFuKSAqIHByaWNlQXJlYSk7XHJcbiAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZyBrZXk9e3QudG9GaXhlZCg2KX0+XHJcbiAgICAgICAgICAgICAgPGxpbmVcclxuICAgICAgICAgICAgICAgIHgxPXtwYWRMZWZ0fVxyXG4gICAgICAgICAgICAgICAgeDI9e3BhZExlZnQgKyBwcmljZVd9XHJcbiAgICAgICAgICAgICAgICB5MT17eX1cclxuICAgICAgICAgICAgICAgIHkyPXt5fVxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlPXt0aGVtZSA9PT0gXCJsaWdodFwiID8gXCIjZDBkN2RlXCIgOiBcIiMzMDM2M2RcIn1cclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxfVxyXG4gICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgPHRleHRcclxuICAgICAgICAgICAgICAgIHg9e3BhZExlZnQgKyBwcmljZVcgKyBMYXlvdXRDb25maWcuQVhJU19ZX0xBQkVMX1hfT0ZGU0VUfVxyXG4gICAgICAgICAgICAgICAgeT17eSArIExheW91dENvbmZpZy5BWElTX1lfRk9OVF9TSVpFIC8gM31cclxuICAgICAgICAgICAgICAgIGZpbGw9e3RoZW1lID09PSBcImxpZ2h0XCIgPyBcIiMwMDAwMDBcIiA6IFwiI2ZmZmZmZlwifVxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU9e0xheW91dENvbmZpZy5BWElTX1lfRk9OVF9TSVpFfVxyXG4gICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIHt0LnRvRml4ZWQoZGVjaW1hbHMpfVxyXG4gICAgICAgICAgICAgIDwvdGV4dD5cclxuICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9KX1cclxuXHJcbiAgICAgICAgey8qIFZlcnRpY2FsIGdyaWQgbGluZXMgKHJlbmRlciBiZWZvcmUgY2hhcnQgZGF0YSBzbyB0aGV5IGFwcGVhciBiZWhpbmQpICovfVxyXG4gICAgICAgIHt0aW1lVGlja3MubWFwKCh0LCBpKSA9PiAoXHJcbiAgICAgICAgICA8bGluZVxyXG4gICAgICAgICAgICBrZXk9e1wieHRpY2stXCIgKyBpfVxyXG4gICAgICAgICAgICB4MT17dC54fVxyXG4gICAgICAgICAgICB4Mj17dC54fVxyXG4gICAgICAgICAgICB5MT17MH1cclxuICAgICAgICAgICAgeTI9e2hWaXN1YWx9XHJcbiAgICAgICAgICAgIHN0cm9rZT17dGhlbWUgPT09IFwibGlnaHRcIiA/IFwiI2QwZDdkZVwiIDogXCIjMzAzNjNkXCJ9XHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxfVxyXG4gICAgICAgICAgLz5cclxuICAgICAgICApKX1cclxuXHJcbiAgICAgICAgey8qIEJvbGxpbmdlciBCYW5kcyAqL31cclxuICAgICAgICB7c2hvd0JvbGxpbmdlckJhbmRzICYmIGJvbGxpbmdlckJhbmRzLnVwcGVyLmxlbmd0aCA+IDAgJiYgKFxyXG4gICAgICAgICAgPD5cclxuICAgICAgICAgICAgey8qIEZpbGwgYXJlYSAqL31cclxuICAgICAgICAgICAgPHBvbHlnb25cclxuICAgICAgICAgICAgICBwb2ludHM9eygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludHM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgICAgICAgICAvLyBVcHBlciBiYW5kXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvbGxpbmdlckJhbmRzLnVwcGVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVwcGVyVmFsID0gYm9sbGluZ2VyQmFuZHMudXBwZXJbaV07XHJcbiAgICAgICAgICAgICAgICAgIGlmICh1cHBlclZhbCA9PT0gbnVsbCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSB4Rm9ySWR4KGkpO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSAodXBwZXJWYWwgLSBtaW4pIC8gc3BhbjtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IHBhZFRvcCArIChwcmljZUFyZWEgLSB2YWwgKiBwcmljZUFyZWEpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoeCkgJiYgaXNGaW5pdGUoeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChgJHt4fSwke3l9YCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIExvd2VyIGJhbmQgKHJldmVyc2VkKVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGJvbGxpbmdlckJhbmRzLmxvd2VyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxvd2VyVmFsID0gYm9sbGluZ2VyQmFuZHMubG93ZXJbaV07XHJcbiAgICAgICAgICAgICAgICAgIGlmIChsb3dlclZhbCA9PT0gbnVsbCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSB4Rm9ySWR4KGkpO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSAobG93ZXJWYWwgLSBtaW4pIC8gc3BhbjtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IHBhZFRvcCArIChwcmljZUFyZWEgLSB2YWwgKiBwcmljZUFyZWEpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoeCkgJiYgaXNGaW5pdGUoeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChgJHt4fSwke3l9YCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludHMuam9pbihcIiBcIik7XHJcbiAgICAgICAgICAgICAgfSkoKX1cclxuICAgICAgICAgICAgICBmaWxsPVwicmdiYSgxMzUsIDIwNiwgMjM1LCAwLjE1KVwiXHJcbiAgICAgICAgICAgICAgc3Ryb2tlPVwibm9uZVwiXHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB7LyogVXBwZXIgYmFuZCBvdXRsaW5lICovfVxyXG4gICAgICAgICAgICA8cG9seWxpbmVcclxuICAgICAgICAgICAgICBwb2ludHM9e2JvbGxpbmdlckJhbmRzLnVwcGVyXHJcbiAgICAgICAgICAgICAgICAubWFwKCh2LCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh2ID09PSBudWxsKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IHhGb3JJZHgoaSk7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9ICh2IC0gbWluKSAvIHNwYW47XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBwYWRUb3AgKyAocHJpY2VBcmVhIC0gdmFsICogcHJpY2VBcmVhKTtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke3h9LCR7eX1gO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIocCA9PiBwICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oXCIgXCIpfVxyXG4gICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcclxuICAgICAgICAgICAgICBzdHJva2U9XCJyZ2JhKDEzNSwgMjA2LCAyMzUsIDAuOClcIlxyXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxfVxyXG4gICAgICAgICAgICAgIHZlY3RvckVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiXHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB7LyogTG93ZXIgYmFuZCBvdXRsaW5lICovfVxyXG4gICAgICAgICAgICA8cG9seWxpbmVcclxuICAgICAgICAgICAgICBwb2ludHM9e2JvbGxpbmdlckJhbmRzLmxvd2VyXHJcbiAgICAgICAgICAgICAgICAubWFwKCh2LCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh2ID09PSBudWxsKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IHhGb3JJZHgoaSk7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9ICh2IC0gbWluKSAvIHNwYW47XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBwYWRUb3AgKyAocHJpY2VBcmVhIC0gdmFsICogcHJpY2VBcmVhKTtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke3h9LCR7eX1gO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIocCA9PiBwICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oXCIgXCIpfVxyXG4gICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcclxuICAgICAgICAgICAgICBzdHJva2U9XCJyZ2JhKDEzNSwgMjA2LCAyMzUsIDAuOClcIlxyXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxfVxyXG4gICAgICAgICAgICAgIHZlY3RvckVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiXHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICA8Lz5cclxuICAgICAgICApfVxyXG4gICAgICAgIHttb2RlID09PSBcImxpbmVcIiAmJiAoXHJcbiAgICAgICAgICA8cG9seWxpbmVcclxuICAgICAgICAgICAgcG9pbnRzPXtsaW5lUHRzfVxyXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXHJcbiAgICAgICAgICAgIHN0cm9rZT17dXAgPyBcInZhcigtLWNvbG9yLXN1Y2Nlc3MpXCIgOiBcInZhcigtLWNvbG9yLWRhbmdlcilcIn1cclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezJ9XHJcbiAgICAgICAgICAgIHZlY3RvckVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICl9XHJcbiAgICAgICAge21vZGUgPT09IFwiY2FuZGxlc1wiICYmXHJcbiAgICAgICAgICBkcmF3RGF0YS5tYXAoKGQ6IENhbmRsZSwgaWR4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHhGb3JJZHgoaWR4KTtcclxuICAgICAgICAgICAgY29uc3QgeCA9IGNlbnRlclggLSBjYW5kbGVXaWR0aCAvIDI7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbE9wZW4gPSBsb2dTY2FsZVxyXG4gICAgICAgICAgICAgID8gKE1hdGgubG9nMTAoZC5vKSAtIE1hdGgubG9nMTAobWluKSkgLyAoTWF0aC5sb2cxMChtYXgpIC0gTWF0aC5sb2cxMChtaW4gfHwgMSkpXHJcbiAgICAgICAgICAgICAgOiAoZC5vIC0gbWluKSAvIHNwYW47XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbENsb3NlID0gbG9nU2NhbGVcclxuICAgICAgICAgICAgICA/IChNYXRoLmxvZzEwKGQuYykgLSBNYXRoLmxvZzEwKG1pbikpIC8gKE1hdGgubG9nMTAobWF4KSAtIE1hdGgubG9nMTAobWluIHx8IDEpKVxyXG4gICAgICAgICAgICAgIDogKGQuYyAtIG1pbikgLyBzcGFuO1xyXG4gICAgICAgICAgICBjb25zdCB2YWxIaWdoID0gbG9nU2NhbGVcclxuICAgICAgICAgICAgICA/IChNYXRoLmxvZzEwKGQuaCkgLSBNYXRoLmxvZzEwKG1pbikpIC8gKE1hdGgubG9nMTAobWF4KSAtIE1hdGgubG9nMTAobWluIHx8IDEpKVxyXG4gICAgICAgICAgICAgIDogKGQuaCAtIG1pbikgLyBzcGFuO1xyXG4gICAgICAgICAgICBjb25zdCB2YWxMb3cgPSBsb2dTY2FsZVxyXG4gICAgICAgICAgICAgID8gKE1hdGgubG9nMTAoZC5sKSAtIE1hdGgubG9nMTAobWluKSkgLyAoTWF0aC5sb2cxMChtYXgpIC0gTWF0aC5sb2cxMChtaW4gfHwgMSkpXHJcbiAgICAgICAgICAgICAgOiAoZC5sIC0gbWluKSAvIHNwYW47XHJcbiAgICAgICAgICAgIGNvbnN0IG9wZW5ZID0gOCArIChwcmljZUFyZWEgLSB2YWxPcGVuICogcHJpY2VBcmVhKTtcclxuICAgICAgICAgICAgY29uc3QgY2xvc2VZID0gOCArIChwcmljZUFyZWEgLSB2YWxDbG9zZSAqIHByaWNlQXJlYSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hZID0gOCArIChwcmljZUFyZWEgLSB2YWxIaWdoICogcHJpY2VBcmVhKTtcclxuICAgICAgICAgICAgY29uc3QgbG93WSA9IDggKyAocHJpY2VBcmVhIC0gdmFsTG93ICogcHJpY2VBcmVhKTtcclxuICAgICAgICAgICAgY29uc3QgcmlzaW5nID0gZC5jID49IGQubztcclxuICAgICAgICAgICAgY29uc3QgcGN0ID0gTWF0aC5taW4oMC4wNSwgTWF0aC5tYXgoLTAuMDUsIChkLmMgLSBkLm8pIC8gZC5vKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGludGVuc2l0eSA9IE1hdGguYWJzKHBjdCkgLyAwLjA1O1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlQ29sb3IgPSByaXNpbmcgPyBcInZhcigtLWNvbG9yLXN1Y2Nlc3MpXCIgOiBcInZhcigtLWNvbG9yLWRhbmdlcilcIjtcclxuICAgICAgICAgICAgY29uc3QgZmlsbCA9IHJpc2luZ1xyXG4gICAgICAgICAgICAgID8gYHJnYmEoMzUsMTM0LDU0LCR7MC4zNSArIDAuNTUgKiBpbnRlbnNpdHl9KWBcclxuICAgICAgICAgICAgICA6IGByZ2JhKDI0OCw4MSw3MywkezAuMzUgKyAwLjU1ICogaW50ZW5zaXR5fSlgO1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgIDxnIGtleT17ZC50fT5cclxuICAgICAgICAgICAgICAgIDxsaW5lXHJcbiAgICAgICAgICAgICAgICAgIHgxPXt4ICsgY2FuZGxlV2lkdGggLyAyfVxyXG4gICAgICAgICAgICAgICAgICB4Mj17eCArIGNhbmRsZVdpZHRoIC8gMn1cclxuICAgICAgICAgICAgICAgICAgeTE9e2hpZ2hZfVxyXG4gICAgICAgICAgICAgICAgICB5Mj17bG93WX1cclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlPXtiYXNlQ29sb3J9XHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDxyZWN0XHJcbiAgICAgICAgICAgICAgICAgIHg9e3h9XHJcbiAgICAgICAgICAgICAgICAgIHk9e01hdGgubWluKG9wZW5ZLCBjbG9zZVkpfVxyXG4gICAgICAgICAgICAgICAgICB3aWR0aD17Y2FuZGxlV2lkdGh9XHJcbiAgICAgICAgICAgICAgICAgIGhlaWdodD17TWF0aC5tYXgoMiwgTWF0aC5hYnMoY2xvc2VZIC0gb3BlblkpKX1cclxuICAgICAgICAgICAgICAgICAgZmlsbD17ZmlsbH1cclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlPXtiYXNlQ29sb3J9XHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXswLjV9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0pfVxyXG5cclxuICAgICAgICB7LyogRU1BIDIwICovfVxyXG4gICAgICAgIHtzaG93RU1BMjAgJiYgZW1hMjAubGVuZ3RoICYmIChcclxuICAgICAgICAgIDxwb2x5bGluZVxyXG4gICAgICAgICAgICBwb2ludHM9e2VtYTIwXHJcbiAgICAgICAgICAgICAgLm1hcCgodiwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IG51bGwpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHhGb3JJZHgoaSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBsb2dTY2FsZVxyXG4gICAgICAgICAgICAgICAgICA/IChNYXRoLmxvZzEwKHYpIC0gTWF0aC5sb2cxMChtaW4pKSAvIChNYXRoLmxvZzEwKG1heCkgLSBNYXRoLmxvZzEwKG1pbiB8fCAxKSlcclxuICAgICAgICAgICAgICAgICAgOiAodiAtIG1pbikgLyBzcGFuO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IDggKyAocHJpY2VBcmVhIC0gdmFsICogcHJpY2VBcmVhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHt4fSwke3l9YDtcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgIC5maWx0ZXIocCA9PiBwICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgIC5qb2luKFwiIFwiKX1cclxuICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxyXG4gICAgICAgICAgICBzdHJva2U9XCIjZmY5NTAwXCJcclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezEuNH1cclxuICAgICAgICAgICAgdmVjdG9yRWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgKX1cclxuXHJcbiAgICAgICAge2RyYXdEYXRhLm1hcCgoZCwgaWR4KSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBjZW50ZXJYID0geEZvcklkeChpZHgpO1xyXG4gICAgICAgICAgY29uc3QgeCA9IGNlbnRlclggLSBjYW5kbGVXaWR0aCAvIDI7XHJcbiAgICAgICAgICBjb25zdCB2b2xSYXRpbyA9IGQudiAvIG1heFZvbDtcclxuICAgICAgICAgIGxldCBiYXJIID0gdm9sUmF0aW8gKiAodm9sSCAtIDE2KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gTWluaW11bSBiYXIgaGVpZ2h0IGZvciB2aXNpYmlsaXR5IChlc3BlY2lhbGx5IGZvciBsb3cgYWZ0ZXItaG91cnMgdm9sdW1lKVxyXG4gICAgICAgICAgY29uc3QgbWluQmFySGVpZ2h0ID0gMjtcclxuICAgICAgICAgIGlmIChiYXJIID4gMCAmJiBiYXJIIDwgbWluQmFySGVpZ2h0KSBiYXJIID0gbWluQmFySGVpZ2h0O1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zdCB5ID0gcHJpY2VIICsgKHZvbEggLSBiYXJIKTtcclxuICAgICAgICAgIGNvbnN0IHJpc2luZyA9IGQuYyA+PSBkLm87XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgZXh0ZW5kZWQgaG91cnMgKGJlZm9yZSA5OjMwIG9yIGFmdGVyIDE2OjAwIEVUKVxyXG4gICAgICAgICAgY29uc3QgY2FuZGxlRGF0ZSA9IG5ldyBEYXRlKGQudCk7XHJcbiAgICAgICAgICBjb25zdCBob3VyID0gY2FuZGxlRGF0ZS5nZXRIb3VycygpO1xyXG4gICAgICAgICAgY29uc3QgbWludXRlID0gY2FuZGxlRGF0ZS5nZXRNaW51dGVzKCk7XHJcbiAgICAgICAgICBjb25zdCB0aW1lSW5NaW51dGVzID0gaG91ciAqIDYwICsgbWludXRlO1xyXG4gICAgICAgICAgY29uc3QgbWFya2V0T3BlbiA9IDkgKiA2MCArIDMwOyAvLyA5OjMwIEFNXHJcbiAgICAgICAgICBjb25zdCBtYXJrZXRDbG9zZSA9IDE2ICogNjA7IC8vIDQ6MDAgUE1cclxuICAgICAgICAgIGNvbnN0IGlzRXh0ZW5kZWRIb3VycyA9IHRpbWVJbk1pbnV0ZXMgPCBtYXJrZXRPcGVuIHx8IHRpbWVJbk1pbnV0ZXMgPj0gbWFya2V0Q2xvc2U7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxyZWN0XHJcbiAgICAgICAgICAgICAga2V5PXtkLnQgKyBcIjp2b2xcIn1cclxuICAgICAgICAgICAgICB4PXt4fVxyXG4gICAgICAgICAgICAgIHk9e3l9XHJcbiAgICAgICAgICAgICAgd2lkdGg9e2NhbmRsZVdpZHRofVxyXG4gICAgICAgICAgICAgIGhlaWdodD17YmFySH1cclxuICAgICAgICAgICAgICBmaWxsPXtyaXNpbmcgPyBcInZhcigtLWNvbG9yLXN1Y2Nlc3MpXCIgOiBcInZhcigtLWNvbG9yLWRhbmdlcilcIn1cclxuICAgICAgICAgICAgICBvcGFjaXR5PXtpc0V4dGVuZGVkSG91cnMgPyAwLjIgOiAwLjM1fVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9KX1cclxuICAgICAgICB7c2hvd1ZvbE1BICYmIHZvbE1BLmxlbmd0aCAmJiAoXHJcbiAgICAgICAgICA8cG9seWxpbmVcclxuICAgICAgICAgICAgcG9pbnRzPXt2b2xNQVxyXG4gICAgICAgICAgICAgIC5tYXAoKHYsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh2ID09PSBudWxsKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB4Rm9ySWR4KGkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmF0aW8gPSB2IC8gbWF4Vm9sO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFySCA9IHJhdGlvICogKHZvbEggLSAxNik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gcHJpY2VIICsgKHZvbEggLSBiYXJIKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHt4fSwke3l9YDtcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgIC5maWx0ZXIocCA9PiBwICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgIC5qb2luKFwiIFwiKX1cclxuICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxyXG4gICAgICAgICAgICBzdHJva2U9XCIjNThhNmZmXCJcclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XHJcbiAgICAgICAgICAgIHZlY3RvckVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICl9XHJcbiAgICAgICAge2hvdmVyUG9pbnQgJiZcclxuICAgICAgICAgICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSB4Rm9ySWR4KGhvdmVyISk7XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSA4ICsgKHByaWNlQXJlYSAtICgoaG92ZXJQb2ludC5jIC0gbWluKSAvIHNwYW4pICogcHJpY2VBcmVhKTtcclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICA8Zz5cclxuICAgICAgICAgICAgICAgIDxsaW5lXHJcbiAgICAgICAgICAgICAgICAgIHgxPXt4fVxyXG4gICAgICAgICAgICAgICAgICB4Mj17eH1cclxuICAgICAgICAgICAgICAgICAgeTE9ezB9XHJcbiAgICAgICAgICAgICAgICAgIHkyPXtwcmljZUh9XHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZT17dGhlbWUgPT09IFwibGlnaHRcIiA/IFwiIzY1NmQ3NlwiIDogXCIjN2Q4NTkwXCJ9XHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIjQgM1wiXHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDxsaW5lXHJcbiAgICAgICAgICAgICAgICAgIHgxPXswfVxyXG4gICAgICAgICAgICAgICAgICB4Mj17d31cclxuICAgICAgICAgICAgICAgICAgeTE9e3l9XHJcbiAgICAgICAgICAgICAgICAgIHkyPXt5fVxyXG4gICAgICAgICAgICAgICAgICBzdHJva2U9e3RoZW1lID09PSBcImxpZ2h0XCIgPyBcIiM2NTZkNzZcIiA6IFwiIzdkODU5MFwifVxyXG4gICAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk9XCI0IDNcIlxyXG4gICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD17MX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8Y2lyY2xlXHJcbiAgICAgICAgICAgICAgICAgIGN4PXt4fVxyXG4gICAgICAgICAgICAgICAgICBjeT17eX1cclxuICAgICAgICAgICAgICAgICAgcj17NX1cclxuICAgICAgICAgICAgICAgICAgZmlsbD1cInZhcigtLWNvbG9yLWJnKVwiXHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZT17dXAgPyBcInZhcigtLWNvbG9yLXN1Y2Nlc3MpXCIgOiBcInZhcigtLWNvbG9yLWRhbmdlcilcIn1cclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezJ9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0pKCl9XHJcbiAgICAgICAge2RyYXdEYXRhLmxlbmd0aCA+IDAgJiZcclxuICAgICAgICAgICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBkcmF3RGF0YVtkcmF3RGF0YS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgY29uc3QgeSA9IDggKyAocHJpY2VBcmVhIC0gKChsYXN0LmMgLSBtaW4pIC8gc3BhbikgKiBwcmljZUFyZWEpO1xyXG4gICAgICAgICAgICBjb25zdCBpc1VwID0gbGFzdC5jID49IGNsb3Nlc1swXTtcclxuICAgICAgICAgICAgLy8gQnJpZ2h0ZXIsIGhpZ2hlciBjb250cmFzdCBjb2xvcnMgZm9yIGxhc3QgcHJpY2UgbGFiZWxcclxuICAgICAgICAgICAgY29uc3QgYnJpZ2h0R3JlZW4gPSBcIiMwMGZmNDFcIjsgLy8gQnJpZ2h0IG5lb24gZ3JlZW5cclxuICAgICAgICAgICAgY29uc3QgYnJpZ2h0UmVkID0gXCIjZmYzMzY2XCI7IC8vIEJyaWdodCByZWRcclxuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBpc1VwID8gYnJpZ2h0R3JlZW4gOiBicmlnaHRSZWQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgIDxnPlxyXG4gICAgICAgICAgICAgICAgPGxpbmVcclxuICAgICAgICAgICAgICAgICAgeDE9e3BhZExlZnR9XHJcbiAgICAgICAgICAgICAgICAgIHgyPXtwYWRMZWZ0ICsgcHJpY2VXfVxyXG4gICAgICAgICAgICAgICAgICB5MT17eX1cclxuICAgICAgICAgICAgICAgICAgeTI9e3l9XHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZT17Y29sb3J9XHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIjIgNFwiXHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDxyZWN0XHJcbiAgICAgICAgICAgICAgICAgIHg9e3BhZExlZnQgKyBwcmljZVcgKyA0fVxyXG4gICAgICAgICAgICAgICAgICB5PXt5IC0gTGF5b3V0Q29uZmlnLkxBU1RfUFJJQ0VfTEFCRUxfSEVJR0hUIC8gMn1cclxuICAgICAgICAgICAgICAgICAgd2lkdGg9e0xheW91dENvbmZpZy5MQVNUX1BSSUNFX0xBQkVMX1dJRFRIfVxyXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ9e0xheW91dENvbmZpZy5MQVNUX1BSSUNFX0xBQkVMX0hFSUdIVH1cclxuICAgICAgICAgICAgICAgICAgZmlsbD17aXNVcCBcclxuICAgICAgICAgICAgICAgICAgICA/ICh0aGVtZSA9PT0gXCJsaWdodFwiID8gXCIjZTZmZmYwXCIgOiBcIiMwMDIyMTFcIikgXHJcbiAgICAgICAgICAgICAgICAgICAgOiAodGhlbWUgPT09IFwibGlnaHRcIiA/IFwiI2ZmZTZlZVwiIDogXCIjMmQwMDExXCIpfVxyXG4gICAgICAgICAgICAgICAgICBzdHJva2U9e2NvbG9yfVxyXG4gICAgICAgICAgICAgICAgICByeD17M31cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8dGV4dFxyXG4gICAgICAgICAgICAgICAgICB4PXtwYWRMZWZ0ICsgcHJpY2VXICsgNCArIExheW91dENvbmZpZy5MQVNUX1BSSUNFX0xBQkVMX1dJRFRIIC8gMn1cclxuICAgICAgICAgICAgICAgICAgeT17eSArIExheW91dENvbmZpZy5MQVNUX1BSSUNFX0xBQkVMX0ZPTlRfU0laRSAvIDN9XHJcbiAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxyXG4gICAgICAgICAgICAgICAgICBmaWxsPXtjb2xvcn1cclxuICAgICAgICAgICAgICAgICAgZm9udFNpemU9e0xheW91dENvbmZpZy5MQVNUX1BSSUNFX0xBQkVMX0ZPTlRfU0laRX1cclxuICAgICAgICAgICAgICAgICAgZm9udFdlaWdodD17NjAwfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICB7bGFzdC5jLnRvRml4ZWQoZGVjaW1hbHMpfVxyXG4gICAgICAgICAgICAgICAgPC90ZXh0PlxyXG4gICAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0pKCl9XHJcbiAgICAgICAgXHJcbiAgICAgICAgey8qIEluZGljYXRvciBsYWJlbHMgd2l0aCBzbWFydCBvdmVybGFwIGF2b2lkYW5jZSAqL31cclxuICAgICAgICB7KCgpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGxhYmVsczogQXJyYXk8eyB5OiBudW1iZXI7IHZhbHVlOiBudW1iZXI7IGNvbG9yOiBzdHJpbmc7IGJnQ29sb3I6IHN0cmluZzsgc3Ryb2tlOiBzdHJpbmcgfT4gPSBbXTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gTWFpbiBwcmljZSBwb3NpdGlvblxyXG4gICAgICAgICAgY29uc3QgbGFzdFByaWNlID0gZHJhd0RhdGFbZHJhd0RhdGEubGVuZ3RoIC0gMV0/LmMgfHwgMDtcclxuICAgICAgICAgIGNvbnN0IHByaWNlWSA9IDggKyAocHJpY2VBcmVhIC0gKChsYXN0UHJpY2UgLSBtaW4pIC8gc3BhbikgKiBwcmljZUFyZWEpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBFTUEyMFxyXG4gICAgICAgICAgaWYgKHNob3dFTUEyMCAmJiBlbWEyMC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RFbWEgPSBlbWEyMFtlbWEyMC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgaWYgKGxhc3RFbWEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICBsYWJlbHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB5OiA4ICsgKHByaWNlQXJlYSAtICgobGFzdEVtYSAtIG1pbikgLyBzcGFuKSAqIHByaWNlQXJlYSksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGFzdEVtYSxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIiNmZjk1MDBcIixcclxuICAgICAgICAgICAgICAgIGJnQ29sb3I6IHRoZW1lID09PSBcImxpZ2h0XCIgPyBcIiNmZmY1ZTZcIiA6IFwiIzJkMjQwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiNmZjk1MDBcIixcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBCb2xsaW5nZXIgQmFuZHMgVXBwZXJcclxuICAgICAgICAgIGlmIChzaG93Qm9sbGluZ2VyQmFuZHMgJiYgYm9sbGluZ2VyQmFuZHMudXBwZXIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0VXBwZXIgPSBib2xsaW5nZXJCYW5kcy51cHBlcltib2xsaW5nZXJCYW5kcy51cHBlci5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgaWYgKGxhc3RVcHBlciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIGxhYmVscy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHk6IDggKyAocHJpY2VBcmVhIC0gKChsYXN0VXBwZXIgLSBtaW4pIC8gc3BhbikgKiBwcmljZUFyZWEpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxhc3RVcHBlcixcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBcInJnYmEoMTM1LCAyMDYsIDIzNSwgMSlcIixcclxuICAgICAgICAgICAgICAgIGJnQ29sb3I6IHRoZW1lID09PSBcImxpZ2h0XCIgPyBcIiNlNmY3ZmZcIiA6IFwiIzAwMWEyZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcInJnYmEoMTM1LCAyMDYsIDIzNSwgMC44KVwiLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEJvbGxpbmdlciBCYW5kcyBMb3dlclxyXG4gICAgICAgICAgaWYgKHNob3dCb2xsaW5nZXJCYW5kcyAmJiBib2xsaW5nZXJCYW5kcy5sb3dlci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RMb3dlciA9IGJvbGxpbmdlckJhbmRzLmxvd2VyW2JvbGxpbmdlckJhbmRzLmxvd2VyLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBpZiAobGFzdExvd2VyICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgbGFiZWxzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgeTogOCArIChwcmljZUFyZWEgLSAoKGxhc3RMb3dlciAtIG1pbikgLyBzcGFuKSAqIHByaWNlQXJlYSksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGFzdExvd2VyLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IFwicmdiYSgxMzUsIDIwNiwgMjM1LCAxKVwiLFxyXG4gICAgICAgICAgICAgICAgYmdDb2xvcjogdGhlbWUgPT09IFwibGlnaHRcIiA/IFwiI2U2ZjdmZlwiIDogXCIjMDAxYTJkXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwicmdiYSgxMzUsIDIwNiwgMjM1LCAwLjgpXCIsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQWRqdXN0IHBvc2l0aW9ucyB0byBhdm9pZCBvdmVybGFwc1xyXG4gICAgICAgICAgY29uc3QgbWluR2FwID0gTGF5b3V0Q29uZmlnLklORElDQVRPUl9MQUJFTF9IRUlHSFQgKyAyO1xyXG4gICAgICAgICAgY29uc3QgYWRqdXN0ZWRMYWJlbHMgPSBsYWJlbHMubWFwKChsYWJlbCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgYWRqdXN0ZWRZID0gbGFiZWwueTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENoZWNrIG92ZXJsYXAgd2l0aCBtYWluIHByaWNlIGxhYmVsXHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhhZGp1c3RlZFkgLSBwcmljZVkpIDwgbWluR2FwKSB7XHJcbiAgICAgICAgICAgICAgLy8gTW92ZSBhYm92ZSBvciBiZWxvdyBiYXNlZCBvbiB3aGljaCBzaWRlIGhhcyBtb3JlIHNwYWNlXHJcbiAgICAgICAgICAgICAgaWYgKGFkanVzdGVkWSA8IHByaWNlWSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTGFiZWwgaXMgYWJvdmUgcHJpY2UsIG1vdmUgaXQgZnVydGhlciB1cFxyXG4gICAgICAgICAgICAgICAgYWRqdXN0ZWRZID0gcHJpY2VZIC0gbWluR2FwO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMYWJlbCBpcyBiZWxvdyBwcmljZSwgbW92ZSBpdCBmdXJ0aGVyIGRvd25cclxuICAgICAgICAgICAgICAgIGFkanVzdGVkWSA9IHByaWNlWSArIG1pbkdhcDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmxhYmVsLCB5OiBhZGp1c3RlZFkgfTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBTb3J0IGJ5IFkgcG9zaXRpb24gYW5kIGFkanVzdCBmb3Igb3ZlcmxhcHMgYmV0d2VlbiBpbmRpY2F0b3JzXHJcbiAgICAgICAgICBhZGp1c3RlZExhYmVscy5zb3J0KChhLCBiKSA9PiBhLnkgLSBiLnkpO1xyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhZGp1c3RlZExhYmVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYWRqdXN0ZWRMYWJlbHNbaV0ueSAtIGFkanVzdGVkTGFiZWxzW2kgLSAxXS55IDwgbWluR2FwKSB7XHJcbiAgICAgICAgICAgICAgYWRqdXN0ZWRMYWJlbHNbaV0ueSA9IGFkanVzdGVkTGFiZWxzW2kgLSAxXS55ICsgbWluR2FwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHJldHVybiBhZGp1c3RlZExhYmVscy5tYXAoKGxhYmVsLCBpZHgpID0+IChcclxuICAgICAgICAgICAgPGcga2V5PXtgaW5kaWNhdG9yLWxhYmVsLSR7aWR4fWB9PlxyXG4gICAgICAgICAgICAgIDxyZWN0XHJcbiAgICAgICAgICAgICAgICB4PXtwYWRMZWZ0ICsgcHJpY2VXICsgNH1cclxuICAgICAgICAgICAgICAgIHk9e2xhYmVsLnkgLSBMYXlvdXRDb25maWcuSU5ESUNBVE9SX0xBQkVMX0hFSUdIVCAvIDJ9XHJcbiAgICAgICAgICAgICAgICB3aWR0aD17TGF5b3V0Q29uZmlnLklORElDQVRPUl9MQUJFTF9XSURUSH1cclxuICAgICAgICAgICAgICAgIGhlaWdodD17TGF5b3V0Q29uZmlnLklORElDQVRPUl9MQUJFTF9IRUlHSFR9XHJcbiAgICAgICAgICAgICAgICBmaWxsPXtsYWJlbC5iZ0NvbG9yfVxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlPXtsYWJlbC5zdHJva2V9XHJcbiAgICAgICAgICAgICAgICByeD17Mn1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgIDx0ZXh0XHJcbiAgICAgICAgICAgICAgICB4PXtwYWRMZWZ0ICsgcHJpY2VXICsgNCArIExheW91dENvbmZpZy5JTkRJQ0FUT1JfTEFCRUxfV0lEVEggLyAyfVxyXG4gICAgICAgICAgICAgICAgeT17bGFiZWwueSArIExheW91dENvbmZpZy5JTkRJQ0FUT1JfTEFCRUxfRk9OVF9TSVpFIC8gM31cclxuICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxyXG4gICAgICAgICAgICAgICAgZmlsbD17bGFiZWwuY29sb3J9XHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZT17TGF5b3V0Q29uZmlnLklORElDQVRPUl9MQUJFTF9GT05UX1NJWkV9XHJcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0PXs2MDB9XHJcbiAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAge2xhYmVsLnZhbHVlLnRvRml4ZWQoZGVjaW1hbHMpfVxyXG4gICAgICAgICAgICAgIDwvdGV4dD5cclxuICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgKSk7XHJcbiAgICAgICAgfSkoKX1cclxuICAgICAgICBcclxuICAgICAgICB7dGltZVRpY2tzLm1hcCgodCwgaSkgPT4gKFxyXG4gICAgICAgICAgPHRleHRcclxuICAgICAgICAgICAga2V5PXtcInhsYWJlbC1cIiArIGl9XHJcbiAgICAgICAgICAgIHg9e3QueH1cclxuICAgICAgICAgICAgeT17aCAtIDZ9XHJcbiAgICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxyXG4gICAgICAgICAgICBmb250U2l6ZT17TGF5b3V0Q29uZmlnLkFYSVNfWF9GT05UX1NJWkV9XHJcbiAgICAgICAgICAgIGZpbGw9e3RoZW1lID09PSBcImxpZ2h0XCIgPyBcIiMwMDAwMDBcIiA6IFwiI2ZmZmZmZlwifVxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICB7dC5sYWJlbH1cclxuICAgICAgICAgIDwvdGV4dD5cclxuICAgICAgICApKX1cclxuICAgICAgPC9zdmc+XHJcbiAgICAgIHtob3ZlclBvaW50ICYmICgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaG92ZXJYID0geEZvcklkeChob3ZlciEpO1xyXG4gICAgICAgIGNvbnN0IGhvdmVyWFBlcmNlbnQgPSAoKGhvdmVyWCAtIHBhZExlZnQpIC8gcHJpY2VXKSAqIDEwMDtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTaW1wbGUgYm91bmRhcnkgY2hlY2s6IGlmIG5lYXIgZWRnZXMsIGFkanVzdCBwb3NpdGlvbmluZ1xyXG4gICAgICAgIC8vIE5lYXIgcmlnaHQgZWRnZSAoPiA4NSUpIC0gYW5jaG9yIHRvIHJpZ2h0IG9mIGhvdmVyIHBvaW50XHJcbiAgICAgICAgLy8gTmVhciBsZWZ0IGVkZ2UgKDwgMTUlKSAtIGFuY2hvciB0byBsZWZ0IG9mIGhvdmVyIHBvaW50XHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGNlbnRlciBvbiBob3ZlciBwb2ludFxyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBsZWZ0UG9zOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IHJpZ2h0UG9zOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IHRyYW5zZm9ybTogc3RyaW5nO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChob3ZlclhQZXJjZW50ID4gODUpIHtcclxuICAgICAgICAgIC8vIE5lYXIgcmlnaHQgZWRnZSAtIHRvb2x0aXAgb3BlbnMgdG8gdGhlIGxlZnRcclxuICAgICAgICAgIGxlZnRQb3MgPSBgJHtob3ZlclhQZXJjZW50fSVgO1xyXG4gICAgICAgICAgdHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVYKC0xMDAlKVwiO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG92ZXJYUGVyY2VudCA8IDE1KSB7XHJcbiAgICAgICAgICAvLyBOZWFyIGxlZnQgZWRnZSAtIHRvb2x0aXAgb3BlbnMgdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICBsZWZ0UG9zID0gYCR7aG92ZXJYUGVyY2VudH0lYDtcclxuICAgICAgICAgIHRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWCgwKVwiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBDZW50ZXIgb24gaG92ZXIgcG9pbnQgKGRlZmF1bHQpXHJcbiAgICAgICAgICBsZWZ0UG9zID0gYCR7aG92ZXJYUGVyY2VudH0lYDtcclxuICAgICAgICAgIHRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWCgtNTAlKVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgICAgbGVmdDogbGVmdFBvcyxcclxuICAgICAgICAgICAgICByaWdodDogcmlnaHRQb3MsXHJcbiAgICAgICAgICAgICAgdG9wOiA4LFxyXG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6IHRoZW1lID09PSBcImxpZ2h0XCIgPyBcInJnYmEoMjU1LDI1NSwyNTUsMC45NSlcIiA6IFwicmdiYSgwLDAsMCwwLjc4KVwiLFxyXG4gICAgICAgICAgICAgIHBhZGRpbmc6IFwiNnB4IDhweFwiLFxyXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogNCxcclxuICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICBib3JkZXI6IHRoZW1lID09PSBcImxpZ2h0XCIgPyBcIjFweCBzb2xpZCAjZDBkN2RlXCIgOiBcIjFweCBzb2xpZCAjMzAzNjNkXCIsXHJcbiAgICAgICAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcclxuICAgICAgICAgICAgICBiYWNrZHJvcEZpbHRlcjogXCJibHVyKDJweClcIixcclxuICAgICAgICAgICAgICBjb2xvcjogdGhlbWUgPT09IFwibGlnaHRcIiA/IFwiIzI0MjkyZlwiIDogXCIjZTZlZGYzXCIsXHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtLFxyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGZvbnRTaXplOiAxMSwgb3BhY2l0eTogMC43IH19PlxyXG4gICAgICAgICAgICAgIHtuZXcgRGF0ZShob3ZlclBvaW50LnQpLnRvTG9jYWxlU3RyaW5nKCl9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGZvbnRXZWlnaHQ6IDYwMCB9fT57aG92ZXJQb2ludC5jLnRvRml4ZWQoMil9PC9kaXY+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgICB9KSgpfVxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJMYXlvdXRDb25maWciLCJ1c2VBdXRoIiwiQWR2YW5jZWRQcmljZUNoYXJ0IiwiZGF0YSIsIm1vZGUiLCJyYW5nZSIsImxvZ1NjYWxlIiwic2hvd1ZvbE1BIiwic2hvd0JvbGxpbmdlckJhbmRzIiwic2hvd0VNQTIwIiwic3ltYm9sIiwidGhlbWUiLCJob3ZlciIsInNldEhvdmVyIiwidXNlU3RhdGUiLCJzb3VyY2VEYXRhIiwiVEFSR0VUX1BFUl9SQU5HRSIsInRhcmdldCIsImJ1Y2tldFNpemUiLCJsZW5ndGgiLCJNYXRoIiwiY2VpbCIsInJhd0VtYTIwIiwiZW1hIiwibWFwIiwiZCIsImMiLCJyYXdWb2xNQSIsInNtYSIsInYiLCJyYXdCb2xsaW5nZXJCYW5kcyIsImNhbGN1bGF0ZUJvbGxpbmdlckJhbmRzIiwidXBwZXIiLCJsb3dlciIsIm1pZGRsZSIsImJ1Y2tldEFnZ3JlZ2F0ZSIsInNyYyIsInNpemUiLCJvdXQiLCJpIiwic2xpY2UiLCJvIiwiaCIsIkluZmluaXR5IiwibCIsInMiLCJwdXNoIiwidCIsImJ1Y2tldEluZGljYXRvciIsInZhbHVlcyIsImJhc2VEYXRhIiwiYnVja2V0ZWRFbWEyMCIsImJ1Y2tldGVkVm9sTUEiLCJidWNrZXRlZEJvbGxpbmdlckJhbmRzIiwiYnVmZmVyUGVyUmFuZ2UiLCJidWZmZXJDYW5kbGVzIiwibWluIiwiZmxvb3IiLCJkaXNwbGF5RGF0YSIsIndpbmRvd0lkeCIsInNldFdpbmRvd0lkeCIsIndTdGFydCIsIndFbmQiLCJmdWxsU3RhcnQiLCJmdWxsRW5kIiwiZWZmZWN0aXZlU3RhcnQiLCJtYXgiLCJlZmZlY3RpdmVFbmQiLCJzYWZlRW5kIiwic2FmZVN0YXJ0IiwiZHJhd0RhdGEiLCJpbmRpY2F0b3JTdGFydCIsImluZGljYXRvckVuZCIsImVtYTIwIiwidm9sTUEiLCJib2xsaW5nZXJCYW5kcyIsImNsb3NlcyIsImhpZ2hzIiwibG93cyIsInF1YW50aWxlIiwiYXJyIiwicSIsInNvcnRlZCIsInNvcnQiLCJhIiwiYiIsInBvcyIsImJhc2UiLCJyZXN0IiwidW5kZWZpbmVkIiwibGFzdEMiLCJzcGFuIiwiUyIsIkNIQVJUX1NDQUxFIiwiaFZpc3VhbEJhc2UiLCJHUkFQSF9IRUlHSFQiLCJ2b2x1bWVQb3J0aW9uIiwiaFZpc3VhbCIsInZvbEgiLCJwcmljZUgiLCJheGlzRm9vdGVyIiwiQVhJU19GT09URVJfSEVJR0hUIiwidyIsIkdSQVBIX1dJRFRIIiwiZ3V0dGVyUmlnaHQiLCJBWElTX1JJR0hUX0dVVFRFUiIsInBhZFRvcCIsInBhZEJvdHRvbSIsInBhZExlZnQiLCJwcmljZUFyZWEiLCJ1cCIsInByaWNlVyIsIm51bUNhbmRsZXMiLCJ4Rm9ySWR4IiwiaWR4IiwiZHJhd1RpbWVzIiwiRGF0ZSIsImdldFRpbWUiLCJjYW5kbGVXaWR0aCIsImxpbmVQdHMiLCJ4IiwidmFsIiwibG9nMTAiLCJ5Iiwiam9pbiIsImhvdmVyUG9pbnQiLCJvbk1vdmUiLCJlIiwicmVjdCIsImN1cnJlbnRUYXJnZXQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRYIiwibGVmdCIsInhSYXRpbyIsIndpZHRoIiwicm91bmQiLCJkcmFnU3RhdGUiLCJvbldoZWVsIiwicHJldmVudERlZmF1bHQiLCJkZWx0YSIsImRlbHRhWSIsImZhY3RvciIsImN1cnJlbnRMZW4iLCJuZXdMZW4iLCJmb2N1c0lkeCIsIm5ld1N0YXJ0IiwibmV3RW5kIiwib25Qb2ludGVyRG93biIsInNldFBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwiY3VycmVudCIsInN0YXJ0WCIsInN0YXJ0UmFuZ2UiLCJvblBvaW50ZXJNb3ZlIiwiZUlkeCIsImxlbiIsInBpeGVsUGVyQ2FuZGxlIiwiZGVsdGFQeCIsInNoaWZ0Iiwib25Qb2ludGVyVXAiLCJuaWNlVGlja3MiLCJsb3ciLCJoaWdoIiwicmF3U3BhbiIsInJvdWdoU3RlcCIsInBvdzEwIiwicG93IiwibXVsdGlwbGVzIiwiZm91bmQiLCJmaW5kIiwibSIsInN0ZXAiLCJmaXJzdCIsInRpY2tzIiwidGltZVRpY2tzIiwic2VlbiIsIlNldCIsImZvckVhY2giLCJoaCIsImdldEhvdXJzIiwibW0iLCJnZXRNaW51dGVzIiwidGltZUtleSIsImhhcyIsImFkZCIsImxhYmVsIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwiaG91ciIsIm1pbnV0ZSIsImhvdXIxMiIsImsiLCJ0b0RhdGVTdHJpbmciLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJ3ZWVrZGF5IiwidG9VcHBlckNhc2UiLCJnZXREYXkiLCJrZXkiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsIm1vbmRheUNvdW50Iiwic2Vlbk1vbnRoIiwibWsiLCJ0b0xvY2FsZVN0cmluZyIsIm1vbnRoIiwic2VlblllYXIiLCJTdHJpbmciLCJtYXhWb2wiLCJtYWduaXR1ZGUiLCJhYnMiLCJkZWNpbWFscyIsInBlcmlvZCIsIkFycmF5IiwiZmlsbCIsInN1bSIsInN0ZERldk11bHRpcGxpZXIiLCJhdmciLCJyZWR1Y2UiLCJ2YXJpYW5jZSIsInN0ZERldiIsInNxcnQiLCJkaXYiLCJzdHlsZSIsInBvc2l0aW9uIiwiaW5zZXQiLCJmb250U2l6ZSIsInN2ZyIsInZpZXdCb3giLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwiaGVpZ2h0IiwiY3Vyc29yIiwidXNlclNlbGVjdCIsImZvbnRGYW1pbHkiLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VMZWF2ZSIsImciLCJsaW5lIiwieDEiLCJ4MiIsInkxIiwieTIiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsInRleHQiLCJBWElTX1lfTEFCRUxfWF9PRkZTRVQiLCJBWElTX1lfRk9OVF9TSVpFIiwidG9GaXhlZCIsInBvbHlnb24iLCJwb2ludHMiLCJ1cHBlclZhbCIsImlzRmluaXRlIiwibG93ZXJWYWwiLCJwb2x5bGluZSIsImZpbHRlciIsInAiLCJ2ZWN0b3JFZmZlY3QiLCJjZW50ZXJYIiwidmFsT3BlbiIsInZhbENsb3NlIiwidmFsSGlnaCIsInZhbExvdyIsIm9wZW5ZIiwiY2xvc2VZIiwiaGlnaFkiLCJsb3dZIiwicmlzaW5nIiwicGN0IiwiaW50ZW5zaXR5IiwiYmFzZUNvbG9yIiwidm9sUmF0aW8iLCJiYXJIIiwibWluQmFySGVpZ2h0IiwiY2FuZGxlRGF0ZSIsInRpbWVJbk1pbnV0ZXMiLCJtYXJrZXRPcGVuIiwibWFya2V0Q2xvc2UiLCJpc0V4dGVuZGVkSG91cnMiLCJvcGFjaXR5IiwicmF0aW8iLCJzdHJva2VEYXNoYXJyYXkiLCJjaXJjbGUiLCJjeCIsImN5IiwiciIsImxhc3QiLCJpc1VwIiwiYnJpZ2h0R3JlZW4iLCJicmlnaHRSZWQiLCJjb2xvciIsIkxBU1RfUFJJQ0VfTEFCRUxfSEVJR0hUIiwiTEFTVF9QUklDRV9MQUJFTF9XSURUSCIsInJ4IiwiTEFTVF9QUklDRV9MQUJFTF9GT05UX1NJWkUiLCJ0ZXh0QW5jaG9yIiwiZm9udFdlaWdodCIsImxhYmVscyIsImxhc3RQcmljZSIsInByaWNlWSIsImxhc3RFbWEiLCJ2YWx1ZSIsImJnQ29sb3IiLCJsYXN0VXBwZXIiLCJsYXN0TG93ZXIiLCJtaW5HYXAiLCJJTkRJQ0FUT1JfTEFCRUxfSEVJR0hUIiwiYWRqdXN0ZWRMYWJlbHMiLCJhZGp1c3RlZFkiLCJJTkRJQ0FUT1JfTEFCRUxfV0lEVEgiLCJJTkRJQ0FUT1JfTEFCRUxfRk9OVF9TSVpFIiwiQVhJU19YX0ZPTlRfU0laRSIsImhvdmVyWCIsImhvdmVyWFBlcmNlbnQiLCJsZWZ0UG9zIiwicmlnaHRQb3MiLCJ0cmFuc2Zvcm0iLCJyaWdodCIsInRvcCIsImJhY2tncm91bmQiLCJwYWRkaW5nIiwiYm9yZGVyUmFkaXVzIiwicG9pbnRlckV2ZW50cyIsImJvcmRlciIsIndoaXRlU3BhY2UiLCJiYWNrZHJvcEZpbHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/dashboard/AdvancedPriceChart.tsx\n"));

/***/ })

});